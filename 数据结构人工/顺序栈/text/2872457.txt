#include<iostream> #include<stdio.h> #include<stdlib.h> #include<malloc.h> #define Max 200 using namespace std; typedef struct{     int i;     int j;     int di; }Box; typedef struct{     Box data[Max];     int top; }SqStack;  void InitStack(SqStack*&s){   //初始化     s=(SqStack*)malloc(sizeof(SqStack));     s->top=-1; }  bool StackEmpty(SqStack * s){  //判断栈是否为空     return(s->top==-1); }  bool Push(SqStack *& s,Box e){  //入栈 注意：此时e的类型一定要是Box     if(s->top==Max-1)         return false;     s->top++;     s->data[s->top]=e;     return true; }  bool Pop(SqStack *& s,Box &e){  //出栈      if(s->top==-1)         return false;     e=s->data[s->top];     s->top--;     return true; }  bool GetTop(SqStack*s,Box &e){  //取栈顶元素     if(s->top==-1)         return false;     e=s->data[s->top];     return true; }  void DestroyStack(SqStack*&s){  //销毁栈     free(s); }   bool mgpath(int xi,int yi,int xe,int ye,int M,int N){     Box path[Max],e;     int i,j,di,il,jl,k;     bool find;     SqStack *st;     InitStack(st);     e.i=xi;     e.j=yi;     e.di=-1;     Push(st,e);     int mg[M][N];     for(int i=0;i<M;i++)         for(int j=0;j<N;j++)             cin>>mg[i][j];     mg[xi][yi]=-1;     //一定要初始化！     while(!StackEmpty(st)){  //若走到终点，则输出完整路径         GetTop(st,e);         i=e.i;         j=e.j;         di=e.di;         if(i==xe&&j==ye){             k=0;             while(!StackEmpty(st)){                 Pop(st,e);                 path[k++]=e;             }             while(k>=1){                 k--;                 cout<<path[k].i<<