 给定一个MXN的迷宫图，求一条从指定入口到出口的路径。假设迷宫图如图所示（M=8,N=8）。对于图中每个方块，空白表示通道，阴影表示墙。所求路径必须是简单路径，即在求得的路径上不能重复出现同一通道块（蓝色为入口，红色为出口）。 数据组织     为了表示迷宫，设置一个数组mg，其中每个元素表示一个方块的状态，为0时表示对应方块是通道，为1时表示对应方块是墙，不可走。为了算法方便，在迷宫外围加了一道围墙。图所示的迷宫对应的迷宫数组mg（由于迷宫四周加了一道围墙，故mg的行数和列数均加10）如下： int mg[m+2][n+2]= { {1,1,1,1,1,1,1,1,1,1},   {1,0,0,1,0,0,0,1,0,1},   {1,0,0,1,0,0,0,1,0,1},   {1,0,0,0,0,1,1,0,0,1},   {1,0,1,1,1,0,0,0,0,1},   {1,0,0,0,1,0,0,0,0,1},   {1,0,1,0,0,0,1,0,0,1},   {1,0,1,1,1,0,1,1,0,1},   {1,1,0,0,0,0,0,0,0,1},   {1,1,1,1,1,1,1,1,1,1}}; 另外，在算法中用到的栈采用顺序栈存储结构，即将栈定义为： typedef struct { int i;//当前方块行号 int j;//当前方块列号 int di;//下一个可走的相邻方块的方位号 }Box;//定义方块类型     #include <stdio.h> #include<stdlib.h> int mg[10][10]= {{1,1,1,1,1,1,1,1,1,1}, {1,0,0,1,0,0,0,1,0,1}, {1,0,0,1,0,0,0,1,0,1}, {1,0,0,0,0,1,1,0,0,1}, {1,0,1,1,1,0,0,0,0,1}, {1,0,0,0,1,0,0,0,0,1}, {1,0,1,0,0,0,1,0,0,1}, {1,0,1,1,1,0,1,1,0,1}, {1,1,0,0,0,0,0,0,0,1}, {1,1,1,1,1,1,1,1,1,1} };//地图 int M=8;//行数 int N=8;//列数 typedef struct { int i;//当前方块行号 int j;//当前方块列号 int di;//下一个可走的相邻方块的方位号 } Box; //定义方块类型 typedef struct { Box data[100]; int top;//栈顶指针 } StType; //定义顺序栈类型 bool mgpath(int xi,int yi,int xe,int ye)//求解路径为：(xi,yi)->(xe,ye) { int i,j,k,di,find; StType st;//定义栈st st.top=-1;//初始化栈顶指针 st.top++;//初始方块进栈 st.data[st.top].i=xi; st.data[st.top].j=yi; st.data[st.top].di=-1; mg[xi][yi]=-1; while(st.top>-1)//栈不为空时循环 { i=st.data[st.top].i; j=st.data[st.top].j; di=st.data[st.top].di;//取栈顶方块 if(i==xe&&j==ye)//找到出口，输出路径 { printf(