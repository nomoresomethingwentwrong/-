{
    "code":200,
    "msg":"成功",
    "data":[
        {
            "assembleId":2870245,
            "assembleContent":"<h1><p><span style="font-size: medium;">将单链表转换为双向循环链表 </span></p><pre><code>typedef struct dlnode<br>{<br>    int data;<br>    struct dlnode *next,*prior;<br>} DLNode,*DLinkList;<br> <br>DLinkList Creat_DLinkList(LinkList L)<br>{<br>    DLinkList H;<br>    DLNode *s,,*p,*rear;<br>    H=(DLNode*)malloc(sizeof(DLNode));//生成H的头结点<br>    H->next=H;//构造H为空的双向循环链表<br>    H->prior=H;<br>    rear=H;<br>    p=L->next;//p指向L的第一个结点<br>    while(p)<br>    {<br>        s=(DLNode*)malloc(sizeof(DLNode));<br>        s->data=p->data;//申请、填充结点<br>        s->next=rear->next;<br>        s->prior=rear;<br>        rear->next=s;<br>        H->prior=s;//结点s插到H的链表尾<br>        rear=s;//修改H的尾指针rear<br>        p=p->next;<br>    }<br>    return H;<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"将单链表转换为双向循环链表  typedef struct dlnode {     int data;     struct dlnode *next,*prior; } DLNode,*DLinkList;  DLinkList Creat_DLinkList(LinkList L) {     DLinkList H;     DLNode *s,,*p,*rear;     H=(DLNode*)malloc(sizeof(DLNode));//生成H的头结点     H->next=H;//构造H为空的双向循环链表     H->prior=H;     rear=H;     p=L->next;//p指向L的第一个结点     while(p)     {         s=(DLNode*)malloc(sizeof(DLNode));         s->data=p->data;//申请、填充结点         s->next=rear->next;         s->prior=rear;         rear->next=s;         H->prior=s;//结点s插到H的链表尾         rear=s;//修改H的尾指针rear         p=p->next;     }     return H; }  ",
            "assembleScratchTime":"2019-04-05 13:24:05",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870246,
            "assembleContent":"<h1><p><strong style="font-size: medium;">两个递增有序的单链表A和B，合成链表C，不改变排序性。</strong></p><pre><code>#include <stdio.h><br>#include <stdlib.h><br>#include <malloc.h><br>#define maxsize 1000<br>typedef struct<br>{<br>    int data[maxsize];<br>    int last;<br>} seqlist;<br> <br>seqlist *init_seqlist(int arrsize)<br>{<br>    seqlist *L;<br>    L=(seqlist *)malloc(sizeof(seqlist));<br>    L->last=arrsize-1;<br>    return L;<br>}<br> <br>void input(seqlist *A)<br>{<br>    int i;<br>    for(i=0; i<=A->last; i++)<br>    {<br>        scanf("%d",&A->data[i]);<br>    }<br>}<br> <br>void bubblesort(seqlist *A)//j将表进行冒泡排序<br>{<br>    int i,j,temp;<br>    for(i=0; i<A->last; i++)<br>    {<br>        for(j=i+1; j<A->last+1; j++)<br>        {<br>            if(A->data[j]<A->data[i])<br>            {<br>                temp=A->data[j];<br>                A->data[j]=A->data[i];<br>                A->data[i]=temp;<br>            }<br>        }<br>    }<br>}<br> <br>seqlist * merge(seqlist *A,seqlist *B,seqlist *C)<br>{<br>    int i=0,j=0,k=0;<br>    while(i<=A->last&&j<=B->last)<br>    {<br>        if(A->data[i]<B->data[j])<br>        {<br>            C->data[k++]=A->data[i++];<br>        }<br>        else<br>        {<br>            C->data[k++]=B->data[j++];<br>        }<br>    }<br>    while(i<=A->last)//表B先结束<br>    {<br>        C->data[k++]=A->data[i++];<br>    }<br>    while(j<=B->last)//表A先结束<br>    {<br>        C->data[k++]=B->data[j++];<br>    }<br>    C->last=k-1;<br>    return C;<br>}<br> <br>int main()<br>{<br>    int i,arrsize1,arrsize2;<br>    seqlist *A,*B,*C;<br>    C=(seqlist *)malloc(sizeof(seqlist));<br>    scanf("%d",&arrsize1);<br>    A=init_seqlist(arrsize1);<br>    input(A);<br>    scanf("%d",&arrsize2);<br>    B=init_seqlist(arrsize2);<br>    input(B);<br>    bubblesort(A);<br>    bubblesort(B);<br>    C=merge(A,B,C);<br>    for(i=0;i<=C->last;i++)<br>    {<br>        printf("%d ",C->data[i]);<br>    }<br>  return 0;<br>}</code></pre><p><br></p></h1>  ",
            "assembleText":"两个递增有序的单链表A和B，合成链表C，不改变排序性。 #include <stdio.h> #include <stdlib.h> #include <malloc.h> #define maxsize 1000 typedef struct {     int data[maxsize];     int last; } seqlist;  seqlist *init_seqlist(int arrsize) {     seqlist *L;     L=(seqlist *)malloc(sizeof(seqlist));     L->last=arrsize-1;     return L; }  void input(seqlist *A) {     int i;     for(i=0; i<=A->last; i++)     {         scanf("%d",&A->data[i]);     } }  void bubblesort(seqlist *A)//j将表进行冒泡排序 {     int i,j,temp;     for(i=0; i<A->last; i++)     {         for(j=i+1; j<A->last+1; j++)         {             if(A->data[j]<A->data[i])             {                 temp=A->data[j];                 A->data[j]=A->data[i];                 A->data[i]=temp;             }         }     } }  seqlist * merge(seqlist *A,seqlist *B,seqlist *C) {     int i=0,j=0,k=0;     while(i<=A->last&&j<=B->last)     {         if(A->data[i]<B->data[j])         {             C->data[k++]=A->data[i++];         }         else         {             C->data[k++]=B->data[j++];         }     }     while(i<=A->last)//表B先结束     {         C->data[k++]=A->data[i++];     }     while(j<=B->last)//表A先结束     {         C->data[k++]=B->data[j++];     }     C->last=k-1;     return C; }  int main() {     int i,arrsize1,arrsize2;     seqlist *A,*B,*C;     C=(seqlist *)malloc(sizeof(seqlist));     scanf("%d",&arrsize1);     A=init_seqlist(arrsize1);     input(A);     scanf("%d",&arrsize2);     B=init_seqlist(arrsize2);     input(B);     bubblesort(A);     bubblesort(B);     C=merge(A,B,C);     for(i=0;i<=C->last;i++)     {         printf("%d ",C->data[i]);     }   return 0; }",
            "assembleScratchTime":"2019-04-05 13:24:57",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870247,
            "assembleContent":"<h1><p><span style="font-size: medium;">已知带头结点的单链表L中的结点是按整数值递增排列的，试写一算法，将值为x的结点插入到表L中，使得L仍然递增有序（这里我们将插入和排序用一个函数完成，不用排序和插入两个函数实现） </span></p><pre><code>#include <stdio.h><br>#include <stdlib.h><br>#define maxsize 1000<br>typedef struct node<br>{<br>    int data;<br>    struct lnode *next;<br>} LNode,*LinkList;<br> <br>LinkList init_LNode()<br>{<br>    LinkList L;<br>    L=(LinkList)malloc(sizeof(LNode));<br>    L->data=0;<br>    L->next=NULL;<br>    return L;<br>}<br> <br>LinkList insert_linklist(LinkList L,int insert_data)<br>{<br>    LNode *p,*q,*s;<br>    p=L->next;<br>    q=p;<br>    while(p!=NULL&&insert_data<p->data)<br>    {<br>        q=p;//q记录前驱结点<br>        p=p->next;<br>    }<br>    if(p==NULL)//为空代表走到了最后或表开始为空<br>    {<br>        s=(LinkList)malloc(sizeof(LNode));<br>        s->data=insert_data;<br>        s->next=NULL;<br>        q->next=s;<br>    }<br>    else<br>    {<br>        s=(LinkList)malloc(sizeof(LNode));<br>        s->data=insert_data;<br>        s->next=p;<br>        q->next=s;<br>    }<br>    return L;<br>}<br> <br>void output_link(LinkList L)<br>{<br>    LNode *p;<br>    p=L->next;<br>    while(p!=NULL)<br>    {<br>        printf("%d ",p->data);<br>        p=p->next;<br>    }<br>}<br> <br>int main()<br>{<br>    int input_data;<br>    LinkList L=init_LNode();<br>    printf("please input the data for the list,100 represent the end\n");<br>    scanf("%d",&input_data);<br>    while(input_data!=100)<br>    {<br>        L=insert_linklist(L,input_data);<br>        scanf("%d",&input_data);<br>    }<br>    output_link(L);//输入结束，输出该表内容<br>    printf("please input the insert data:");<br>    scanf("%d",&input_data);<br>    L=insert_linklist(L,input_data);<br>    output_link(L);<br>    return 0;<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"已知带头结点的单链表L中的结点是按整数值递增排列的，试写一算法，将值为x的结点插入到表L中，使得L仍然递增有序（这里我们将插入和排序用一个函数完成，不用排序和插入两个函数实现）  #include <stdio.h> #include <stdlib.h> #define maxsize 1000 typedef struct node {     int data;     struct lnode *next; } LNode,*LinkList;  LinkList init_LNode() {     LinkList L;     L=(LinkList)malloc(sizeof(LNode));     L->data=0;     L->next=NULL;     return L; }  LinkList insert_linklist(LinkList L,int insert_data) {     LNode *p,*q,*s;     p=L->next;     q=p;     while(p!=NULL&&insert_data<p->data)     {         q=p;//q记录前驱结点         p=p->next;     }     if(p==NULL)//为空代表走到了最后或表开始为空     {         s=(LinkList)malloc(sizeof(LNode));         s->data=insert_data;         s->next=NULL;         q->next=s;     }     else     {         s=(LinkList)malloc(sizeof(LNode));         s->data=insert_data;         s->next=p;         q->next=s;     }     return L; }  void output_link(LinkList L) {     LNode *p;     p=L->next;     while(p!=NULL)     {         printf("%d ",p->data);         p=p->next;     } }  int main() {     int input_data;     LinkList L=init_LNode();     printf("please input the data for the list,100 represent the end\n");     scanf("%d",&input_data);     while(input_data!=100)     {         L=insert_linklist(L,input_data);         scanf("%d",&input_data);     }     output_link(L);//输入结束，输出该表内容     printf("please input the insert data:");     scanf("%d",&input_data);     L=insert_linklist(L,input_data);     output_link(L);     return 0; }  ",
            "assembleScratchTime":"2019-04-05 13:25:25",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870248,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表的逆置 </span></p><pre><code>typedef struct lnode<br>{<br>    int data;<br>    struct lnode *next;<br>}LNode,*LinkList;<br> <br>void reverse(LinkList* L)<br>{<br>    LNode *p;<br>    p=L->next; //p指向第一个数据结点<br>    L->next=NULL;//将原链表置为空<br>    while(p)<br>    {<br>        q=p;//q为p的前驱结点<br>        p=p->next;<br>        q->next=L->next;//头插法实现逆转<br>        L->nect=q;<br>    }<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"单链表的逆置  typedef struct lnode {     int data;     struct lnode *next; }LNode,*LinkList;  void reverse(LinkList* L) {     LNode *p;     p=L->next; //p指向第一个数据结点     L->next=NULL;//将原链表置为空     while(p)     {         q=p;//q为p的前驱结点         p=p->next;         q->next=L->next;//头插法实现逆转         L->nect=q;     } }  ",
            "assembleScratchTime":"2019-04-05 13:26:12",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870249,
            "assembleContent":"<h1><p><span style="font-size: medium;">删除一链表中的重复结点 </span></p><pre><code>typedef struct lnode<br>{<br>    int data;<br>    struct lnode *next;<br>}LNode,*LinkList;<br> <br>void put_linklist(LinkList *L)<br>{<br>    LinkList *q,*p,*r;<br>    p=L->next;//p指向第一个数据结点<br>    while(p->next)//p作为基准比较<br>    {<br>        q=p;<br>        if(p==NULL)return;<br>        while(q->next)//q作为待删前驱结点  <br>        {<br>            if(q->next->data==p->data)<br>            {<br>                r=q->next;//r为待删结点<br>                q->next=r->next;<br>                free(r);<br>            }<br>            q=q->next;<br>        }<br>        p=p->next;<br>    }<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"删除一链表中的重复结点  typedef struct lnode {     int data;     struct lnode *next; }LNode,*LinkList;  void put_linklist(LinkList *L) {     LinkList *q,*p,*r;     p=L->next;//p指向第一个数据结点     while(p->next)//p作为基准比较     {         q=p;         if(p==NULL)return;         while(q->next)//q作为待删前驱结点          {             if(q->next->data==p->data)             {                 r=q->next;//r为待删结点                 q->next=r->next;                 free(r);             }             q=q->next;         }         p=p->next;     } }  ",
            "assembleScratchTime":"2019-04-05 13:26:26",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870251,
            "assembleContent":"<h1><p><span style="font-size: medium;">有两个单链表A，B，其中元素递增且有序，编写算法将A，B归并成一个按元素之递减（允许有相同值）有序的链表C，要求用A，B中的原结点形成，不能重新申请结点 </span></p><pre><code>typedef struct lnode<br>{<br>    int data;<br>    struct lnode *next;<br>}LNode,*LinkList;<br> <br>LinkList merge(LinkList A,LinkList B)//设A，B为带头结点的单链表<br>{<br>    LNode *p,*q,*s;LinkList C;<br>    p=A->next;q=B->next;<br>    C=A;<br>    free(B);<br>    while(p&&q)<br>    {<br>        if(p->data<q->data)//从原A，B中取下较小者<br>        {<br>            s=p;p=p->next;<br>        }<br>        else<br>        {<br>            s=q;q=q->next;<br>        }<br>        s->next=C->next;//插到C的头部<br>        C->next=s;<br>    }<br>    if(p==NULL)p=q;//p已结束<br>    while(p)//将剩余的结点一个个摘下，插到C表的头部<br>    {<br>        s=p;p=p->next;<br>        s->next=C->next;<br>        C->next=s;<br>    }<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"有两个单链表A，B，其中元素递增且有序，编写算法将A，B归并成一个按元素之递减（允许有相同值）有序的链表C，要求用A，B中的原结点形成，不能重新申请结点  typedef struct lnode {     int data;     struct lnode *next; }LNode,*LinkList;  LinkList merge(LinkList A,LinkList B)//设A，B为带头结点的单链表 {     LNode *p,*q,*s;LinkList C;     p=A->next;q=B->next;     C=A;     free(B);     while(p&&q)     {         if(p->data<q->data)//从原A，B中取下较小者         {             s=p;p=p->next;         }         else         {             s=q;q=q->next;         }         s->next=C->next;//插到C的头部         C->next=s;     }     if(p==NULL)p=q;//p已结束     while(p)//将剩余的结点一个个摘下，插到C表的头部     {         s=p;p=p->next;         s->next=C->next;         C->next=s;     } }  ",
            "assembleScratchTime":"2019-04-05 13:26:56",
            "facetId":556159,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870252,
            "assembleContent":"<h1><p><span style="font-size: medium;">手动输入一个<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">线性链表</a>，然后通过Treserve( Sqlist &L,visit())遍历该线性表中的每个元素，并输出。</span> </p><pre><code>#include <stdio.h><br>#include <stdlib.h><br>#include <malloc.h><br>typedef char ElemType;<br>typedef struct Node<br>{<br>ElemType data;<br>struct Node *next;<br>}Node,*Sqlist;<br>void IniList(Sqlist *L) /*初始化*/<br>{<br>*L=(Sqlist)malloc(sizeof(Node));<br>(*L)->next=*L;<br>}<br>void Create_cLinkList(Sqlist L) /*尾插法建立链表*/<br>{<br>Node *s;<br>char c;<br>int flag=1;<br>L->data=NULL;<br>while(flag)<br>{<br>c=getchar();<br>if(c!='$')<br>{<br>s=(Node *)malloc(sizeof(Node));<br>s->data=c;<br>s->next=L->next;<br>L->next=s;<br>}<br>else<br>flag=0;<br>}<br>}<br>void visit(Node *p)<br>{<br>printf("%c",p->data);<br>}<br>void Treserve( Sqlist &L,void (*visit)(Node *p))</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"手动输入一个线性链表，然后通过Treserve( Sqlist &L,visit())遍历该线性表中的每个元素，并输出。  #include <stdio.h> #include <stdlib.h> #include <malloc.h> typedef char ElemType; typedef struct Node { ElemType data; struct Node *next; }Node,*Sqlist; void IniList(Sqlist *L) /*初始化*/ { *L=(Sqlist)malloc(sizeof(Node)); (*L)->next=*L; } void Create_cLinkList(Sqlist L) /*尾插法建立链表*/ { Node *s; char c; int flag=1; L->data=NULL; while(flag) { c=getchar(); if(c!='$') { s=(Node *)malloc(sizeof(Node)); s->data=c; s->next=L->next; L->next=s; } else flag=0; } } void visit(Node *p) { printf("%c",p->data); } void Treserve( Sqlist &L,void (*visit)(Node *p))  ",
            "assembleScratchTime":"2019-04-05 13:27:44",
            "facetId":556159,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/458090259.html",
            "type":"text"
        },
        {
            "assembleId":2870379,
            "assembleContent":"<p>C语言</p><pre>#include <stdio.h>
#include <process.h>

struct Student{
    char cName[20];    //姓名 
    int iNumber;    //学号 
    struct Student *pNext;    //指向下一个结点的地址 
}; 

int iCount;    //全局变量，用来表示链表长度 

//创建链表返回链表的头指针 
struct Student *Create(){
    struct Student *pHead = NULL;    //定义头指针
    struct Student *pEnd, *pNew;    //最后一个结点和新的结点
    
    iCount = 0;    //初始化链表长度
    
    //给最后 一个结点和新结点分配内存空间 
    pEnd = pNew = (struct Student *)malloc(sizeof(struct Student)); 
    //提示让其输入姓名和 学号 
     printf("please enter the name,then the number\n");
     scanf("%s", &pNew->cName);
     scanf("%d", &pNew->iNumber);
     
     //判断输入的学号是否为0，不为0就进行处理 
     while(pNew->iNumber    !=0){
         iCount++;    //结点加1
        if(iCount == 1){
            pHead = pNew;    //头指针指向下个结点的地址 
            pNew->pNext = pHead;
            pEnd = pNew;    //pEnd这是跟踪的指针结点 
        }else{
            pEnd->pNext = pNew;    //让之前的元素的指针指向下一个结点的地址 
            pNew->pNext = NULL;    //让当前的元素的指针域指向NULL 
            pEnd = pNew;
        }
        //再给pNew分配内存空间 
        pNew = (struct Student *)malloc(sizeof(struct Student)); 
         printf("please enter the name,then the number\n");
         scanf("%s", &pNew->cName);
         scanf("%d", &pNew->iNumber);
     }
     free(pNew);
     return pHead;
}
</pre><p><br></p> ",
            "assembleText":"C语言 #include <stdio.h>
#include <process.h>

struct Student{
    char cName[20];    //姓名 
    int iNumber;    //学号 
    struct Student *pNext;    //指向下一个结点的地址 
}; 

int iCount;    //全局变量，用来表示链表长度 

//创建链表返回链表的头指针 
struct Student *Create(){
    struct Student *pHead = NULL;    //定义头指针
    struct Student *pEnd, *pNew;    //最后一个结点和新的结点
    
    iCount = 0;    //初始化链表长度
    
    //给最后 一个结点和新结点分配内存空间 
    pEnd = pNew = (struct Student *)malloc(sizeof(struct Student)); 
    //提示让其输入姓名和 学号 
     printf("please enter the name,then the number\n");
     scanf("%s", &pNew->cName);
     scanf("%d", &pNew->iNumber);
     
     //判断输入的学号是否为0，不为0就进行处理 
     while(pNew->iNumber    !=0){
         iCount++;    //结点加1
        if(iCount == 1){
            pHead = pNew;    //头指针指向下个结点的地址 
            pNew->pNext = pHead;
            pEnd = pNew;    //pEnd这是跟踪的指针结点 
        }else{
            pEnd->pNext = pNew;    //让之前的元素的指针指向下一个结点的地址 
            pNew->pNext = NULL;    //让当前的元素的指针域指向NULL 
            pEnd = pNew;
        }
        //再给pNew分配内存空间 
        pNew = (struct Student *)malloc(sizeof(struct Student)); 
         printf("please enter the name,then the number\n");
         scanf("%s", &pNew->cName);
         scanf("%d", &pNew->iNumber);
     }
     free(pNew);
     return pHead;
}",
            "assembleScratchTime":"2019-04-05 14:01:12",
            "facetId":556159,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870380,
            "assembleContent":"<p>C语言</p><pre><p>//输出链表<br>void Print(struct Student *pHead){<br>    struct Student *pTemp;    //定义一个临时指针<br>    int iIndex = 0;    //用来计算有多少个指针输出<br>    <br>    printf("=====the links has %d element======\n", iCount);<br>    printf("|iIndex|   name   |iNumber|\n");<br>    pTemp = pHead;<br>    while(pTemp != NULL){<br>        iIndex++;<br>        printf("%6d", iIndex);<br>        printf("%10s", pTemp->cName);<br>        printf("%7d\n", pTemp->iNumber);<br>        pTemp = pTemp->pNext; <br>    }<br>    printf("===================================\n");<br>} <br></p></pre> ",
            "assembleText":"C语言 //输出链表 void Print(struct Student *pHead){     struct Student *pTemp;    //定义一个临时指针     int iIndex = 0;    //用来计算有多少个指针输出         printf("=====the links has %d element======\n", iCount);     printf("|iIndex|   name   |iNumber|\n");     pTemp = pHead;     while(pTemp != NULL){         iIndex++;         printf("%6d", iIndex);         printf("%10s", pTemp->cName);         printf("%7d\n", pTemp->iNumber);         pTemp = pTemp->pNext;     }     printf("===================================\n"); }",
            "assembleScratchTime":"2019-04-05 14:01:25",
            "facetId":556159,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870382,
            "assembleContent":"<p>C语言</p><pre><p>

</p><pre>//插入元素,只需要头指针就行,并返回头指针 
struct Student *Insert(struct Student *pHead){
    struct Student *pNew;
    pNew = (struct Student *)malloc(sizeof(struct Student));    //分配内存空间
    printf("请输入name和number :\n");
    scanf("%s", &pNew->cName);
    scanf("%d", &pNew->iNumber);
    pNew->pNext = pHead;
    pHead = pNew; 
    iCount++;    
    return pHead;
} </pre><p>

</p></pre> ",
            "assembleText":"C语言 

 //插入元素,只需要头指针就行,并返回头指针 
struct Student *Insert(struct Student *pHead){
    struct Student *pNew;
    pNew = (struct Student *)malloc(sizeof(struct Student));    //分配内存空间
    printf("请输入name和number :\n");
    scanf("%s", &pNew->cName);
    scanf("%d", &pNew->iNumber);
    pNew->pNext = pHead;
    pHead = pNew; 
    iCount++;    
    return pHead;
}",
            "assembleScratchTime":"2019-04-05 14:01:35",
            "facetId":556159,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870383,
            "assembleContent":"<p>C语言</p><pre><code>//删除元素， 传一个头指针，以及第几个元素,无返回值<br>void Delete(struct Student *pHead, int iIndex){<br>    int i;    //用于循环<br>    struct Student *pPre;    //定义前一个结构体指针变量 <br>    struct Student *pTemp;    //定义要删除的结构体指针变量 <br>    pPre = pTemp = pHead;    //都指向pHead <br>    <br>    //循环的目的是让pTemp为要删除的结点，pPre为其前面一个结点 <br>    for(i=1; i<iIndex; i++){<br>        pPre = pTemp;<br>        pTemp = pTemp->pNext; <br>    }<br>    <br>    pPre->pNext = pTemp->pNext;    //删除pTemp结点<br>    free(pTemp);<br>    iCount--; <br>}</code></pre><p><br></p> ",
            "assembleText":"C语言 //删除元素， 传一个头指针，以及第几个元素,无返回值 void Delete(struct Student *pHead, int iIndex){     int i;    //用于循环     struct Student *pPre;    //定义前一个结构体指针变量     struct Student *pTemp;    //定义要删除的结构体指针变量     pPre = pTemp = pHead;    //都指向pHead         //循环的目的是让pTemp为要删除的结点，pPre为其前面一个结点     for(i=1; i<iIndex; i++){         pPre = pTemp;         pTemp = pTemp->pNext;     }         pPre->pNext = pTemp->pNext;    //删除pTemp结点     free(pTemp);     iCount--; }",
            "assembleScratchTime":"2019-04-05 14:01:48",
            "facetId":556159,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870385,
            "assembleContent":"<p>C语言</p><pre><code><p>//写入文件<br>void Save(struct Student *pHead){<br>    FILE *p;    //定义一个文件指针 <br>    struct Student *pTemp;    //定义一个结构体指针变量 <br>    p = fopen("data.txt", "a+");<br>    if(p == NULL){<br>        printf("打开文件失败!\n");<br>    }<br>    pTemp = pHead;<br>    while(pTemp!=NULL){<br>        //fputs(pTemp->cName, p);<br>        fprintf(p, "%15s", pTemp->cName);<br>        fprintf(p, "%10d", pTemp->iNumber);<br>        fputs("\n", p);<br>        pTemp = pTemp->pNext;<br>    }<br>    fclose(p);    //关闭指针 <br>} <br></p>    pPre->pNext = pTemp->pNext;    //删除pTemp结点<br>    free(pTemp);<br>    iCount--; <br>}</code></pre><p><br></p> ",
            "assembleText":"C语言 //写入文件 void Save(struct Student *pHead){ FILE *p; //定义一个文件指针 struct Student *pTemp; //定义一个结构体指针变量 p = fopen("data.txt", "a+"); if(p == NULL){ printf("打开文件失败!\n"); } pTemp = pHead; while(pTemp!=NULL){ //fputs(pTemp->cName, p); fprintf(p, "%15s", pTemp->cName); fprintf(p, "%10d", pTemp->iNumber); fputs("\n", p); pTemp = pTemp->pNext; } fclose(p); //关闭指针 }     pPre->pNext = pTemp->pNext;    //删除pTemp结点     free(pTemp);     iCount--; }",
            "assembleScratchTime":"2019-04-05 14:02:01",
            "facetId":556159,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870154,
            "assembleContent":"<h3><p>链式存储：用的任意存储单元存储线性表的数据元素</p><p>其由数据域和指针域构成</p><p>所以又分成单链表和双向链表</p></h3><h3><br></h3> ",
            "assembleText":"链式存储：用的任意存储单元存储线性表的数据元素 其由数据域和指针域构成 所以又分成单链表和双向链表",
            "assembleScratchTime":"2019-04-05 12:52:12",
            "facetId":556138,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zfw50537381/article/details/6518463",
            "type":"text"
        },
        {
            "assembleId":2870155,
            "assembleContent":"<h2><span style="font-size: medium;">链式表示指的是用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息<i>（即直接后继的存储位置）</i>，这两部分信息组成数据元素的存储映像，称为结点<i>（node）</i>。它包括两个域；存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称为指针或链  </span></h2> ",
            "assembleText":"链式表示指的是用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素的存储映像，称为结点（node）。它包括两个域；存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称为指针或链  ",
            "assembleScratchTime":"2019-04-05 12:52:40",
            "facetId":556138,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2870156,
            "assembleContent":"<h2><span style="font-size: medium;"><b>单向链表</b>（又名单链表、线性链表）是<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" title="链表">链表</a>的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。  </span></h2>  ",
            "assembleText":"单向链表（又名单链表、线性链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。  ",
            "assembleScratchTime":"2019-04-06 21:22:22",
            "facetId":556138,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870165,
            "assembleContent":"<h2><span style="font-size: medium;"><b>链表</b>（<span lang="en">Linked list</span>）是一种常见的基础数据结构，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8" title="线性表">线性表</a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="指针 (计算机科学)">指针</a>(<span lang="en">Pointer</span>)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的<a href="https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6" title="复杂度">复杂度</a>，比另一种线性表<a href="https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E8%A1%A8" title="顺序表">顺序表</a>快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。  </span></h2> ",
            "assembleText":"链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。  ",
            "assembleScratchTime":"2019-04-05 12:56:36",
            "facetId":556138,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870168,
            "assembleContent":"<h2><span style="font-size: medium;">在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</span></h2> ",
            "assembleText":"在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。",
            "assembleScratchTime":"2019-04-05 12:58:15",
            "facetId":556138,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870169,
            "assembleContent":"<h2><span style="font-size: medium;">链表可以在多种编程语言中实现。像<a href="https://zh.wikipedia.org/wiki/Lisp" title="Lisp">Lisp</a>和<a href="https://zh.wikipedia.org/wiki/Scheme" title="Scheme">Scheme</a>这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。</span></h2> ",
            "assembleText":"链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。",
            "assembleScratchTime":"2019-04-05 12:58:30",
            "facetId":556138,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870397,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/863580145/786945645.jpg" style="max-width:100%;"><br></p>  ",
            "assembleText":"",
            "assembleScratchTime":"2019-04-05 14:04:23",
            "facetId":556138,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/332129079.html",
            "type":"text"
        },
        {
            "assembleId":2870409,
            "assembleContent":"<p><em><strong>单链表的基本结构： </strong></em> <img src="http://yotta.xjtushilei.com:8090/863580233/485780896.png" style="max-width: 100%;"> </p>  ",
            "assembleText":"单链表的基本结构：   ",
            "assembleScratchTime":"2019-04-05 14:07:07",
            "facetId":556138,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870435,
            "assembleContent":"<p>In <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, a <b>Linked list</b> is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)" title="Pointer (computer programming)">points</a> to the next. It is a <a href="https://en.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> consisting of a collection of <a href="https://en.wikipedia.org/wiki/Node_(computer_science)" title="Node (computer science)">nodes</a> which together represent a <a href="https://en.wikipedia.org/wiki/Sequence" title="Sequence">sequence</a>. In its most basic form, each node contains: <a href="https://en.wikipedia.org/wiki/Data_(computing)" title="Data (computing)">data</a>, and a <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" title="Reference (computer science)">reference</a> (in other words, a <i>link</i>) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More complex variants add additional links, allowing more efficient insertion or removal of nodes at arbitrary positions. A drawback of linked lists is that access time is linear (and difficult to <a href="https://en.wikipedia.org/wiki/Instruction_pipelining" title="Instruction pipelining">pipeline</a>). Faster access, such as random access, is not feasible. <a href="https://en.wikipedia.org/wiki/Array_data_structure" title="Array data structure">Arrays</a> have better <a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Locality of reference">cache locality</a> compared to linked lists.  <br></p><p><br></p> ",
            "assembleText":"In computer science, a Linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element points to the next. It is a data structure consisting of a collection of nodes which together represent a sequence. In its most basic form, each node contains: data, and a reference (in other words, a link) to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More complex variants add additional links, allowing more efficient insertion or removal of nodes at arbitrary positions. A drawback of linked lists is that access time is linear (and difficult to pipeline). Faster access, such as random access, is not feasible. Arrays have better cache locality compared to linked lists.  ",
            "assembleScratchTime":"2019-04-05 14:19:18",
            "facetId":556138,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870436,
            "assembleContent":"<p><a href="https://en.wikipedia.org/wiki/File:Singly-linked-list.svg"><img alt="Singly-linked-list.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" decoding="async" width="408" height="41" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/612px-Singly-linked-list.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/816px-Singly-linked-list.svg.png 2x"></a><br><small><i>A linked list whose nodes contain two fields: an integer value and a link to the next node. The last node is linked to a terminator used to signify the end of the list.</i></small>  <br></p> ",
            "assembleText":"A linked list whose nodes contain two fields: an integer value and a link to the next node. The last node is linked to a terminator used to signify the end of the list.  ",
            "assembleScratchTime":"2019-04-05 14:19:30",
            "facetId":556138,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2862580,
            "assembleContent":"<p>逻辑结构：数据之间的相互关系。<br></p><ul><li>集合 结构中的数据元素除了同属于一种类型外，别无其它关系。</li><li>线性结构 数据元素之间一对一的关系</li><li>树形结构 数据元素之间一对多的关系</li><li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系</li></ul> ",
            "assembleText":"逻辑结构：数据之间的相互关系。 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。 线性结构 数据元素之间一对一的关系 树形结构 数据元素之间一对多的关系 图状结构或网状结构 结构中的数据元素之间存在多对多的关系",
            "assembleScratchTime":"2019-03-18 09:29:29",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862585,
            "assembleContent":"<ol><li>时间复杂度：算法的执行时间与原操作<strong>执行次数</strong>之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)、O(n<sup>3</sup>)。幂次时间复杂度有小到大O(2<sup>n</sup>)、O(n!)、O(n<sup>n</sup>)</li></ol> ",
            "assembleText":"时间复杂度：算法的执行时间与原操作执行次数之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)、O(n3)。幂次时间复杂度有小到大O(2n)、O(n!)、O(nn)",
            "assembleScratchTime":"2019-03-18 09:30:34",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862596,
            "assembleContent":"<div><ol><li>空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析<strong>除输入和程序之外的辅助变量所占额外空间</strong>。</li></ol></div> ",
            "assembleText":"空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。",
            "assembleScratchTime":"2019-03-18 09:31:47",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862601,
            "assembleContent":"<div>数据类型：在一种程序设计语言中，变量所具有的数据种类。<a href="https://www.baidu.com/s?wd=%E6%95%B4%E5%9E%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank">整型</a>、浮点型、字符型等等  <br></div> ",
            "assembleText":"数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、浮点型、字符型等等  ",
            "assembleScratchTime":"2019-03-18 09:32:33",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862612,
            "assembleContent":"<div><h2 id="线性表">线性表</h2><p>线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)</p></div> ",
            "assembleText":"线性表 线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1)",
            "assembleScratchTime":"2019-03-18 09:33:47",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862617,
            "assembleContent":"<h2 id="线性表"><p>线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先估计存储空间大小。 <br><br></p></h2> ",
            "assembleText":"线性链表：用一组任意的存储单元来依次存放线性表的结点，这组存储单元即可以是连续的，也可以是不连续的，甚至是零散分布在内存中的任意位置上的。因此，链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址。data域是数据域，用来存放结点的值。next是指针域（亦称链域），用来存放结点的直接后继的地址（或位置）。不需要事先估计存储空间大小。",
            "assembleScratchTime":"2019-03-18 09:35:22",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862628,
            "assembleContent":"<h2 id="线性表"><p><strong>单链表</strong>中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。  <br><br></p></h2> ",
            "assembleText":"单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。  ",
            "assembleScratchTime":"2019-03-18 09:36:47",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862633,
            "assembleContent":"<h2 id="线性表"><ul><li>静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。</li></ul><p> <br><br></p></h2> ",
            "assembleText":"静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。  ",
            "assembleScratchTime":"2019-03-18 09:37:26",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862644,
            "assembleContent":"<h2 id="线性表"><ul><li>循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。   <br></li></ul><p> <br><br></p></h2> ",
            "assembleText":"循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。     ",
            "assembleScratchTime":"2019-03-18 09:38:36",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862649,
            "assembleContent":"<h2 id="线性表"><ul><li>双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。  <br></li></ul><p><br></p></h2> ",
            "assembleText":"双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。  ",
            "assembleScratchTime":"2019-03-18 09:39:13",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862660,
            "assembleContent":"<h3 id="栈">栈</h3><h2 id="线性表"><div><p>栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增</p></div></h2><h2><p><br></p></h2> ",
            "assembleText":"栈 栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。先进后出。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增",
            "assembleScratchTime":"2019-03-18 09:40:43",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862665,
            "assembleContent":"<h3 id="队列">队列</h3><h3 id="栈"><p>队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。</p></h3><h2><p><br></p></h2> ",
            "assembleText":"队列 队列(Queue)也是一种运算受限的线性表。它只允许在表的一端进行插入，而在另一端进行删除。允许删除的一端称为队头(front)，允许插入的一端称为队尾(rear)。先进先出。",
            "assembleScratchTime":"2019-03-18 09:41:26",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862676,
            "assembleContent":"<h3 id="队列"><ol><li>顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置</li></ol></h3><h2><p><br></p></h2> ",
            "assembleText":"顺序队列：顺序存储结构。当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头前一个位置，而尾指针始终指向队尾元素的实际位置",
            "assembleScratchTime":"2019-03-18 09:42:42",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862681,
            "assembleContent":"<h3 id="队列"><ol><li><p>循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”<br><br></p></li></ol></h3> ",
            "assembleText":"循环队列。在循环队列中进行出队、入队操作时，头尾指针仍要加1，朝前移动。只不过当头尾指针指向向量上界（MaxSize-1）时，其加1操作的结果是指向向量的下界0。除非向量空间真的被队列元素全部占用，否则不会上溢。因此，除一些简单的应用外，真正实用的顺序队列是循环队列。故队空和队满时头尾指针均相等。因此，我们无法通过front=rear来判断队列“空”还是“满”",
            "assembleScratchTime":"2019-03-18 09:46:38",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862692,
            "assembleContent":"<ol><li>链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。</li></ol> ",
            "assembleText":"链队列：链式存储结构。限制仅在表头删除和表尾插入的单链表。显然仅有单链表的头指针不便于在表尾做插入操作，为此再增加一个尾指针，指向链表的最后一个结点。",
            "assembleScratchTime":"2019-03-18 09:50:04",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862697,
            "assembleContent":"<p>串(String)是零个或多个字符组成的有限序列。长度为零的串称为<strong>空串</strong>(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为<strong>空白串</strong>(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串。  <br></p> ",
            "assembleText":"串(String)是零个或多个字符组成的有限序列。长度为零的串称为空串(Empty String)，它不包含任何字符。通常将仅由一个或多个空格组成的串称为空白串(Blank String) 注意：空串和空白串的不同，例如“ ”和“”分别表示长度为1的空白串和长度为0的空串。  ",
            "assembleScratchTime":"2019-03-18 09:50:46",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862708,
            "assembleContent":"<p>广义表<br>广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a1,a2,a3,…,an的有限序列，其中ai或者是原子项，或者是一个广义表。若广义表LS（n>=1)非空，则a1是LS的表头，其余元素组成的表(a2,…an)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。表尾是指除去表头后剩下的元素组成的表，表头可以为表或单元素值。所以表尾不可以是单个元素值。<br><br></p> ",
            "assembleText":"广义表 广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a1,a2,a3,…,an的有限序列，其中ai或者是原子项，或者是一个广义表。若广义表LS（n>=1)非空，则a1是LS的表头，其余元素组成的表(a2,…an)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。表尾是指除去表头后剩下的元素组成的表，表头可以为表或单元素值。所以表尾不可以是单个元素值。",
            "assembleScratchTime":"2019-03-18 09:52:17",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862724,
            "assembleContent":"<div><ol><li>数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的<strong>基本</strong>单位</li></ol></div><p><br></p> ",
            "assembleText":"数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的基本单位",
            "assembleScratchTime":"2019-03-18 09:54:46",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862740,
            "assembleContent":"<p>存储结构：<br>指数据的<a target="_blank" href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84">逻辑结构</a>在计算机存储空间的存放形式。  <br></p>   ",
            "assembleText":"存储结构： 指数据的逻辑结构在计算机存储空间的存放形式。  ",
            "assembleScratchTime":"2019-03-18 10:04:27",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_31196849/article/details/78529724",
            "type":"text"
        },
        {
            "assembleId":2862783,
            "assembleContent":"<p>链接存储：在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的)。它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有顺序存储结构所具有的弱点,但也同时失去了顺序表可随机存取的优点。  <br></p> ",
            "assembleText":"链接存储：在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的)。它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有顺序存储结构所具有的弱点,但也同时失去了顺序表可随机存取的优点。  ",
            "assembleScratchTime":"2019-03-18 10:41:33",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/wengchen123/article/details/78373000",
            "type":"text"
        },
        {
            "assembleId":2862794,
            "assembleContent":"<p>索引存储：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成。  <br></p> ",
            "assembleText":"索引存储：除建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引表由若干索引项组成。  ",
            "assembleScratchTime":"2019-03-18 10:42:46",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/wengchen123/article/details/78373000",
            "type":"text"
        },
        {
            "assembleId":2862801,
            "assembleContent":"<p>散列存储：散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。  <br></p>  ",
            "assembleText":"散列存储：散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。  ",
            "assembleScratchTime":"2019-03-18 10:44:00",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/wengchen123/article/details/78373000",
            "type":"text"
        },
        {
                "assembleId":2870177,
                "assembleContent":"<h2><p><span style="font-size: medium;"><b>块状链表</b>本身是一个链表，但是链表储存的并不是一般的数据，而是由这些数据组成的顺序表。每一个块状链表的节点，也就是顺序表，可以被叫做一个<b>块</b>。</span></p><p><span style="font-size: medium;">块状链表通过使用可变的顺序表的长度和特殊的插入、删除方式，可以在达到<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle O({\sqrt {n}})}"><semantics><annotation encoding="application/x-tex">{\displaystyle O({\sqrt {n}})}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5526ab1252c0f682bbe07c0ad67c0f29de5522b" aria-hidden="true" alt="O({\sqrt  n})">的复杂度。块状链表另一个特点是相对于普通链表来说节省内存，因为不用保存指向每一个数据节点的指针。</span></p></h2> ",
                "assembleText":"块状链表本身是一个链表，但是链表储存的并不是一般的数据，而是由这些数据组成的顺序表。每一个块状链表的节点，也就是顺序表，可以被叫做一个块。 块状链表通过使用可变的顺序表的长度和特殊的插入、删除方式，可以在达到 {\displaystyle O({\sqrt {n}})}的复杂度。块状链表另一个特点是相对于普通链表来说节省内存，因为不用保存指向每一个数据节点的指针。",
                "assembleScratchTime":"2019-04-05 13:00:56",
                "facetId":556198,
                "sourceId":1,
                "domainId":413,
                "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
                "type":"text"
        },
        {
            "assembleId":2870178,
            "assembleContent":"<h2><p><span style="font-size: medium;">根据情况，也可以自己设计链表的其它扩展。但是一般不会在边上附加数据，因为链表的点和边基本上是一一对应的（除了第一个或者最后一个节点，但是也不会产生特殊情况）。不过有一个特例是如果链表支持在链表的一段中把前和后指针反向，反向标记加在边上可能会更方便。</span></p><p><span style="font-size: medium;">对于非线性的链表，可以参见相关的其他数据结构，例如<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)" title="树 (数据结构)">树</a>、<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)" title="图 (数学)">图</a>。另外有一种基于多个线性链表的数据结构：<a href="https://zh.wikipedia.org/wiki/%E8%B7%B3%E8%A1%A8" title="跳表">跳表</a>，插入、删除和查找等基本操作的速度可以达到O(nlogn)，和<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E8%A1%A1%E6%A0%91" title="平衡树">平衡树</a>一样。</span></p></h2> ",
            "assembleText":"根据情况，也可以自己设计链表的其它扩展。但是一般不会在边上附加数据，因为链表的点和边基本上是一一对应的（除了第一个或者最后一个节点，但是也不会产生特殊情况）。不过有一个特例是如果链表支持在链表的一段中把前和后指针反向，反向标记加在边上可能会更方便。 对于非线性的链表，可以参见相关的其他数据结构，例如树、图。另外有一种基于多个线性链表的数据结构：跳表，插入、删除和查找等基本操作的速度可以达到O(nlogn)，和平衡树一样。",
            "assembleScratchTime":"2019-04-05 13:01:18",
            "facetId":556198,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870201,
            "assembleContent":"<h1><p><span style="font-size: medium;"> 静态链表<br></span></p><pre></pre><p><span style="font-size: medium;">静态链表是借助数组来描述线性表的链式存储结构，节点也有数据域和指针域，这里的指针是节点的相对地址（数组下标），也需要预先分配一块连续的内存空间。</span></p><pre></pre><p><span style="font-size: medium;">特点，插入删除和动态链表一样，以next==-1为结束标志。</span></p><pre></pre><p><span style="font-size: medium;"> </span></p></h1> ",
            "assembleText":" 静态链表 静态链表是借助数组来描述线性表的链式存储结构，节点也有数据域和指针域，这里的指针是节点的相对地址（数组下标），也需要预先分配一块连续的内存空间。 特点，插入删除和动态链表一样，以next==-1为结束标志。  ",
            "assembleScratchTime":"2019-04-05 13:08:04",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870203,
            "assembleContent":"<h1><p><span style="font-size: medium;">把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。</span></p><p><span style="font-size: medium;"><img src="https://images2018.cnblogs.com/blog/1206298/201803/1206298-20180326133522100-1928731505.png" alt=""></span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">    有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</span></p></h1> ",
            "assembleText":"把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。   　　有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。",
            "assembleScratchTime":"2019-04-05 13:09:11",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870236,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表头插法和尾插法</span></p><p><span style="font-size: medium;">两种</span></p></h1><h4>线性表的相邻元素之间存在着序偶关系。如用（a<sub>1</sub>，…，a<sub>i-1</sub>，a<sub>i</sub>，a<sub>i+1</sub>，…，a<sub>n</sub>）表示一个顺序表，则表中a<sub>i-1</sub>领先于a<sub>i</sub><sub>，</sub>a<sub>i</sub>领先于a<sub>i+1</sub>，称a<sub>i-1</sub>是a<sub>i</sub>的直接前驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。当i=1,2，…，n-1时，a<sub>i</sub>有且仅有一个直接后继，当i=2，3，…，n时，a<sub>i</sub>有且仅有一个直接前驱 。 </h4>  ",
            "assembleText":"单链表头插法和尾插法 两种 线性表的相邻元素之间存在着序偶关系。如用（a1，…，ai-1，ai，ai+1，…，an）表示一个顺序表，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1,2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱 。 ",
            "assembleScratchTime":"2019-04-05 13:19:26",
            "facetId":556198,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870240,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表头插法和尾插法</span></p><p><span style="font-size: medium;">两种<b style="color: inherit;">线性表</b><span style="color: inherit;">（英语：</span><span lang="en" style="color: inherit;">Linear List</span><span style="color: inherit;">）是由n（n≥0）个</span><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE" title="数据" style="background-color: rgb(255, 255, 255);">数据</a><span style="color: inherit;">元素（</span><a href="https://zh.wikipedia.org/w/index.php?title=%E7%BB%93%E7%82%B9&action=edit&redlink=1" title="结点（页面不存在）" style="background-color: rgb(255, 255, 255);">结点</a><span style="color: inherit;">）a[0]，a[1]，a[2]…，a[n-1]组成的</span><a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%89%E9%99%90%E5%BA%8F%E5%88%97&action=edit&redlink=1" title="有限序列（页面不存在）" style="background-color: rgb(255, 255, 255);">有限序列</a><span style="color: inherit;">。</span><br></span></p></h1><h2><p><span style="font-size: medium;">其中：</span></p><ul><li><span style="font-size: medium;">数据元素的个数n定义为表的长度 = "list".length() （"list".length() = 0（表里没有一个元素）时称为空表）</span></li><li><span style="font-size: medium;">将非空的线性表（n>=1）记作：（a[0]，a[1]，a[2]，…，a[n-1]）</span></li><li><span style="font-size: medium;">数据元素a[i]（0≤i≤n-1）只是个抽象符号，其具体含义在不同情况下可以不同</span></li></ul><p><span style="font-size: medium;">一个数据元素可以由若干个数据项组成。数据元素称为记录，含有大量记录的线性表又称为文件。这种结构具有下列特点：存在一个唯一的没有前驱的（头）数据元素；存在一个唯一的没有后继的（尾）数据元素；此外，每一个数据元素均有一个直接前驱和一个直接后继数据元素。 　　</span></p></h2>  ",
            "assembleText":"单链表头插法和尾插法 两种线性表（英语：Linear List）是由n（n≥0）个数据元素（结点）a[0]，a[1]，a[2]…，a[n-1]组成的有限序列。 其中： 数据元素的个数n定义为表的长度 = "list".length() （"list".length() = 0（表里没有一个元素）时称为空表） 将非空的线性表（n>=1）记作：（a[0]，a[1]，a[2]，…，a[n-1]） 数据元素a[i]（0≤i≤n-1）只是个抽象符号，其具体含义在不同情况下可以不同 一个数据元素可以由若干个数据项组成。数据元素称为记录，含有大量记录的线性表又称为文件。这种结构具有下列特点：存在一个唯一的没有前驱的（头）数据元素；存在一个唯一的没有后继的（尾）数据元素；此外，每一个数据元素均有一个直接前驱和一个直接后继数据元素。 　　",
            "assembleScratchTime":"2019-04-05 13:22:05",
            "facetId":556198,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870242,
            "assembleContent":"<h1><p>线性表是逻辑结构，顺序表和链表是存储结构。</p></h1><h1><p><br></p></h1>  ",
            "assembleText":"线性表是逻辑结构，顺序表和链表是存储结构。",
            "assembleScratchTime":"2019-04-05 13:22:29",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870243,
            "assembleContent":"<h1><p><span style="font-size: medium;">线性表（List）：由零个或多个数据元素组成的有限序列。</span></p><p><span style="font-size: medium;">注意：</span></p><p><span style="font-size: medium;">1.线性表是一个序列。</span></p><p><span style="font-size: medium;">2.0个元素构成的线性表是空表。</span></p><p><span style="font-size: medium;">3.线性表中的第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继。</span></p><p><span style="font-size: medium;">4.线性表是有长度的，其长度就是元素个数，且线性表的元素个数是有限的，也就是说，线性表的长度是有限的。</span></p></h1>  ",
            "assembleText":"线性表（List）：由零个或多个数据元素组成的有限序列。 注意： 1.线性表是一个序列。 2.0个元素构成的线性表是空表。 3.线性表中的第一个元素无前驱，最后一个元素无后继，其他元素有且只有一个前驱和后继。 4.线性表是有长度的，其长度就是元素个数，且线性表的元素个数是有限的，也就是说，线性表的长度是有限的。",
            "assembleScratchTime":"2019-04-05 13:22:54",
            "facetId":556198,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wsnb/p/5191518.html",
            "type":"text"
        },
        {
            "assembleId":2870434,
            "assembleContent":"<h2 id="题目描述"><img src="http://yotta.xjtushilei.com:8090/863580567/553941250.png" style="max-width:100%;"><br></h2> ",
            "assembleText":"",
            "assembleScratchTime":"2019-04-05 14:17:12",
            "facetId":556198,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/mingmingmomo/p/9288877.html",
            "type":"text"
        },
        {
            "assembleId":2870441,
            "assembleContent":"<h2><span id="History" style="font-size: medium;">History</span></h2><h2><p><span style="font-size: medium;">Linked lists were developed in 1955–1956 by <a href="https://en.wikipedia.org/wiki/Allen_Newell" title="Allen Newell">Allen Newell</a>, <a href="https://en.wikipedia.org/wiki/Cliff_Shaw" title="Cliff Shaw">Cliff Shaw</a> and <a href="https://en.wikipedia.org/wiki/Herbert_A._Simon" title="Herbert A. Simon">Herbert A. Simon</a> at <a href="https://en.wikipedia.org/wiki/RAND_Corporation" title="RAND Corporation">RAND Corporation</a> as the primary <a href="https://en.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> for their <a href="https://en.wikipedia.org/wiki/Information_Processing_Language" title="Information Processing Language">Information Processing Language</a>. IPL was used by the authors to develop several early <a href="https://en.wikipedia.org/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a> programs, including the Logic Theory Machine, the <a href="https://en.wikipedia.org/wiki/General_Problem_Solver" title="General Problem Solver">General Problem Solver</a>, and a computer chess program. Reports on their work appeared in IRE Transactions on Information Theory in 1956, and several conference proceedings from 1957 to 1959, including Proceedings of the Western Joint Computer Conference in 1957 and 1958, and Information Processing (Proceedings of the first <a href="https://en.wikipedia.org/wiki/UNESCO" title="UNESCO">UNESCO</a> International Conference on Information Processing) in 1959. The now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in "Programming the Logic Theory Machine" by Newell and Shaw in Proc. WJCC, February 1957. Newell and Simon were recognized with the ACM <a href="https://en.wikipedia.org/wiki/Turing_Award" title="Turing Award">Turing Award</a> in 1975 for having "made basic contributions to artificial intelligence, the psychology of human cognition, and list processing". The problem of <a href="https://en.wikipedia.org/wiki/Machine_translation" title="Machine translation">machine translation</a> for <a href="https://en.wikipedia.org/wiki/Natural_language" title="Natural language">natural language</a> processing led <a href="https://en.wikipedia.org/wiki/Victor_Yngve" title="Victor Yngve">Victor Yngve</a> at <a href="https://en.wikipedia.org/wiki/Massachusetts_Institute_of_Technology" title="Massachusetts Institute of Technology">Massachusetts Institute of Technology</a> (MIT) to use linked lists as data structures in his COMIT programming language for computer research in the field of <a href="https://en.wikipedia.org/wiki/Linguistics" title="Linguistics">linguistics</a>. A report on this language entitled "A programming language for mechanical translation" appeared in Mechanical Translation in 1958.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (January 2019)">citation needed</span></a></i>]</sup></span></p><p><span style="font-size: medium;"><a href="https://en.wikipedia.org/wiki/LISP" title="LISP">LISP</a>, standing for list processor, was created by <a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a> in 1958 while he was at MIT and in 1960 he published its design in a paper in the <a href="https://en.wikipedia.org/wiki/Communications_of_the_ACM" title="Communications of the ACM">Communications of the ACM</a>, entitled "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I". One of LISP's major data structures is the linked list.</span></p><p><span style="font-size: medium;">By the early 1960s, the utility of both linked lists and languages which use these structures as their primary data representation was well established. Bert Green of the <a href="https://en.wikipedia.org/wiki/MIT_Lincoln_Laboratory" title="MIT Lincoln Laboratory">MIT Lincoln Laboratory</a> published a review article entitled "Computer languages for symbol manipulation" in IRE Transactions on Human Factors in Electronics in March 1961 which summarized the advantages of the linked list approach. A later review article, "A Comparison of list-processing computer languages" by Bobrow and Raphael, appeared in Communications of the ACM in April 1964.</span></p><p><span style="font-size: medium;">Several operating systems developed by <a href="https://en.wikipedia.org/wiki/Technical_Systems_Consultants" title="Technical Systems Consultants">Technical Systems Consultants</a> (originally of West Lafayette Indiana, and later of Chapel Hill, North Carolina) used singly linked lists as file structures. A directory entry pointed to the first sector of a file, and succeeding portions of the file were located by traversing pointers. Systems using this technique included Flex (for the <a href="https://en.wikipedia.org/wiki/Motorola_6800" title="Motorola 6800">Motorola 6800</a> CPU), mini-Flex (same CPU), and Flex9 (for the Motorola 6809 CPU). A variant developed by TSC for and marketed by Smoke Signal Broadcasting in California, used doubly linked lists in the same manner.</span></p><p><span style="font-size: medium;">The TSS/360 operating system, developed by IBM for the System 360/370 machines, used a double linked list for their file system catalog. The directory structure was similar to Unix, where a directory could contain files and other directories and extend to any depth.</span></p></h2> ",
            "assembleText":"History Linked lists were developed in 1955–1956 by Allen Newell, Cliff Shaw and Herbert A. Simon at RAND Corporation as the primary data structure for their Information Processing Language. IPL was used by the authors to develop several early artificial intelligence programs, including the Logic Theory Machine, the General Problem Solver, and a computer chess program. Reports on their work appeared in IRE Transactions on Information Theory in 1956, and several conference proceedings from 1957 to 1959, including Proceedings of the Western Joint Computer Conference in 1957 and 1958, and Information Processing (Proceedings of the first UNESCO International Conference on Information Processing) in 1959. The now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in "Programming the Logic Theory Machine" by Newell and Shaw in Proc. WJCC, February 1957. Newell and Simon were recognized with the ACM Turing Award in 1975 for having "made basic contributions to artificial intelligence, the psychology of human cognition, and list processing". The problem of machine translation for natural language processing led Victor Yngve at Massachusetts Institute of Technology (MIT) to use linked lists as data structures in his COMIT programming language for computer research in the field of linguistics. A report on this language entitled "A programming language for mechanical translation" appeared in Mechanical Translation in 1958.[citation needed] LISP, standing for list processor, was created by John McCarthy in 1958 while he was at MIT and in 1960 he published its design in a paper in the Communications of the ACM, entitled "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I". One of LISP's major data structures is the linked list. By the early 1960s, the utility of both linked lists and languages which use these structures as their primary data representation was well established. Bert Green of the MIT Lincoln Laboratory published a review article entitled "Computer languages for symbol manipulation" in IRE Transactions on Human Factors in Electronics in March 1961 which summarized the advantages of the linked list approach. A later review article, "A Comparison of list-processing computer languages" by Bobrow and Raphael, appeared in Communications of the ACM in April 1964. Several operating systems developed by Technical Systems Consultants (originally of West Lafayette Indiana, and later of Chapel Hill, North Carolina) used singly linked lists as file structures. A directory entry pointed to the first sector of a file, and succeeding portions of the file were located by traversing pointers. Systems using this technique included Flex (for the Motorola 6800 CPU), mini-Flex (same CPU), and Flex9 (for the Motorola 6809 CPU). A variant developed by TSC for and marketed by Smoke Signal Broadcasting in California, used doubly linked lists in the same manner. The TSS/360 operating system, developed by IBM for the System 360/370 machines, used a double linked list for their file system catalog. The directory structure was similar to Unix, where a directory could contain files and other directories and extend to any depth.",
            "assembleScratchTime":"2019-04-05 14:20:47",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870442,
            "assembleContent":"<h2><span id="Basic_concepts_and_nomenclature">Basic concepts and nomenclature</span></h2><div><p>Each record of a linked list is often called an 'element' or '<a href="https://en.wikipedia.org/wiki/Node_(computer_science)" title="Node (computer science)">node</a>'.</p><p>The field of each node that contains the address of the next node is usually called the 'next link' or 'next pointer'. The remaining fields are known as the 'data', 'information', 'value', 'cargo', or 'payload' fields.</p><p>The 'head' of a list is its first node. The 'tail' of a list may refer either to the rest of the list after the head, or to the last node in the list. In <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a> and some derived languages, the next node may be called the '<a href="https://en.wikipedia.org/wiki/CAR_and_CDR" title="CAR and CDR">cdr</a>' (pronounced <i>could-er</i>) of the list, while the payload of the head node may be called the 'car'.</p></div> ",
            "assembleText":"Basic concepts and nomenclature Each record of a linked list is often called an 'element' or 'node'. The field of each node that contains the address of the next node is usually called the 'next link' or 'next pointer'. The remaining fields are known as the 'data', 'information', 'value', 'cargo', or 'payload' fields. The 'head' of a list is its first node. The 'tail' of a list may refer either to the rest of the list after the head, or to the last node in the list. In Lisp and some derived languages, the next node may be called the 'cdr' (pronounced could-er) of the list, while the payload of the head node may be called the 'car'.",
            "assembleScratchTime":"2019-04-05 14:21:11",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870447,
            "assembleContent":"<h3><span id="Multiply_linked_list">Multiply linked list</span></h3><div><p>In a 'multiply linked list', each node contains two or more link fields, each field being used to connect the same set of data records in a different order of same set(e.g., by name, by department, by date of birth, etc.). While doubly linked lists can be seen as special cases of multiply linked list, the fact that the two and more orders are opposite to each other leads to simpler and more efficient algorithms, so they are usually treated as a separate case.  <br></p></div> ",
            "assembleText":"Multiply linked list In a 'multiply linked list', each node contains two or more link fields, each field being used to connect the same set of data records in a different order of same set(e.g., by name, by department, by date of birth, etc.). While doubly linked lists can be seen as special cases of multiply linked list, the fact that the two and more orders are opposite to each other leads to simpler and more efficient algorithms, so they are usually treated as a separate case.  ",
            "assembleScratchTime":"2019-04-05 14:22:35",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870450,
            "assembleContent":"<h3><span id="Sentinel_nodes">Sentinel nodes</span></h3><div>In some implementations an extra 'sentinel' or 'dummy' node may be added before the first data record or after the last one. This convention simplifies and accelerates some list-handling algorithms, by ensuring that all links can be safely dereferenced and that every list (even one that contains no data elements) always has a "first" and "last" node.  <span><br></span></div> ",
            "assembleText":"Sentinel nodes In some implementations an extra 'sentinel' or 'dummy' node may be added before the first data record or after the last one. This convention simplifies and accelerates some list-handling algorithms, by ensuring that all links can be safely dereferenced and that every list (even one that contains no data elements) always has a "first" and "last" node.  ",
            "assembleScratchTime":"2019-04-05 14:23:18",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870452,
            "assembleContent":"<h3><span id="Empty_lists">Empty lists</span></h3><div><p>An empty list is a list that contains no data records. This is usually the same as saying that it has zero nodes. If sentinel nodes are being used, the list is usually said to be empty when it has only sentinel nodes.</p><h3><br></h3></div> ",
            "assembleText":"Empty lists An empty list is a list that contains no data records. This is usually the same as saying that it has zero nodes. If sentinel nodes are being used, the list is usually said to be empty when it has only sentinel nodes.",
            "assembleScratchTime":"2019-04-05 14:23:39",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870454,
            "assembleContent":"<h3><span id="Hash_linking">Hash linking</span></h3><h3><p><span style="font-size: medium;">The link fields need not be physically part of the nodes. If the data records are stored in an array and referenced by their indices, the link field may be stored in a separate array with the same indices as the data records.</span></p></h3> ",
            "assembleText":"Hash linking The link fields need not be physically part of the nodes. If the data records are stored in an array and referenced by their indices, the link field may be stored in a separate array with the same indices as the data records.",
            "assembleScratchTime":"2019-04-05 14:23:56",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870456,
            "assembleContent":"<h3><span id="List_handles" style="font-size: medium;">List handles</span></h3><h3><p><span style="font-size: medium;">Since a reference to the first node gives access to the whole list, that reference is often called the 'address', 'pointer', or 'handle' of the list. Algorithms that manipulate linked lists usually get such handles to the input lists and return the handles to the resulting lists. In fact, in the context of such algorithms, the word "list" often means "list handle". In some situations, however, it may be convenient to refer to a list by a handle that consists of two links, pointing to its first and last nodes.  </span><br></p></h3> ",
            "assembleText":"List handles Since a reference to the first node gives access to the whole list, that reference is often called the 'address', 'pointer', or 'handle' of the list. Algorithms that manipulate linked lists usually get such handles to the input lists and return the handles to the resulting lists. In fact, in the context of such algorithms, the word "list" often means "list handle". In some situations, however, it may be convenient to refer to a list by a handle that consists of two links, pointing to its first and last nodes.  ",
            "assembleScratchTime":"2019-04-05 14:24:17",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870458,
            "assembleContent":"<h3><span id="Combining_alternatives">Combining alternatives</span></h3><h3><p><span style="font-size: medium;">The alternatives listed above may be arbitrarily combined in almost every way, so one may have circular doubly linked lists without sentinels, circular singly linked lists with sentinels, etc.</span></p></h3><h2><br></h2> ",
            "assembleText":"Combining alternatives The alternatives listed above may be arbitrarily combined in almost every way, so one may have circular doubly linked lists without sentinels, circular singly linked lists with sentinels, etc.",
            "assembleScratchTime":"2019-04-05 14:24:33",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870460,
            "assembleContent":"<h2><span id="Tradeoffs">Tradeoffs</span></h2><h3><p><span style="font-size: medium;">As with most choices in computer programming and design, no method is well suited to all circumstances. A linked list data structure might work well in one case, but cause problems in another. This is a list of some of the common tradeoffs involving linked list structures</span></p></h3><h2><br></h2> ",
            "assembleText":"Tradeoffs As with most choices in computer programming and design, no method is well suited to all circumstances. A linked list data structure might work well in one case, but cause problems in another. This is a list of some of the common tradeoffs involving linked list structures",
            "assembleScratchTime":"2019-04-05 14:24:51",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870462,
            "assembleContent":"<h3><span id="Linked_lists_vs._dynamic_arrays">Linked lists vs. dynamic arrays</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><img src="http://yotta.xjtushilei.com:8090/863580860/1230056814.PNG" style="max-width:100%;"><br></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Linked lists vs. dynamic arrays",
            "assembleScratchTime":"2019-04-05 14:25:50",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870465,
            "assembleContent":"<h3><span id="Linked_lists_vs._dynamic_arrays">Linked lists vs. dynamic arrays</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><p>A <i><a href="https://en.wikipedia.org/wiki/Dynamic_array" title="Dynamic array">dynamic array</a></i> is a data structure that allocates all elements contiguously in memory, and keeps a count of the current number of elements. If the space reserved for the dynamic array is exceeded, it is reallocated and (possibly) copied, which is an expensive operation.</p><p>Linked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a specific point of a list, assuming that we have indexed a pointer to the node (before the one to be removed, or before the insertion point) already, is a constant-time operation (otherwise without this reference it is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the elements on average, and all the elements in the worst case. While one can "delete" an element from an array in constant time by somehow marking its slot as "vacant", this causes <a href="https://en.wikipedia.org/wiki/Fragmentation_(computer)" title="Fragmentation (computer)">fragmentation</a> that impedes the performance of iteration.</p><p>Moreover, arbitrarily many elements may be inserted into a linked list, limited only by the total memory available; while a dynamic array will eventually fill up its underlying array data structure and will have to reallocate—an expensive operation, one that may not even be possible if memory is fragmented, although the cost of reallocation can be averaged over insertions, and the cost of an insertion due to reallocation would still be <a href="https://en.wikipedia.org/wiki/Amortized_analysis" title="Amortized analysis">amortized</a> O(1). This helps with appending elements at the array's end, but inserting into (or removing from) middle positions still carries prohibitive costs due to data moving to maintain contiguity. An array from which many elements are removed may also have to be resized in order to avoid wasting too much space.</p><p>On the other hand, dynamic arrays (as well as fixed-size <a href="https://en.wikipedia.org/wiki/Array_data_structure" title="Array data structure">array data structures</a>) allow constant-time <a href="https://en.wikipedia.org/wiki/Random_access" title="Random access">random access</a>, while linked lists allow only <a href="https://en.wikipedia.org/wiki/Sequential_access" title="Sequential access">sequential access</a> to elements. Singly linked lists, in fact, can be easily traversed in only one direction. This makes linked lists unsuitable for applications where it's useful to look up an element by its index quickly, such as <a href="https://en.wikipedia.org/wiki/Heapsort" title="Heapsort">heapsort</a>. Sequential access on arrays and dynamic arrays is also faster than on linked lists on many machines, because they have optimal <a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Locality of reference">locality of reference</a> and thus make good use of data caching.</p><p>Another disadvantage of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data items such as <a href="https://en.wikipedia.org/wiki/Character_(computing)" title="Character (computing)">characters</a> or <a href="https://en.wikipedia.org/wiki/Boolean_value" title="Boolean value">boolean values</a>, because the storage overhead for the links may exceed by a factor of two or more the size of the data. In contrast, a dynamic array requires only the space for the data itself (and a very small amount of control data).<sup id="cite_ref-8"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-8">[note 1]</a></sup> It can also be slow, and with a naïve allocator, wasteful, to allocate memory separately for each new element, a problem generally solved using <a href="https://en.wikipedia.org/wiki/Memory_pool" title="Memory pool">memory pools</a>.</p><p>Some hybrid solutions try to combine the advantages of the two representations. <a href="https://en.wikipedia.org/wiki/Unrolled_linked_list" title="Unrolled linked list">Unrolled linked lists</a> store several elements in each list node, increasing cache performance while decreasing memory overhead for references. <a href="https://en.wikipedia.org/wiki/CDR_coding" title="CDR coding">CDR coding</a> does both these as well, by replacing references with the actual data referenced, which extends off the end of the referencing record.</p><p>A good example that highlights the pros and cons of using dynamic arrays vs. linked lists is by implementing a program that resolves the <a href="https://en.wikipedia.org/wiki/Josephus_problem" title="Josephus problem">Josephus problem</a>. The Josephus problem is an election method that works by having a group of people stand in a circle. Starting at a predetermined person, you count around the circle <i>n</i> times. Once you reach the <i>n</i>th person, take them out of the circle and have the members close the circle. Then count around the circle the same <i>n</i> times and repeat the process, until only one person is left. That person wins the election. This shows the strengths and weaknesses of a linked list vs. a dynamic array, because if you view the people as connected nodes in a circular linked list then it shows how easily the linked list is able to delete nodes (as it only has to rearrange the links to the different nodes). However, the linked list will be poor at finding the next person to remove and will need to search through the list until it finds that person. A dynamic array, on the other hand, will be poor at deleting nodes (or elements) as it cannot remove one node without individually shifting all the elements up the list by one. However, it is exceptionally easy to find the <i>n</i>th person in the circle by directly referencing them by their position in the array.</p><p>The <a href="https://en.wikipedia.org/wiki/List_ranking" title="List ranking">list ranking</a> problem concerns the efficient conversion of a linked list representation into an array. Although trivial for a conventional computer, solving this problem by a <a href="https://en.wikipedia.org/wiki/Parallel_algorithm" title="Parallel algorithm">parallel algorithm</a> is complicated and has been the subject of much research.</p><p>A <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">balanced tree</a> has similar memory access patterns and space overhead to a linked list while permitting much more efficient indexing, taking O(log n) time instead of O(n) for a random access. However, insertion and deletion operations are more expensive due to the overhead of tree manipulations to maintain balance. Schemes exist for trees to automatically maintain themselves in a balanced state: <a href="https://en.wikipedia.org/wiki/AVL_tree" title="AVL tree">AVL trees</a> or <a href="https://en.wikipedia.org/wiki/Red-black_tree" title="Red-black tree">red-black trees</a>.</p></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Linked lists vs. dynamic arrays A dynamic array is a data structure that allocates all elements contiguously in memory, and keeps a count of the current number of elements. If the space reserved for the dynamic array is exceeded, it is reallocated and (possibly) copied, which is an expensive operation. Linked lists have several advantages over dynamic arrays. Insertion or deletion of an element at a specific point of a list, assuming that we have indexed a pointer to the node (before the one to be removed, or before the insertion point) already, is a constant-time operation (otherwise without this reference it is O(n)), whereas insertion in a dynamic array at random locations will require moving half of the elements on average, and all the elements in the worst case. While one can "delete" an element from an array in constant time by somehow marking its slot as "vacant", this causes fragmentation that impedes the performance of iteration. Moreover, arbitrarily many elements may be inserted into a linked list, limited only by the total memory available; while a dynamic array will eventually fill up its underlying array data structure and will have to reallocate—an expensive operation, one that may not even be possible if memory is fragmented, although the cost of reallocation can be averaged over insertions, and the cost of an insertion due to reallocation would still be amortized O(1). This helps with appending elements at the array's end, but inserting into (or removing from) middle positions still carries prohibitive costs due to data moving to maintain contiguity. An array from which many elements are removed may also have to be resized in order to avoid wasting too much space. On the other hand, dynamic arrays (as well as fixed-size array data structures) allow constant-time random access, while linked lists allow only sequential access to elements. Singly linked lists, in fact, can be easily traversed in only one direction. This makes linked lists unsuitable for applications where it's useful to look up an element by its index quickly, such as heapsort. Sequential access on arrays and dynamic arrays is also faster than on linked lists on many machines, because they have optimal locality of reference and thus make good use of data caching. Another disadvantage of linked lists is the extra storage needed for references, which often makes them impractical for lists of small data items such as characters or boolean values, because the storage overhead for the links may exceed by a factor of two or more the size of the data. In contrast, a dynamic array requires only the space for the data itself (and a very small amount of control data).[note 1] It can also be slow, and with a naïve allocator, wasteful, to allocate memory separately for each new element, a problem generally solved using memory pools. Some hybrid solutions try to combine the advantages of the two representations. Unrolled linked lists store several elements in each list node, increasing cache performance while decreasing memory overhead for references. CDR coding does both these as well, by replacing references with the actual data referenced, which extends off the end of the referencing record. A good example that highlights the pros and cons of using dynamic arrays vs. linked lists is by implementing a program that resolves the Josephus problem. The Josephus problem is an election method that works by having a group of people stand in a circle. Starting at a predetermined person, you count around the circle n times. Once you reach the nth person, take them out of the circle and have the members close the circle. Then count around the circle the same n times and repeat the process, until only one person is left. That person wins the election. This shows the strengths and weaknesses of a linked list vs. a dynamic array, because if you view the people as connected nodes in a circular linked list then it shows how easily the linked list is able to delete nodes (as it only has to rearrange the links to the different nodes). However, the linked list will be poor at finding the next person to remove and will need to search through the list until it finds that person. A dynamic array, on the other hand, will be poor at deleting nodes (or elements) as it cannot remove one node without individually shifting all the elements up the list by one. However, it is exceptionally easy to find the nth person in the circle by directly referencing them by their position in the array. The list ranking problem concerns the efficient conversion of a linked list representation into an array. Although trivial for a conventional computer, solving this problem by a parallel algorithm is complicated and has been the subject of much research. A balanced tree has similar memory access patterns and space overhead to a linked list while permitting much more efficient indexing, taking O(log n) time instead of O(n) for a random access. However, insertion and deletion operations are more expensive due to the overhead of tree manipulations to maintain balance. Schemes exist for trees to automatically maintain themselves in a balanced state: AVL trees or red-black trees.",
            "assembleScratchTime":"2019-04-05 14:26:10",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870467,
            "assembleContent":"<h3><span id="Singly_linked_linear_lists_vs._other_lists">Singly linked linear lists vs. other lists</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><p>While doubly linked and circular lists have advantages over singly linked linear lists, linear lists offer some advantages that make them preferable in some situations.</p><p>A singly linked linear list is a <a href="https://en.wikipedia.org/wiki/Recursion" title="Recursion">recursive</a> data structure, because it contains a pointer to a <i>smaller</i> object of the same type. For that reason, many operations on singly linked linear lists (such as <a href="https://en.wikipedia.org/wiki/Merge_algorithm" title="Merge algorithm">merging</a> two lists, or enumerating the elements in reverse order) often have very simple recursive algorithms, much simpler than any solution using <a href="https://en.wikipedia.org/wiki/Iteration" title="Iteration">iterative commands</a>. While those recursive solutions can be adapted for doubly linked and circularly linked lists, the procedures generally need extra arguments and more complicated base cases.</p><p>Linear singly linked lists also allow <a href="https://en.wikipedia.org/wiki/Tail-sharing" title="Tail-sharing">tail-sharing</a>, the use of a common final portion of sub-list as the terminal portion of two different lists. In particular, if a new node is added at the beginning of a list, the former list remains available as the tail of the new one—a simple example of a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structure</a>. Again, this is not true with the other variants: a node may never belong to two different circular or doubly linked lists.</p><p>In particular, end-sentinel nodes can be shared among singly linked non-circular lists. The same end-sentinel node may be used for <i>every</i> such list. In <a href="https://en.wikipedia.org/wiki/Lisp_programming_language" title="Lisp programming language">Lisp</a>, for example, every proper list ends with a link to a special node, denoted by <code>nil</code> or <code>()</code>, whose <code><a href="https://en.wikipedia.org/wiki/CAR_and_CDR" title="CAR and CDR">CAR</a></code> and <code>CDR</code> links point to itself. Thus a Lisp procedure can safely take the <code>CAR</code> or <code>CDR</code> of <i>any</i> list.</p><p>The advantages of the fancy variants are often limited to the complexity of the algorithms, not in their efficiency. A circular list, in particular, can usually be emulated by a linear list together with two variables that point to the first and last nodes, at no extra cost.</p></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Singly linked linear lists vs. other lists While doubly linked and circular lists have advantages over singly linked linear lists, linear lists offer some advantages that make them preferable in some situations. A singly linked linear list is a recursive data structure, because it contains a pointer to a smaller object of the same type. For that reason, many operations on singly linked linear lists (such as merging two lists, or enumerating the elements in reverse order) often have very simple recursive algorithms, much simpler than any solution using iterative commands. While those recursive solutions can be adapted for doubly linked and circularly linked lists, the procedures generally need extra arguments and more complicated base cases. Linear singly linked lists also allow tail-sharing, the use of a common final portion of sub-list as the terminal portion of two different lists. In particular, if a new node is added at the beginning of a list, the former list remains available as the tail of the new one—a simple example of a persistent data structure. Again, this is not true with the other variants: a node may never belong to two different circular or doubly linked lists. In particular, end-sentinel nodes can be shared among singly linked non-circular lists. The same end-sentinel node may be used for every such list. In Lisp, for example, every proper list ends with a link to a special node, denoted by nil or (), whose CAR and CDR links point to itself. Thus a Lisp procedure can safely take the CAR or CDR of any list. The advantages of the fancy variants are often limited to the complexity of the algorithms, not in their efficiency. A circular list, in particular, can usually be emulated by a linear list together with two variables that point to the first and last nodes, at no extra cost.",
            "assembleScratchTime":"2019-04-05 14:26:29",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870469,
            "assembleContent":"<h3><span id="Doubly_linked_vs._singly_linked">Doubly linked vs. singly linked</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><p>Double-linked lists require more space per node (unless one uses <a href="https://en.wikipedia.org/wiki/XOR_linked_list" title="XOR linked list">XOR-linking</a>), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the <i>address of the pointer</i> to that node, which is either the handle for the whole list (in case of the first node) or the link field in the <i>previous</i> node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structures</a>  <br></p></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Doubly linked vs. singly linked Double-linked lists require more space per node (unless one uses XOR-linking), and their elementary operations are more expensive; but they are often easier to manipulate because they allow fast and easy sequential access to the list in both directions. In a doubly linked list, one can insert or delete a node in a constant number of operations given only that node's address. To do the same in a singly linked list, one must have the address of the pointer to that node, which is either the handle for the whole list (in case of the first node) or the link field in the previous node. Some algorithms require access in both directions. On the other hand, doubly linked lists do not allow tail-sharing and cannot be used as persistent data structures  ",
            "assembleScratchTime":"2019-04-05 14:26:45",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870470,
            "assembleContent":"<h3><span id="Circularly_linked_vs._linearly_linked">Circularly linked vs. linearly linked</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><p>A circularly linked list may be a natural option to represent arrays that are naturally circular, e.g. the corners of a <a href="https://en.wikipedia.org/wiki/Polygon" title="Polygon">polygon</a>, a pool of <a href="https://en.wikipedia.org/wiki/Data_buffer" title="Data buffer">buffers</a> that are used and released in <a href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" title="FIFO (computing and electronics)">FIFO</a> ("first in, first out") order, or a set of processes that should be <a href="https://en.wikipedia.org/wiki/Time_sharing" title="Time sharing">time-shared</a> in <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" title="Round-robin scheduling">round-robin order</a>. In these applications, a pointer to any node serves as a handle to the whole list.</p><p>With a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two.</p><p>A circular list can be split into two circular lists, in constant time, by giving the addresses of the last node of each piece. The operation consists in swapping the contents of the link fields of those two nodes. Applying the same operation to any two nodes in two distinct lists joins the two list into one. This property greatly simplifies some algorithms and data structures, such as the <a href="https://en.wikipedia.org/wiki/Quad-edge_data_structure" title="Quad-edge data structure">quad-edge</a> and <a href="https://en.wikipedia.org/w/index.php?title=Face-edge_data_structure&action=edit&redlink=1" title="Face-edge data structure (page does not exist)">face-edge</a>.</p><p>The simplest representation for an empty <i>circular</i> list (when such a thing makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty <i>linear</i> list is more natural and often creates fewer special cases.</p></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked vs. linearly linked A circularly linked list may be a natural option to represent arrays that are naturally circular, e.g. the corners of a polygon, a pool of buffers that are used and released in FIFO ("first in, first out") order, or a set of processes that should be time-shared in round-robin order. In these applications, a pointer to any node serves as a handle to the whole list. With a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two. A circular list can be split into two circular lists, in constant time, by giving the addresses of the last node of each piece. The operation consists in swapping the contents of the link fields of those two nodes. Applying the same operation to any two nodes in two distinct lists joins the two list into one. This property greatly simplifies some algorithms and data structures, such as the quad-edge and face-edge. The simplest representation for an empty circular list (when such a thing makes sense) is a null pointer, indicating that the list has no nodes. Without this choice, many algorithms have to test for this special case, and handle it separately. By contrast, the use of null to denote an empty linear list is more natural and often creates fewer special cases.",
            "assembleScratchTime":"2019-04-05 14:27:05",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870471,
            "assembleContent":"<h3><span id="Using_sentinel_nodes">Using sentinel nodes</span></h3><div><tdtable-na"><tdtable-na"><tdtable-na"><p><a href="https://en.wikipedia.org/wiki/Sentinel_node" title="Sentinel node">Sentinel node</a> may simplify certain list operations, by ensuring that the next or previous nodes exist for every element, and that even empty lists have at least one node. One may also use a sentinel node at the end of the list, with an appropriate data field, to eliminate some end-of-list tests. For example, when scanning the list looking for a node with a given value <i>x</i>, setting the sentinel's data field to <i>x</i> makes it unnecessary to test for end-of-list inside the loop. Another example is the merging two sorted lists: if their sentinels have data fields set to +∞, the choice of the next output node does not need special handling for empty lists.</p><p>However, sentinel nodes use up extra space (especially in applications that use many short lists), and they may complicate other operations (such as the creation of a new empty list).</p><p>However, if the circular list is used merely to simulate a linear list, one may avoid some of this complexity by adding a single sentinel node to every list, between the last and the first data nodes. With this convention, an empty list consists of the sentinel node alone, pointing to itself via the next-node link. The list handle should then be a pointer to the last data node, before the sentinel, if the list is not empty; or to the sentinel itself, if the list is empty.</p><p>The same trick can be used to simplify the handling of a doubly linked linear list, by turning it into a circular doubly linked list with a single sentinel node. However, in this case, the handle should be a single pointer to the dummy node itself.<sup id="cite_ref-9"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-9">[8]</a></sup></p></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Using sentinel nodes Sentinel node may simplify certain list operations, by ensuring that the next or previous nodes exist for every element, and that even empty lists have at least one node. One may also use a sentinel node at the end of the list, with an appropriate data field, to eliminate some end-of-list tests. For example, when scanning the list looking for a node with a given value x, setting the sentinel's data field to x makes it unnecessary to test for end-of-list inside the loop. Another example is the merging two sorted lists: if their sentinels have data fields set to +∞, the choice of the next output node does not need special handling for empty lists. However, sentinel nodes use up extra space (especially in applications that use many short lists), and they may complicate other operations (such as the creation of a new empty list). However, if the circular list is used merely to simulate a linear list, one may avoid some of this complexity by adding a single sentinel node to every list, between the last and the first data nodes. With this convention, an empty list consists of the sentinel node alone, pointing to itself via the next-node link. The list handle should then be a pointer to the last data node, before the sentinel, if the list is not empty; or to the sentinel itself, if the list is empty. The same trick can be used to simplify the handling of a doubly linked linear list, by turning it into a circular doubly linked list with a single sentinel node. However, in this case, the handle should be a single pointer to the dummy node itself.[8]",
            "assembleScratchTime":"2019-04-05 14:27:25",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870487,
            "assembleContent":"<h2><span id="Linked_lists_using_arrays_of_nodes">Linked lists using arrays of nodes</span></h2><div><h4><p>Languages that do not support any type of <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" title="Reference (computer science)">reference</a> can still create links by replacing pointers with array indices. The approach is to keep an <a href="https://en.wikipedia.org/wiki/Array_data_type" title="Array data type">array</a> of <a href="https://en.wikipedia.org/wiki/Record_(computer_science)" title="Record (computer science)">records</a>, where each record has integer fields indicating the index of the next (and possibly previous) node in the array. Not all nodes in the array need be used. If records are also not supported, <a href="https://en.wikipedia.org/wiki/Parallel_array" title="Parallel array">parallel arrays</a> can often be used instead.</p><p>As an example, consider the following linked list record that uses arrays instead of pointers:</p><pre> <b>record</b> <i>Entry</i> {
    <i>integer</i> next; <i>// index of next entry in array</i>
    <i>integer</i> prev; <i>// previous entry (if double-linked)</i>
    <i>string</i> name;
    <i>real</i> balance;
 }
</pre><p>A linked list can be built by creating an array of these structures, and an integer variable to store the index of the first element.</p><pre><i>integer</i> listHead
<i>Entry</i> Records[1000]</pre></h4></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Linked lists using arrays of nodes Languages that do not support any type of reference can still create links by replacing pointers with array indices. The approach is to keep an array of records, where each record has integer fields indicating the index of the next (and possibly previous) node in the array. Not all nodes in the array need be used. If records are also not supported, parallel arrays can often be used instead. As an example, consider the following linked list record that uses arrays instead of pointers:  record Entry {
    integer next; // index of next entry in array
    integer prev; // previous entry (if double-linked)
    string name;
    real balance;
 }
 A linked list can be built by creating an array of these structures, and an integer variable to store the index of the first element. integer listHead
Entry Records[1000]",
            "assembleScratchTime":"2019-04-05 14:31:39",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870491,
            "assembleContent":"<h2><span id="Linked_lists_using_arrays_of_nodes">Linked lists using arrays of nodes</span></h2><div><h4><p>Links between elements are formed by placing the array index of the next (or previous) cell into the Next or Prev field within a given element. For example:</p><table><tbody><tr><th>Index</th><th>Next</th><th>Prev</th><th>Name</th><th>Balance</th></tr><tr><td>0</td><td>1</td><td>4</td><td>Jones, John</td><td>123.45</td></tr><tr><td>1</td><td>−1</td><td>0</td><td>Smith, Joseph</td><td>234.56</td></tr><tr><td>2 (listHead)</td><td>4</td><td>−1</td><td>Adams, Adam</td><td>0.00</td></tr><tr><td>3</td><td></td><td></td><td>Ignore, Ignatius</td><td>999.99</td></tr><tr><td>4</td><td>0</td><td>2</td><td>Another, Anita</td><td>876.54</td></tr><tr><td>5</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>In the above example, <code>ListHead</code> would be set to 2, the location of the first entry in the list. Notice that entry 3 and 5 through 7 are not part of the list. These cells are available for any additions to the list. By creating a <code>ListFree</code> integer variable, a <a href="https://en.wikipedia.org/wiki/Free_list" title="Free list">free list</a> could be created to keep track of what cells are available. If all entries are in use, the size of the array would have to be increased or some elements would have to be deleted before new entries could be stored in the list.</p><p>The following code would traverse the list and display names and account balance:</p><pre>i := listHead
<b>while</b> i ≥ 0 <i>// loop through the list</i>
     print i, Records[i].name, Records[i].balance <i>// print entry</i>
     i := Records[i].next
</pre><p>When faced with a choice, the advantages of this approach include:</p><ul><li>The linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly <a href="https://en.wikipedia.org/wiki/Serialization" title="Serialization">serialized</a> for storage on disk or transfer over a network.</li><li>Especially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures.</li><li><a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Locality of reference">Locality of reference</a> can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store.</li><li>Naïve <a href="https://en.wikipedia.org/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation">dynamic memory allocators</a> can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach.</li><li>Seizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size.</li></ul><p>This approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues:</p><ul><li>It increases complexity of the implementation.</li><li>Growing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier.</li><li>Adding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (<a href="https://en.wikipedia.org/wiki/Big-O_notation" title="Big-O notation">O</a>(n)) instead of constant time (although it's still an <a href="https://en.wikipedia.org/wiki/Amortized_analysis" title="Amortized analysis">amortized</a> constant).</li><li>Using a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed.</li></ul><p>For these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.</p></h4></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Linked lists using arrays of nodes Links between elements are formed by placing the array index of the next (or previous) cell into the Next or Prev field within a given element. For example: Index Next Prev Name Balance 0 1 4 Jones, John 123.45 1 −1 0 Smith, Joseph 234.56 2 (listHead) 4 −1 Adams, Adam 0.00 3 Ignore, Ignatius 999.99 4 0 2 Another, Anita 876.54 5 6 7 In the above example, ListHead would be set to 2, the location of the first entry in the list. Notice that entry 3 and 5 through 7 are not part of the list. These cells are available for any additions to the list. By creating a ListFree integer variable, a free list could be created to keep track of what cells are available. If all entries are in use, the size of the array would have to be increased or some elements would have to be deleted before new entries could be stored in the list. The following code would traverse the list and display names and account balance: i := listHead
while i ≥ 0 // loop through the list
     print i, Records[i].name, Records[i].balance // print entry
     i := Records[i].next
 When faced with a choice, the advantages of this approach include: The linked list is relocatable, meaning it can be moved about in memory at will, and it can also be quickly and directly serialized for storage on disk or transfer over a network. Especially for a small list, array indexes can occupy significantly less space than a full pointer on many architectures. Locality of reference can be improved by keeping the nodes together in memory and by periodically rearranging them, although this can also be done in a general store. Naïve dynamic memory allocators can produce an excessive amount of overhead storage for each node allocated; almost no allocation overhead is incurred per node in this approach. Seizing an entry from a pre-allocated array is faster than using dynamic memory allocation for each node, since dynamic memory allocation typically requires a search for a free memory block of the desired size. This approach has one main disadvantage, however: it creates and manages a private memory space for its nodes. This leads to the following issues: It increases complexity of the implementation. Growing a large array when it is full may be difficult or impossible, whereas finding space for a new linked list node in a large, general memory pool may be easier. Adding elements to a dynamic array will occasionally (when it is full) unexpectedly take linear (O(n)) instead of constant time (although it's still an amortized constant). Using a general memory pool leaves more memory for other data if the list is smaller than expected or if many nodes are freed. For these reasons, this approach is mainly used for languages that do not support dynamic memory allocation. These disadvantages are also mitigated if the maximum size of the list is known at the time the array is created.",
            "assembleScratchTime":"2019-04-05 14:32:01",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870493,
            "assembleContent":"<h2><span id="Language_support">Language support</span></h2><div><p>Many <a href="https://en.wikipedia.org/wiki/Programming_language" title="Programming language">programming languages</a> such as <a href="https://en.wikipedia.org/wiki/Lisp_programming_language" title="Lisp programming language">Lisp</a> and <a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a> have singly linked lists built in. In many <a href="https://en.wikipedia.org/wiki/Functional_programming_language" title="Functional programming language">functional languages</a>, these lists are constructed from nodes, each called a <i><a href="https://en.wikipedia.org/wiki/Cons" title="Cons">cons</a></i> or <i>cons cell</i>. The cons has two fields: the <i><a href="https://en.wikipedia.org/wiki/Car_and_cdr" title="Car and cdr">car</a></i>, a reference to the data for that node, and the <i><a href="https://en.wikipedia.org/wiki/Car_and_cdr" title="Car and cdr">cdr</a></i>, a reference to the next node. Although cons cells can be used to build other data structures, this is their primary purpose.</p><p>In languages that support <a href="https://en.wikipedia.org/wiki/Abstract_data_type" title="Abstract data type">abstract data types</a> or templates, linked list ADTs or templates are available for building linked lists. In other languages, linked lists are typically built using <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a> together with <a href="https://en.wikipedia.org/wiki/Record_(computer_science)" title="Record (computer science)">records</a>.</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Language support Many programming languages such as Lisp and Scheme have singly linked lists built in. In many functional languages, these lists are constructed from nodes, each called a cons or cons cell. The cons has two fields: the car, a reference to the data for that node, and the cdr, a reference to the next node. Although cons cells can be used to build other data structures, this is their primary purpose. In languages that support abstract data types or templates, linked list ADTs or templates are available for building linked lists. In other languages, linked lists are typically built using references together with records.",
            "assembleScratchTime":"2019-04-05 14:32:19",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870495,
            "assembleContent":"<h2><span id="Internal_and_external_storage">Internal and external storage</span></h2><div><p>When constructing a linked list, one is faced with the choice of whether to store the data of the list directly in the linked list nodes, called <i>internal storage</i>, or merely to store a reference to the data, called <i>external storage</i>. Internal storage has the advantage of making access to the data more efficient, requiring less storage overall, having better <a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Locality of reference">locality of reference</a>, and simplifying memory management for the list (its data is allocated and deallocated at the same time as the list nodes).</p><p>External storage, on the other hand, has the advantage of being more generic, in that the same data structure and machine code can be used for a linked list no matter what the size of the data is. It also makes it easy to place the same data in multiple linked lists. Although with internal storage the same data can be placed in multiple lists by including multiple <i>next</i> references in the node data structure, it would then be necessary to create separate routines to add or delete cells based on each field. It is possible to create additional linked lists of elements that use internal storage by using external storage, and having the cells of the additional linked lists store references to the nodes of the linked list containing the data.</p><p>In general, if a set of data structures needs to be included in linked lists, external storage is the best approach. If a set of data structures need to be included in only one linked list, then internal storage is slightly better, unless a generic linked list package using external storage is available. Likewise, if different sets of data that can be stored in the same data structure are to be included in a single linked list, then internal storage would be fine.</p><p>Another approach that can be used with some languages involves having different data structures, but all have the initial fields, including the <i>next</i> (and <i>prev</i> if double linked list) references in the same location. After defining separate structures for each type of data, a generic structure can be defined that contains the minimum amount of data shared by all the other structures and contained at the top (beginning) of the structures. Then generic routines can be created that use the minimal structure to perform linked list type operations, but separate routines can then handle the specific data. This approach is often used in message parsing routines, where several types of messages are received, but all start with the same set of fields, usually including a field for message type. The generic routines are used to add new messages to a queue when they are received, and remove them from the queue in order to process the message. The message type field is then used to call the correct routine to process the specific type of message.</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Internal and external storage When constructing a linked list, one is faced with the choice of whether to store the data of the list directly in the linked list nodes, called internal storage, or merely to store a reference to the data, called external storage. Internal storage has the advantage of making access to the data more efficient, requiring less storage overall, having better locality of reference, and simplifying memory management for the list (its data is allocated and deallocated at the same time as the list nodes). External storage, on the other hand, has the advantage of being more generic, in that the same data structure and machine code can be used for a linked list no matter what the size of the data is. It also makes it easy to place the same data in multiple linked lists. Although with internal storage the same data can be placed in multiple lists by including multiple next references in the node data structure, it would then be necessary to create separate routines to add or delete cells based on each field. It is possible to create additional linked lists of elements that use internal storage by using external storage, and having the cells of the additional linked lists store references to the nodes of the linked list containing the data. In general, if a set of data structures needs to be included in linked lists, external storage is the best approach. If a set of data structures need to be included in only one linked list, then internal storage is slightly better, unless a generic linked list package using external storage is available. Likewise, if different sets of data that can be stored in the same data structure are to be included in a single linked list, then internal storage would be fine. Another approach that can be used with some languages involves having different data structures, but all have the initial fields, including the next (and prev if double linked list) references in the same location. After defining separate structures for each type of data, a generic structure can be defined that contains the minimum amount of data shared by all the other structures and contained at the top (beginning) of the structures. Then generic routines can be created that use the minimal structure to perform linked list type operations, but separate routines can then handle the specific data. This approach is often used in message parsing routines, where several types of messages are received, but all start with the same set of fields, usually including a field for message type. The generic routines are used to add new messages to a queue when they are received, and remove them from the queue in order to process the message. The message type field is then used to call the correct routine to process the specific type of message.",
            "assembleScratchTime":"2019-04-05 14:32:35",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870497,
            "assembleContent":"<h3><span id="Speeding_up_search">Speeding up search</span></h3><div><p>Finding a specific element in a linked list, even if it is sorted, normally requires O(<i>n</i>) time (<a href="https://en.wikipedia.org/wiki/Linear_search" title="Linear search">linear search</a>). This is one of the primary disadvantages of linked lists over other data structures. In addition to the variants discussed above, below are two simple ways to improve search time.</p><p>In an unordered list, one simple heuristic for decreasing average search time is the <i>move-to-front heuristic</i>, which simply moves an element to the beginning of the list once it is found. This scheme, handy for creating simple caches, ensures that the most recently used items are also the quickest to find again.</p><p>Another common approach is to "<a href="https://en.wikipedia.org/wiki/Index_(database)" title="Index (database)">index</a>" a linked list using a more efficient external data structure. For example, one can build a <a href="https://en.wikipedia.org/wiki/Red-black_tree" title="Red-black tree">red-black tree</a> or <a href="https://en.wikipedia.org/wiki/Hash_table" title="Hash table">hash table</a> whose elements are references to the linked list nodes. Multiple such indexes can be built on a single list. The disadvantage is that these indexes may need to be updated each time a node is added or removed (or at least, before that index is used again).</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Speeding up search Finding a specific element in a linked list, even if it is sorted, normally requires O(n) time (linear search). This is one of the primary disadvantages of linked lists over other data structures. In addition to the variants discussed above, below are two simple ways to improve search time. In an unordered list, one simple heuristic for decreasing average search time is the move-to-front heuristic, which simply moves an element to the beginning of the list once it is found. This scheme, handy for creating simple caches, ensures that the most recently used items are also the quickest to find again. Another common approach is to "index" a linked list using a more efficient external data structure. For example, one can build a red-black tree or hash table whose elements are references to the linked list nodes. Multiple such indexes can be built on a single list. The disadvantage is that these indexes may need to be updated each time a node is added or removed (or at least, before that index is used again).",
            "assembleScratchTime":"2019-04-05 14:32:56",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870500,
            "assembleContent":"<h3><span id="Random_access_lists">Random access lists</span></h3><div><p>A <a href="https://en.wikipedia.org/w/index.php?title=Random_access_list&action=edit&redlink=1" title="Random access list (page does not exist)">random access list</a> is a list with support for fast random access to read or modify any element in the list.<sup id="cite_ref-okasaki_10-0"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-okasaki-10">[9]</a></sup> One possible implementation is a <a href="https://en.wikipedia.org/w/index.php?title=Skew_binary_random_access_list&action=edit&redlink=1" title="Skew binary random access list (page does not exist)">skew binary random access list</a> using the <a href="https://en.wikipedia.org/wiki/Skew_binary_number_system" title="Skew binary number system">skew binary number system</a>, which involves a list of trees with special properties; this allows worst-case constant time head/cons operations, and worst-case logarithmic time random access to an element by index.<sup id="cite_ref-okasaki_10-1"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-okasaki-10">[9]</a></sup> Random access lists can be implemented as <a href="https://en.wikipedia.org/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structures</a>.<sup id="cite_ref-okasaki_10-2"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-okasaki-10">[9]</a></sup></p><p>Random access lists can be viewed as immutable linked lists in that they likewise support the same O(1) head and tail operations.<sup id="cite_ref-okasaki_10-3"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-okasaki-10">[9]</a></sup></p><p>A simple extension to random access lists is the <a href="https://en.wikipedia.org/w/index.php?title=Min-list&action=edit&redlink=1" title="Min-list (page does not exist)">min-list</a>, which provides an additional operation that yields the minimum element in the entire list in constant time (without<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (October 2011)">clarification needed</span></a></i>]</sup> mutation complexities).<sup id="cite_ref-okasaki_10-4"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-okasaki-10">[9]</a></sup></p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Random access lists A random access list is a list with support for fast random access to read or modify any element in the list.[9] One possible implementation is a skew binary random access list using the skew binary number system, which involves a list of trees with special properties; this allows worst-case constant time head/cons operations, and worst-case logarithmic time random access to an element by index.[9] Random access lists can be implemented as persistent data structures.[9] Random access lists can be viewed as immutable linked lists in that they likewise support the same O(1) head and tail operations.[9] A simple extension to random access lists is the min-list, which provides an additional operation that yields the minimum element in the entire list in constant time (without[clarification needed] mutation complexities).[9]",
            "assembleScratchTime":"2019-04-05 14:33:16",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870502,
            "assembleContent":"<h2><span id="Related_data_structures">Related data structures</span></h2><div><p>Both <a href="https://en.wikipedia.org/wiki/Stack_(data_structure)" title="Stack (data structure)">stacks</a> and <a href="https://en.wikipedia.org/wiki/Queue_(data_structure)" title="Queue (data structure)">queues</a> are often implemented using linked lists, and simply restrict the type of operations which are supported.</p><p>The <a href="https://en.wikipedia.org/wiki/Skip_list" title="Skip list">skip list</a> is a linked list augmented with layers of pointers for quickly jumping over large numbers of elements, and then descending to the next layer. This process continues down to the bottom layer, which is the actual list.</p><p>A <a href="https://en.wikipedia.org/wiki/Binary_tree" title="Binary tree">binary tree</a> can be seen as a type of linked list where the elements are themselves linked lists of the same nature. The result is that each node may include a reference to the first node of one or two other linked lists, which, together with their contents, form the subtrees below that node.</p><p>An <a href="https://en.wikipedia.org/wiki/Unrolled_linked_list" title="Unrolled linked list">unrolled linked list</a> is a linked list in which each node contains an array of data values. This leads to improved <a href="https://en.wikipedia.org/wiki/CPU_cache" title="CPU cache">cache</a> performance, since more list elements are contiguous in memory, and reduced memory overhead, because less metadata needs to be stored for each element of the list.</p><p>A <a href="https://en.wikipedia.org/wiki/Hash_table" title="Hash table">hash table</a> may use linked lists to store the chains of items that hash to the same position in the hash table.</p><p>A <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a> shares some of the ordering properties of a linked list, but is almost always implemented using an array. Instead of references from node to node, the next and previous data indexes are calculated using the current data's index.</p><p>A <a href="https://en.wikipedia.org/wiki/Self-organizing_list" title="Self-organizing list">self-organizing list</a> rearranges its nodes based on some heuristic which reduces search times for data retrieval by keeping commonly accessed nodes at the head of the list.</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Related data structures Both stacks and queues are often implemented using linked lists, and simply restrict the type of operations which are supported. The skip list is a linked list augmented with layers of pointers for quickly jumping over large numbers of elements, and then descending to the next layer. This process continues down to the bottom layer, which is the actual list. A binary tree can be seen as a type of linked list where the elements are themselves linked lists of the same nature. The result is that each node may include a reference to the first node of one or two other linked lists, which, together with their contents, form the subtrees below that node. An unrolled linked list is a linked list in which each node contains an array of data values. This leads to improved cache performance, since more list elements are contiguous in memory, and reduced memory overhead, because less metadata needs to be stored for each element of the list. A hash table may use linked lists to store the chains of items that hash to the same position in the hash table. A heap shares some of the ordering properties of a linked list, but is almost always implemented using an array. Instead of references from node to node, the next and previous data indexes are calculated using the current data's index. A self-organizing list rearranges its nodes based on some heuristic which reduces search times for data retrieval by keeping commonly accessed nodes at the head of the list.",
            "assembleScratchTime":"2019-04-05 14:33:36",
            "facetId":556198,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870166,
            "assembleContent":"<h2><span style="font-size: medium;">使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。  </span></h2> ",
            "assembleText":"使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。  ",
            "assembleScratchTime":"2019-04-05 12:57:53",
            "facetId":556219,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870167,
            "assembleContent":"<h2><span style="font-size: medium;">在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</span></h2> ",
            "assembleText":"在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串节点组成，每个节点包含任意的实例数据（data fields）和一或两个用来指向上一个/或下一个节点的位置的链接（"links"）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。",
            "assembleScratchTime":"2019-04-05 12:58:10",
            "facetId":556219,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870170,
            "assembleContent":"<h2><span style="font-size: medium;">链表可以在多种编程语言中实现。像<a href="https://zh.wikipedia.org/wiki/Lisp" title="Lisp">Lisp</a>和<a href="https://zh.wikipedia.org/wiki/Scheme" title="Scheme">Scheme</a>这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。</span></h2> ",
            "assembleText":"链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的访问和操作。程序语言或面向对象语言，如C/C++和Java依靠易变工具来生成链表。",
            "assembleScratchTime":"2019-04-05 12:58:37",
            "facetId":556219,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870172,
            "assembleContent":"<h2><span style="font-size: medium;">链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。  </span></h2> ",
            "assembleText":"链表最基本的结构是在每个节点保存数据和到下一个节点的地址，在最后一个节点保存一个特殊的结束标记，另外在一个固定的位置保存指向第一个节点的指针，有的时候也会同时储存指向最后一个节点的指针。一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。但是也可以提前把一个节点的位置另外保存起来，然后直接访问。当然如果只是访问数据就没必要了，不如在链表上储存指向实际数据的指针。这样一般是为了访问链表中的下一个或者前一个（需要储存反向的指针，见下面的双向链表）节点。  ",
            "assembleScratchTime":"2019-04-05 12:59:21",
            "facetId":556219,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870186,
            "assembleContent":"<h1><p><span style="font-size: medium;">链表的定义是递归的，它或者为空null，或者指向另一个节点node的引用，这个节点含有下一个节点或链表的引用。</span></p><pre></pre><p><span style="font-size: medium;">与顺序存储相比，允许存储空间不连续，插入删除时不需要移动大量的元素，只需修改指针即可，但查找某个元素，只能从头遍历整个链表。</span></p><pre></pre><p><span style="font-size: medium;">Java中使用嵌套类来定义节点的抽象数据类型：</span></p><pre></pre><p><span style="font-size: medium;"> </span></p><pre></pre><pre><span style="font-size: medium;">private class Node{
    // 链表节点的嵌套类
    T item; // 节点内容
    Node next; // 后继节点
}</span></pre></h1> ",
            "assembleText":"链表的定义是递归的，它或者为空null，或者指向另一个节点node的引用，这个节点含有下一个节点或链表的引用。 与顺序存储相比，允许存储空间不连续，插入删除时不需要移动大量的元素，只需修改指针即可，但查找某个元素，只能从头遍历整个链表。 Java中使用嵌套类来定义节点的抽象数据类型：   private class Node{
    // 链表节点的嵌套类
    T item; // 节点内容
    Node next; // 后继节点
}",
            "assembleScratchTime":"2019-04-05 13:04:01",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870269,
            "assembleContent":"<p>请我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以双向链表和循环链表依旧是线性表。  <br></p> ",
            "assembleText":"请我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以双向链表和循环链表依旧是线性表。  ",
            "assembleScratchTime":"2019-04-05 13:36:46",
            "facetId":556219,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2870273,
            "assembleContent":"<h1><div id="cnblogs_post_body"><p><span style="font-size: medium;">对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。    </span><br></p></div></h1> ",
            "assembleText":"对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。    ",
            "assembleScratchTime":"2019-04-05 13:37:59",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870375,
            "assembleContent":"<p>链表的特点：</p><p>　　1.不需要提前知道要存入数据的长度</p><p>　　2.最后结点为NULL</p><p>　　3.头结点指向下一个结点的结构体指针</p> ",
            "assembleText":"链表的特点： 　　1.不需要提前知道要存入数据的长度 　　2.最后结点为NULL 　　3.头结点指向下一个结点的结构体指针",
            "assembleScratchTime":"2019-04-05 14:00:12",
            "facetId":556219,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/yuwensong/p/5445712.html",
            "type":"text"
        },
        {
            "assembleId":2870389,
            "assembleContent":"<p>在数组中，是通过<strong>索引</strong>访问元素的，但是不要小看索引，好多精妙的算法都是利用了这个<strong>索引</strong>玩花样。但是链表不能，只能通过链一个一个的找。这个说明了链表的优势不在快速找到元素。而哈希表，是通过散列函数将任意Key变成了<strong>索引</strong>，可以看成是索引的一种应用。</p><p>链表的优势在于<strong>定点</strong>删除／插入元素，因为链表影响的最多就是给定元素的左右的两个链，但是数组却做不到，数组由于大小固定，删除操作会移动所有的元素。</p><p>这里就有个trick, 由于改变右边链的时候，如果不先存储右边的<strong>结点</strong>，那么右边的结点的元素就找不到了，所以改变结点的指针的时候，会先暂存下一个<strong>结点</strong>。 <br>另外单链表找不到它的父亲结点(上一个结点)，所以会经常用prev来暂存上一个结点。</p><p>总而言之，链表这一数据结构和数组的差别还是挺大的，属于两种不同的思维方式。</p> ",
            "assembleText":"在数组中，是通过索引访问元素的，但是不要小看索引，好多精妙的算法都是利用了这个索引玩花样。但是链表不能，只能通过链一个一个的找。这个说明了链表的优势不在快速找到元素。而哈希表，是通过散列函数将任意Key变成了索引，可以看成是索引的一种应用。 链表的优势在于定点删除／插入元素，因为链表影响的最多就是给定元素的左右的两个链，但是数组却做不到，数组由于大小固定，删除操作会移动所有的元素。 这里就有个trick, 由于改变右边链的时候，如果不先存储右边的结点，那么右边的结点的元素就找不到了，所以改变结点的指针的时候，会先暂存下一个结点。  另外单链表找不到它的父亲结点(上一个结点)，所以会经常用prev来暂存上一个结点。 总而言之，链表这一数据结构和数组的差别还是挺大的，属于两种不同的思维方式。",
            "assembleScratchTime":"2019-04-05 14:02:54",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u012280578/article/details/78528717",
            "type":"text"
        },
        {
            "assembleId":2870402,
            "assembleContent":"<p>下面哪些不是链表的特征？</p><p>    A.数据在内存中一定是连续的<br></p><p>   B.插入或删除时，无需移动其它元素</p><p>   C.可以随机访问表内的元素</p><p>   D.需要事先估计存储空间</p><p></p><h1>正确答案: A C D </h1><p>这道题是考察链表的最基本特性：链表是用指针来指向元素的值，所有的操作都是通过移动指针来进行的，本身的元素不需要移动。
A中，数据在内存中的地址（即物理地址）不一定连续，但是他们的逻辑地址是连续的。
B中，插入或者删除时，改变的是指向数据的指针，其元素都是不变的。
C中，对于单链表来说，只有指向链表头的头指针，所以不能随机访问表内元素，只能通过指针的移动。
D中，链表的存储空间是不需要事先估计的，他不是线性的，所以可以随着结点的增加而随时增加存储空间。  <br></p>  ",
            "assembleText":"下面哪些不是链表的特征？     A.数据在内存中一定是连续的    B.插入或删除时，无需移动其它元素    C.可以随机访问表内的元素    D.需要事先估计存储空间 正确答案: A C D  这道题是考察链表的最基本特性：链表是用指针来指向元素的值，所有的操作都是通过移动指针来进行的，本身的元素不需要移动。 A中，数据在内存中的地址（即物理地址）不一定连续，但是他们的逻辑地址是连续的。 B中，插入或者删除时，改变的是指向数据的指针，其元素都是不变的。 C中，对于单链表来说，只有指向链表头的头指针，所以不能随机访问表内元素，只能通过指针的移动。 D中，链表的存储空间是不需要事先估计的，他不是线性的，所以可以随着结点的增加而随时增加存储空间。  ",
            "assembleScratchTime":"2019-04-05 14:05:46",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/m0_37920544/article/details/79955822",
            "type":"text"
        },
        {
            "assembleId":2870405,
            "assembleContent":"<p>链表，增删快，查询慢，线程不安全，效率高。  <br></p>  ",
            "assembleText":"链表，增删快，查询慢，线程不安全，效率高。  ",
            "assembleScratchTime":"2019-04-05 14:06:20",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/miaodian2016/article/details/52422498",
            "type":"text"
        },
        {
            "assembleId":2870414,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/863580272/796279665.png" style="max-width:100%;"><br></p>  ",
            "assembleText":"",
            "assembleScratchTime":"2019-04-05 14:08:12",
            "facetId":556219,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870437,
            "assembleContent":"<p>Linked lists are among the simplest and most common data structures. They can be used to implement several other common <a href="https://en.wikipedia.org/wiki/Abstract_data_type" title="Abstract data type">abstract data types</a>, including <a href="https://en.wikipedia.org/wiki/List_(abstract_data_type)" title="List (abstract data type)">lists</a>, <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" title="Stack (abstract data type)">stacks</a>, <a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" title="Queue (abstract data type)">queues</a>, <a href="https://en.wikipedia.org/wiki/Associative_array" title="Associative array">associative arrays</a>, and <a href="https://en.wikipedia.org/wiki/S-expression" title="S-expression">S-expressions</a>, though it is not uncommon to implement those data structures directly without using a linked list as the basis.  <br></p> ",
            "assembleText":"Linked lists are among the simplest and most common data structures. They can be used to implement several other common abstract data types, including lists, stacks, queues, associative arrays, and S-expressions, though it is not uncommon to implement those data structures directly without using a linked list as the basis.  ",
            "assembleScratchTime":"2019-04-05 14:19:49",
            "facetId":556219,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870438,
            "assembleContent":"<p>The principal benefit of a linked list over a conventional <a href="https://en.wikipedia.org/wiki/Array_data_structure" title="Array data structure">array</a> is that the list elements can be easily inserted or removed without reallocation or reorganization of the entire structure because the data items need not be stored <a href="https://en.wiktionary.org/wiki/contiguous" title="wikt:contiguous">contiguously</a> in memory or on disk, while restructuring an array at <a href="https://en.wikipedia.org/wiki/Run_time_(program_lifecycle_phase)" title="Run time (program lifecycle phase)">run-time</a> is a much more expensive operation. Linked lists allow insertion and removal of nodes at any point in the list, and allow doing so with a constant number of operations by keeping the link previous to the link being added or removed in memory during list traversal.  <br></p> ",
            "assembleText":"The principal benefit of a linked list over a conventional array is that the list elements can be easily inserted or removed without reallocation or reorganization of the entire structure because the data items need not be stored contiguously in memory or on disk, while restructuring an array at run-time is a much more expensive operation. Linked lists allow insertion and removal of nodes at any point in the list, and allow doing so with a constant number of operations by keeping the link previous to the link being added or removed in memory during list traversal.  ",
            "assembleScratchTime":"2019-04-05 14:19:59",
            "facetId":556219,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870439,
            "assembleContent":"<p>On the other hand, since simple linked lists by themselves do not allow <a href="https://en.wikipedia.org/wiki/Random_access" title="Random access">random access</a> to the data or any form of efficient indexing, many basic operations—such as obtaining the last node of the list, finding a node that contains a given datum, or locating the place where a new node should be inserted—may require iterating through most or all of the list elements. The advantages and disadvantages of using linked lists are given below. Linked list are dynamic, so the length of list can increase or decrease as necessary. Each node does not necessarily follow the previous one physically in the memory.  <br></p> ",
            "assembleText":"On the other hand, since simple linked lists by themselves do not allow random access to the data or any form of efficient indexing, many basic operations—such as obtaining the last node of the list, finding a node that contains a given datum, or locating the place where a new node should be inserted—may require iterating through most or all of the list elements. The advantages and disadvantages of using linked lists are given below. Linked list are dynamic, so the length of list can increase or decrease as necessary. Each node does not necessarily follow the previous one physically in the memory.  ",
            "assembleScratchTime":"2019-04-05 14:20:07",
            "facetId":556219,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870440,
            "assembleContent":"<h2><span id="Disadvantages">Disadvantages</span></h2><ul><li>They use more memory than <a href="https://en.wikipedia.org/wiki/Array_data_structure" title="Array data structure">arrays</a> because of the storage used by their <a href="https://en.wikipedia.org/wiki/Pointer_(computer_science)" title="Pointer (computer science)">pointers</a>.</li><li>Nodes in a linked list must be read in order from the beginning as linked lists are inherently <a href="https://en.wikipedia.org/wiki/Sequential_access" title="Sequential access">sequential access</a>.</li><li>Nodes are stored incontiguously, greatly increasing the time periods required to access individual elements within the list, especially with a <a href="https://en.wikipedia.org/wiki/CPU_cache" title="CPU cache">CPU cache</a>.</li><li>Difficulties arise in linked lists when it comes to reverse traversing. For instance, singly linked lists are cumbersome to navigate backwards<sup id="cite_ref-1"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-1">[1]</a></sup> and while doubly linked lists are somewhat easier to read, memory is consumed in allocating space for a <a href="https://en.wikipedia.org/wiki/Back-pointer" title="Back-pointer">back-pointer</a>.</li></ul> ",
            "assembleText":"Disadvantages They use more memory than arrays because of the storage used by their pointers. Nodes in a linked list must be read in order from the beginning as linked lists are inherently sequential access. Nodes are stored incontiguously, greatly increasing the time periods required to access individual elements within the list, especially with a CPU cache. Difficulties arise in linked lists when it comes to reverse traversing. For instance, singly linked lists are cumbersome to navigate backwards[1] and while doubly linked lists are somewhat easier to read, memory is consumed in allocating space for a back-pointer.",
            "assembleScratchTime":"2019-04-05 14:20:26",
            "facetId":556219,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870148,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1554184161763/659411658.png">  <br></p><p><br></p> ",
            "assembleText":"  ",
            "assembleScratchTime":"2019-04-05 12:49:35",
            "facetId":556252,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870149,
            "assembleContent":"<h3><strong>线性表有两种实现方式，一种是内置数组实现，另一种是链表实现</strong>，最好把链表就理解为线性表的一种实现方式，而且从链表的定义来看，它的本质是一种数据结构 。 <br></h3><p><br></p> ",
            "assembleText":"线性表有两种实现方式，一种是内置数组实现，另一种是链表实现，最好把链表就理解为线性表的一种实现方式，而且从链表的定义来看，它的本质是一种数据结构 。 ",
            "assembleScratchTime":"2019-04-05 12:49:58",
            "facetId":556252,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_26849233/article/details/72235521",
            "type":"text"
        },
        {
            "assembleId":2870150,
            "assembleContent":"<h3><pre>线性表、包括顺序表和链表<br>顺序表里面元素的地址是连续的，<br>链表里面节点的地址不是连续的，是通过指针连起来的。</pre></h3> ",
            "assembleText":"线性表、包括顺序表和链表 顺序表里面元素的地址是连续的， 链表里面节点的地址不是连续的，是通过指针连起来的。",
            "assembleScratchTime":"2019-04-05 12:50:20",
            "facetId":556255,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870151,
            "assembleContent":"<table><tbody><tr><th><p>存储类别</p></th><th>顺序存储结构</th><th>单链表</th></tr><tr><td>存储分配方式</td><td>用一段连续的存储单元依次存储线性表的数据元素</td><td>采用链式存储结构，用一组任意的存储单元存放线性表的元素</td></tr><tr><td>时间性能</td><td>查找O（1）、插入和删除O（n）</td><td>查找O（n）、插入和删除O（1）</td></tr><tr><td>空间性能</td><td>需要预分配存储空间，分大了浪费，小了容易发生上溢</td><td>不需要分配存储空间，只要有就可以分配，元素个数不受限制</td></tr></tbody></table> ",
            "assembleText":"存储类别 顺序存储结构 单链表 存储分配方式 用一段连续的存储单元依次存储线性表的数据元素 采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找O（1）、插入和删除O（n） 查找O（n）、插入和删除O（1） 空间性能 需要预分配存储空间，分大了浪费，小了容易发生上溢 不需要分配存储空间，只要有就可以分配，元素个数不受限制",
            "assembleScratchTime":"2019-04-05 12:50:42",
            "facetId":556255,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/lzw66666/article/details/78237215",
            "type":"text"
        },
        {
            "assembleId":2870152,
            "assembleContent":"<p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。线性表的逻辑结构简单，便于实现和操作。因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。<br><br>顺序表是在计算机内存中以数组的形式保存的线性表,是指用一组地址连续的存储单元依次存储数据元素的<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">线性结构</a>。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。<br><br>链表是一种物理存储单元上非连续、非顺序的<a href="https://www.baidu.com/s?wd=%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">存储结构</a>，数据元素的<a href="https://www.baidu.com/s?wd=%E9%80%BB%E8%BE%91%E9%A1%BA%E5%BA%8F&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">逻辑顺序</a>是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表<a href="https://www.baidu.com/s?wd=%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">顺序结构</a>，链表比较方便插入和删除操作。    <br></p> ",
            "assembleText":"线性表是最基本、最简单、也是最常用的一种数据结构。线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。线性表的逻辑结构简单，便于实现和操作。因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。 顺序表是在计算机内存中以数组的形式保存的线性表,是指用一组地址连续的存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，链表比较方便插入和删除操作。    ",
            "assembleScratchTime":"2019-04-05 12:51:00",
            "facetId":556255,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/83328266.html",
            "type":"text"
        },
        {
            "assembleId":2870153,
            "assembleContent":"<h3>链表和列表的区别</h3><table border="0" align="left"><tbody><tr><td> </td><td>列表</td><td>链表</td></tr><tr><td>读取</td><td>O(1)</td><td>O(n)</td></tr><tr><td>插入</td><td>O(n)</td><td>O(1)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(n)</td></tr></tbody></table> ",
            "assembleText":"链表和列表的区别   列表 链表 读取 O(1) O(n) 插入 O(n) O(1) 删除 O(1) O(n)",
            "assembleScratchTime":"2019-04-05 12:51:17",
            "facetId":556255,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/83328266.html",
            "type":"text"
        },
        {
            "assembleId":2870272,
            "assembleContent":"<h1><div id="cnblogs_post_body"><p><span style="font-size: medium;">顺序表和链表的比较</span></p><pre></pre><p><span style="font-size: medium;">1. 顺序表可以顺序存取，也支持随机存取；链表只能顺序存取。</span></p><pre></pre><p><span style="font-size: medium;">2. 顺序表逻辑上相邻的物理上也相邻；而链表不一定，它是用指针来描述元素之间的关系。</span></p><pre></pre><p><span style="font-size: medium;">3. 顺序表插入和删除要移动大量元素；链表只需修改指针即可</span></p><pre></pre></div><div id="blog_post_info_block"></div></h1><p><br></p> ",
            "assembleText":"顺序表和链表的比较 1. 顺序表可以顺序存取，也支持随机存取；链表只能顺序存取。 2. 顺序表逻辑上相邻的物理上也相邻；而链表不一定，它是用指针来描述元素之间的关系。 3. 顺序表插入和删除要移动大量元素；链表只需修改指针即可",
            "assembleScratchTime":"2019-04-05 13:37:34",
            "facetId":556255,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870275,
            "assembleContent":"<h1><div id="cnblogs_post_body"><p><span style="font-size: medium;">单链表结构与顺序存储结构优缺点</span></p><p><span style="font-size: medium;">　　1、单链表结构和顺序存储结构对比：</span></p><p><span style="font-size: medium;">　　　　a、存储分配方式：</span></p><p><span style="font-size: medium;">　　　　顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。</span></p><p><span style="font-size: medium;">　　　　单链表采用链式存储结构，用一组任意的存储结构单元存放线性表的元素。</span></p><p><span style="font-size: medium;">　　　　b、时间性能：</span></p><p><span style="font-size: medium;">　　　　查找：顺序存储结构O(1)，单链表O(n)。</span></p><p><span style="font-size: medium;">　　　　插入和删除：顺序存储结构需要平均移动表长一半的元素，时间为O(n)。单链表在线出某位置的指针后，插入和删除时间仅为O(1)。</span></p><p><span style="font-size: medium;">　　　　c、空间性能：顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</span></p></div></h1> ",
            "assembleText":"单链表结构与顺序存储结构优缺点 　　1、单链表结构和顺序存储结构对比： 　　　　a、存储分配方式： 　　　　顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。 　　　　单链表采用链式存储结构，用一组任意的存储结构单元存放线性表的元素。 　　　　b、时间性能： 　　　　查找：顺序存储结构O(1)，单链表O(n)。 　　　　插入和删除：顺序存储结构需要平均移动表长一半的元素，时间为O(n)。单链表在线出某位置的指针后，插入和删除时间仅为O(1)。 　　　　c、空间性能：顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。",
            "assembleScratchTime":"2019-04-05 13:38:42",
            "facetId":556255,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870276,
            "assembleContent":"<h1><div id="cnblogs_post_body"><p><span style="font-size: medium;">若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</span></p><p><span style="font-size: medium;">　　　　当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题，如果知道大致长度，宜采用顺序存储结构。</span></p></div></h1> ",
            "assembleText":"若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。 　　　　当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题，如果知道大致长度，宜采用顺序存储结构。",
            "assembleScratchTime":"2019-04-05 13:39:00",
            "facetId":556255,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870394,
            "assembleContent":"<p><strong>顺序表</strong></p><ol><li><p>长度固定，必须在分配内存之前确定数组的长度。</p></li><li><p>存储空间连续，即允许元素的随机访问。</p></li><li><p>存储密度大，内存中存储的全部是数据元素。</p></li><li><p>要访问特定元素，可以使用索引访问，时间复杂度为 $O(1)$。</p></li><li><p>要想在顺序表中插入或删除一个元素，都涉及到之后所有元素的移动，因此时间复杂度为 $O(n)$。</p></li><li><p>顺序表最主要的问题就是要求长度是固定的，可以使用倍增-复制的办法来支持动态扩容，将顺序表变成“可变长度”的。</p></li><li><p>这个办法不可避免的会浪费一些内存，因为数组的容量总是倍增的。而且每次扩容的时候，都需要将旧的数据全部复制一份，肯定会影响效率。不过实际上，这样做还是直接使用链表的效率要高。</p></li><li><p><strong>链表</strong></p></li><li><ol><li><p>长度不固定，可以任意增删。</p></li><li><p>存储空间不连续，数据元素之间使用指针相连，每个数据元素只能访问周围的一个元素（根据单链表还是双链表有所不同）。</p></li><li><p>存储密度小，因为每个数据元素，都需要额外存储一个指向下一元素的指针（双链表则需要两个指针）。</p></li><li><p>要访问特定元素，只能从链表头开始，遍历到该元素，时间复杂度为 $O(n)$。在特定的数据元素之后插入或删除元素，不涉及到其他元素的移动，因此时间复杂度为 $O(1)$。双链表还允许在特定的数据元素之前插入或删除元素。</p></li></ol></li></ol>  ",
            "assembleText":"顺序表 长度固定，必须在分配内存之前确定数组的长度。 存储空间连续，即允许元素的随机访问。 存储密度大，内存中存储的全部是数据元素。 要访问特定元素，可以使用索引访问，时间复杂度为 $O(1)$。 要想在顺序表中插入或删除一个元素，都涉及到之后所有元素的移动，因此时间复杂度为 $O(n)$。 顺序表最主要的问题就是要求长度是固定的，可以使用倍增-复制的办法来支持动态扩容，将顺序表变成“可变长度”的。 这个办法不可避免的会浪费一些内存，因为数组的容量总是倍增的。而且每次扩容的时候，都需要将旧的数据全部复制一份，肯定会影响效率。不过实际上，这样做还是直接使用链表的效率要高。 链表 长度不固定，可以任意增删。 存储空间不连续，数据元素之间使用指针相连，每个数据元素只能访问周围的一个元素（根据单链表还是双链表有所不同）。 存储密度小，因为每个数据元素，都需要额外存储一个指向下一元素的指针（双链表则需要两个指针）。 要访问特定元素，只能从链表头开始，遍历到该元素，时间复杂度为 $O(n)$。在特定的数据元素之后插入或删除元素，不涉及到其他元素的移动，因此时间复杂度为 $O(1)$。双链表还允许在特定的数据元素之前插入或删除元素。",
            "assembleScratchTime":"2019-04-05 14:04:01",
            "facetId":556255,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/332129079.html",
            "type":"text"
        },
        {
            "assembleId":2870399,
            "assembleContent":"<p>顺序表的优点是可以随机访问数据元素；缺点是大小固定，不利于增删结点。链表的优点是采用指针方式增减结点，非常方便（只需要改变指针指向，不移动结点）；缺点是不能进行随机访问，另外，每个结点上增加指针域，造成额外存储空间增大。  <br></p>  ",
            "assembleText":"顺序表的优点是可以随机访问数据元素；缺点是大小固定，不利于增删结点。链表的优点是采用指针方式增减结点，非常方便（只需要改变指针指向，不移动结点）；缺点是不能进行随机访问，另外，每个结点上增加指针域，造成额外存储空间增大。  ",
            "assembleScratchTime":"2019-04-05 14:04:52",
            "facetId":556255,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/147755595.html",
            "type":"text"
        },
        {
            "assembleId":2870412,
            "assembleContent":"<p><strong><em>顺序表与链表间存储密度的差异：</em></strong></p><br><p><img src="http://yotta.xjtushilei.com:8090/863580255/446648465.png" style="max-width: 100%;"> 顺序表的存储密度为1，而链表的存储密度小于1。</p>  ",
            "assembleText":"顺序表与链表间存储密度的差异：  顺序表的存储密度为1，而链表的存储密度小于1。",
            "assembleScratchTime":"2019-04-05 14:07:46",
            "facetId":556255,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870157,
            "assembleContent":"<h2><span style="font-size: medium;"><b>单向链表</b>（又名单链表、线性链表）是<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" title="链表">链表</a>的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。  </span></h2> ",
            "assembleText":"单向链表（又名单链表、线性链表）是链表的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。  ",
            "assembleScratchTime":"2019-04-05 12:53:17",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870158,
            "assembleContent":"<h2><p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。</p><p><a href="https://zh.wikipedia.org/wiki/File:Link_zh.png"><img alt="Link zh.png" src="https://upload.wikimedia.org/wikipedia/commons/4/45/Link_zh.png" decoding="async" width="517" height="170"></a></p></h2> ",
            "assembleText":"一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。",
            "assembleScratchTime":"2019-04-05 12:53:43",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870159,
            "assembleContent":"<h2><span id="動態單鏈表（C语言）" style="font-size: medium;">动态单链表（C语言）</span></h2><h2><p><span style="font-size: medium;">单向链表的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">数据结构</a>可以分为两部分：数据域和<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="指针 (计算机科学)">指针</a>域，数据域存储数据，指针域指向下一个存储节点的地址。  <br></span></p><pre><code><span style="font-size: medium;">#include <stdio.h><br>#include <stdlib.h><br>#include <conio.h><br><br>#define Status int<br>#define ElemType int // 以整型為例<br><br>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br><br>// 線性表的單鏈表存儲结構<br>typedef struct LNode {<br>    ElemType data;<br>    struct LNode *next;<br>} LNode, *LinkList;<br><br>// 带有头结點的單鏈表的基本操作(12个)<br>void InitList(LinkList *L) {<br>    // 操作结果：構造一个空的線性表L<br>    *L = (LinkList)malloc(sizeof(struct LNode));<br>    // 產生头结點，並使L指向此头结點<br>    if (!*L) // 存儲分配失敗<br>        exit(OVERFLOW);<br>    (*L)->next = NULL; // 指针域為空<br>}<br><br>void DestroyList(LinkList *L) {<br>    // 初始條件：線性表L已存在。操作结果：销毁線性表L<br>    LinkList q;<br>    while (*L) {<br>        q = (*L)->next;<br>        free(*L);<br>        *L = q;<br>    }<br>}<br><br>void ClearList(LinkList L) { // 不改变L<br>    // 初始条件：线性表L已存在。操作结果：将L重置为空表<br>    LinkList p, q;<br>    p = L->next; // p指向第一个结点<br>    while (p) { // 没到表尾<br>        q = p->next;<br>        free(p);<br>        p = q;<br>    }<br>    L->next = NULL; // 头结点指针域为空<br>}<br><br>Status ListEmpty(LinkList L) {<br>    // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE<br>    return L->next == NULL;<br>}<br><br>int ListLength(LinkList L) {<br>    // 初始条件：线性表L已存在。操作结果：返回L中数据元素个数<br>    int i = 0;<br>    LinkList p = L->next; // p指向第一个结点<br>    while (p) { // 没到表尾<br>        i++;<br>        p = p->next;<br>    }<br>    return i;<br>}<br><br>Status GetElem(LinkList L, int i, ElemType *e) {<br>    // L为带头结点的单链表的头指针。当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR<br>    int j = 1; // j为计数器<br>    LinkList p = L->next; // p指向第一个结点<br>    while (p && j < i) { // 顺指针向后查找，直到p指向第i个元素或p为空<br>        p = p->next;<br>        j++;<br>    }<br>    if (!p || j > i) // 第i个元素不存在<br>        return ERROR;<br>    *e = p->data; // 取第i个元素<br>    return OK;<br>}<br><br>int LocateElem(LinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) {<br>    // 初始条件: 线性表L已存在，compare()是数据元素判定函数(满足为1，否则为0)<br>    // 操作结果: 返回L中第1个与e满足关系compare()的数据元素的位序<br>    // 若这样的数据元素不存在，则返回值为0<br>    int i = 0;<br>    LinkList p = L->next;<br>    while (p) {<br>        i++;<br>        if (compare(p->data, e)) // 找到这样的数据元素<br>            return i;<br>        p = p->next;<br>    }<br>    return 0;<br>}<br><br>Status PriorElem(LinkList L, ElemType cur_e, ElemType *pre_e) {<br>    // 初始条件: 线性表L已存在<br>    // 操作结果: 若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，<br>    // 返回OK；否则操作失败，pre_e无定义，返回INFEASIBLE<br>    LinkList q, p = L->next; // p指向第一个结点<br>    while (p->next) { // p所指结点有后继<br>        q = p->next; // q为p的后继<br>        if (q->data == cur_e) {<br>            *pre_e = p->data;<br>            return OK;<br>        }<br>        p = q; // p向后移<br>    }<br>    return INFEASIBLE;<br>}<br><br>Status NextElem(LinkList L, ElemType cur_e, ElemType *next_e) {<br>    // 初始条件：线性表L已存在<br>    // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，<br>    // 返回OK;否则操作失败，next_e无定义，返回INFEASIBLE<br>    LinkList p = L->next; // p指向第一个结点<br>    while (p->next) { // p所指结点有后继<br>        if (p->data == cur_e) {<br>            *next_e = p->next->data;<br>            return OK;<br>        }<br>        p = p->next;<br>    }<br>    return INFEASIBLE;<br>}<br><br>Status ListInsert(LinkList L, int i, ElemType e) {<br>    // 算法2.9。不改变L<br>    // 在带头结点的单链线性表L中第i个位置之前插入元素e<br>    int j = 0;<br>    LinkList p = L, s;<br>    while (p && j < i - 1) { // 寻找第i-1个结点<br>        p = p->next;<br>        j++;<br>    }<br>    if (!p || j > i - 1) // i小于1或者大于表长<br>        return ERROR;<br>    s = (LinkList)malloc(sizeof(struct LNode)); // 生成新结点<br>    s->data = e; // 插入L中<br>    s->next = p->next;<br>    p->next = s;<br>    return OK;<br>}<br><br>Status ListDelete(LinkList L, int i, ElemType *e) {<br>    // 算法2.10。不改变L<br>    // 在带头结点的单链线性表L中，删除第i个元素，并由e返回其值<br>    int j = 0;<br>    LinkList p = L, q;<br>    while (p->next && j < i - 1) { // 寻找第i个结点，并令p指向其前驱结点<br>        p = p->next;<br>        j++;<br>    }<br>    if (!p->next || j > i - 1) // 删除位置不合理<br>        return ERROR;<br>    q = p->next; // 删除并释放结点<br>    p->next = q->next;<br>    *e = q->data;<br>    free(q);<br>    return OK;<br>}<br><br>void ListTraverse(LinkList L, void(*vi)(ElemType)) {<br>    // vi的形参类型为ElemType，与bo2-1.c中相应函数的形参类型ElemType&不同<br>    // 初始条件：线性表L已存在。操作结果：依次对L的每个数据元素调用函数vi()<br>    LinkList p = L->next;<br>    while (p) {<br>        vi(p->data);<br>        p = p->next;<br>    }<br>    printf("\n");<br>}</span></code></pre><br></h2> ",
            "assembleText":"动态单链表（C语言） 单向链表的数据结构可以分为两部分：数据域和指针域，数据域存储数据，指针域指向下一个存储节点的地址。   #include <stdio.h> #include <stdlib.h> #include <conio.h> #define Status int #define ElemType int // 以整型為例 #define OVERFLOW -1 #define ERROR 0 #define OK 1 // 線性表的單鏈表存儲结構 typedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; // 带有头结點的單鏈表的基本操作(12个) void InitList(LinkList *L) { // 操作结果：構造一个空的線性表L *L = (LinkList)malloc(sizeof(struct LNode)); // 產生头结點，並使L指向此头结點 if (!*L) // 存儲分配失敗 exit(OVERFLOW); (*L)->next = NULL; // 指针域為空 } void DestroyList(LinkList *L) { // 初始條件：線性表L已存在。操作结果：销毁線性表L LinkList q; while (*L) { q = (*L)->next; free(*L); *L = q; } } void ClearList(LinkList L) { // 不改变L // 初始条件：线性表L已存在。操作结果：将L重置为空表 LinkList p, q; p = L->next; // p指向第一个结点 while (p) { // 没到表尾 q = p->next; free(p); p = q; } L->next = NULL; // 头结点指针域为空 } Status ListEmpty(LinkList L) { // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE return L->next == NULL; } int ListLength(LinkList L) { // 初始条件：线性表L已存在。操作结果：返回L中数据元素个数 int i = 0; LinkList p = L->next; // p指向第一个结点 while (p) { // 没到表尾 i++; p = p->next; } return i; } Status GetElem(LinkList L, int i, ElemType *e) { // L为带头结点的单链表的头指针。当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR int j = 1; // j为计数器 LinkList p = L->next; // p指向第一个结点 while (p && j < i) { // 顺指针向后查找，直到p指向第i个元素或p为空 p = p->next; j++; } if (!p || j > i) // 第i个元素不存在 return ERROR; *e = p->data; // 取第i个元素 return OK; } int LocateElem(LinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) { // 初始条件: 线性表L已存在，compare()是数据元素判定函数(满足为1，否则为0) // 操作结果: 返回L中第1个与e满足关系compare()的数据元素的位序 // 若这样的数据元素不存在，则返回值为0 int i = 0; LinkList p = L->next; while (p) { i++; if (compare(p->data, e)) // 找到这样的数据元素 return i; p = p->next; } return 0; } Status PriorElem(LinkList L, ElemType cur_e, ElemType *pre_e) { // 初始条件: 线性表L已存在 // 操作结果: 若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， // 返回OK；否则操作失败，pre_e无定义，返回INFEASIBLE LinkList q, p = L->next; // p指向第一个结点 while (p->next) { // p所指结点有后继 q = p->next; // q为p的后继 if (q->data == cur_e) { *pre_e = p->data; return OK; } p = q; // p向后移 } return INFEASIBLE; } Status NextElem(LinkList L, ElemType cur_e, ElemType *next_e) { // 初始条件：线性表L已存在 // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继， // 返回OK;否则操作失败，next_e无定义，返回INFEASIBLE LinkList p = L->next; // p指向第一个结点 while (p->next) { // p所指结点有后继 if (p->data == cur_e) { *next_e = p->next->data; return OK; } p = p->next; } return INFEASIBLE; } Status ListInsert(LinkList L, int i, ElemType e) { // 算法2.9。不改变L // 在带头结点的单链线性表L中第i个位置之前插入元素e int j = 0; LinkList p = L, s; while (p && j < i - 1) { // 寻找第i-1个结点 p = p->next; j++; } if (!p || j > i - 1) // i小于1或者大于表长 return ERROR; s = (LinkList)malloc(sizeof(struct LNode)); // 生成新结点 s->data = e; // 插入L中 s->next = p->next; p->next = s; return OK; } Status ListDelete(LinkList L, int i, ElemType *e) { // 算法2.10。不改变L // 在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 int j = 0; LinkList p = L, q; while (p->next && j < i - 1) { // 寻找第i个结点，并令p指向其前驱结点 p = p->next; j++; } if (!p->next || j > i - 1) // 删除位置不合理 return ERROR; q = p->next; // 删除并释放结点 p->next = q->next; *e = q->data; free(q); return OK; } void ListTraverse(LinkList L, void(*vi)(ElemType)) { // vi的形参类型为ElemType，与bo2-1.c中相应函数的形参类型ElemType&不同 // 初始条件：线性表L已存在。操作结果：依次对L的每个数据元素调用函数vi() LinkList p = L->next; while (p) { vi(p->data); p = p->next; } printf("\n"); }",
            "assembleScratchTime":"2019-04-05 12:54:10",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870160,
            "assembleContent":"<h2><span id="静态单链表（C语言）">静态单链表（C语言）</span></h2><h2><p><br></p><pre><code><p>// 线性表的静态单链表存储结构<br>#define MAX_SIZE 100 // 链表的最大长度<br>typedef struct {<br>    ElemType data; //此處的ElemType可以自由代換（如int/float等）<br>    int cur;<br>} component, SLinkList[MAX_SIZE];<br><br>// 一个数组只生成一个静态链表的基本操作(11个)<br>#define DestroyList ClearList // DestroyList()和ClearList()的操作是一样的<br><br>void InitList(SLinkList L) {<br>    // 构造一个空的链表L，表头为L的最后一个单元L[MAX_SIZE-1]，其余单元链成<br>    // 一个备用链表，表头为L的第一个单元L[0]，“0”表示空指针<br>    int i;<br>    L[MAX_SIZE - 1].cur = 0; // L的最后一个单元为空链表的表头<br>    for (i = 0; i < MAX_SIZE - 2; i++) // 将其余单元链接成以L[0]为表头的备用链表<br>        L[i].cur = i + 1;<br>    L[MAX_SIZE - 2].cur = 0;<br>}<br><br>void ClearList(SLinkList L) {<br>    // 初始条件：线性表L已存在。操作结果：将L重置为空表<br>    int i, j, k;<br>    i = L[MAX_SIZE - 1].cur; // 链表第一个结点的位置<br>    L[MAX_SIZE - 1].cur = 0; // 链表空<br>    k = L[0].cur; // 备用链表第一个结点的位置<br>    L[0].cur = i; // 把链表的结点连到备用链表的表头<br>    while (i) { // 没到链表尾<br>        j = i;<br>        i = L[i].cur; // 指向下一个元素<br>    }<br>    L[j].cur = k; // 备用链表的第一个结点接到链表的尾部<br>}<br><br>Status ListEmpty(SLinkList L) {<br>    // 若L是空表，返回TRUE；否则返回FALSE<br>    if (L[MAX_SIZE - 1].cur == 0) // 若为空表<br>        return TRUE;<br>    else<br>        return FALSE;<br>}<br><br>int ListLength(SLinkList L) {<br>    // 返回L中数据元素个数<br>    int j = 0, i = L[MAX_SIZE - 1].cur; // i指向第一个元素<br>    while (i) { // 没到静态链表尾<br>        i = L[i].cur; // 指向下一个元素<br>        j++;<br>    }<br>    return j;<br>}<br><br>Status GetElem(SLinkList L, int i, ElemType *e) {<br>    // 用e返回L中第i个元素的值<br>    int l, k = MAX_SIZE - 1; // k指向表头序号<br>    if (i < 1 || i > ListLength(L))<br>        return ERROR;<br>    for (l = 1; l <= i; l++) // 移动到第i个元素处<br>        k = L[k].cur;<br>    *e = L[k].data;<br>    return OK;<br>}<br><br>int LocateElem(SLinkList L, ElemType e) { // 算法2.13(有改动)<br>    // 在静态单链线性表L中查找第1个值为e的元素。若找到，则返回它在L中的<br>    // 位序，否则返回0。(与其它LocateElem()的定义不同)<br>    int i = L[MAX_SIZE - 1].cur; // i指示表中第一个结点<br>    while (i && L[i].data != e) // 在表中顺链查找(e不能是字符串)<br>        i = L[i].cur;<br>    return i;<br>}<br><br>Status PriorElem(SLinkList L, ElemType cur_e, ElemType *pre_e) {<br>    // 初始条件：线性表L已存在<br>    // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，<br>    // 否则操作失败，pre_e无定义<br>    int j, i = L[MAX_SIZE - 1].cur; // i指示链表第一个结点的位置<br>    do { // 向后移动结点<br>        j = i;<br>        i = L[i].cur;<br>    } while (i && cur_e != L[i].data);<br>    if (i) { // 找到该元素<br>        *pre_e = L[j].data;<br>        return OK;<br>    }<br>    return ERROR;<br>}<br><br>Status NextElem(SLinkList L, ElemType cur_e, ElemType *next_e) {<br>    // 初始条件：线性表L已存在<br>    // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继<br>    // 否则操作失败，next_e无定义<br>    int j, i = LocateElem(L, cur_e); // 在L中查找第一个值为cur_e的元素的位置<br>    if (i) { // L中存在元素cur_e<br>        j = L[i].cur; // cur_e的后继的位置<br>        if (j) { // cur_e有后继<br>            *next_e = L[j].data;<br>            return OK; // cur_e元素有后继<br>        }<br>    }<br>    return ERROR; // L不存在cur_e元素，cur_e元素无后继<br>}<br><br>Status ListInsert(SLinkList L, int i, ElemType e) {<br>    // 在L中第i个元素之前插入新的数据元素e<br>    int l, j, k = MAX_SIZE - 1; // k指向表头<br>    if (i < 1 || i > ListLength(L) + 1)<br>        return ERROR;<br>    j = Malloc(L); // 申请新单元<br>    if (j) { // 申请成功<br>        L[j].data = e; // 赋值给新单元<br>        for (l = 1; l < i; l++) // 移动i-1个元素<br>            k = L[k].cur;<br>        L[j].cur = L[k].cur;<br>        L[k].cur = j;<br>        return OK;<br>    }<br>    return ERROR;<br>}<br><br>Status ListDelete(SLinkList L, int i, ElemType *e) {<br>    // 删除在L中第i个数据元素e，并返回其值<br>    int j, k = MAX_SIZE - 1; // k指向表头<br>    if (i < 1 || i > ListLength(L))<br>        return ERROR;<br>    for (j = 1; j < i; j++) // 移动i-1个元素<br>        k = L[k].cur;<br>    j = L[k].cur;<br>    L[k].cur = L[j].cur;<br>    *e = L[j].data;<br>    Free(L, j);<br>    return OK;<br>}<br><br>void ListTraverse(SLinkList L, void(*vi)(ElemType)) {<br>    // 初始条件：线性表L已存在。操作结果：依次对L的每个数据元素调用函数vi()<br>    int i = L[MAX_SIZE - 1].cur; // 指向第一个元素<br>    while (i) { // 没到静态链表尾<br>        vi(L[i].data); // 调用vi()<br>        i = L[i].cur; // 指向下一个元素<br>    }<br>    printf("\n");<br>}</p></code></pre></h2> ",
            "assembleText":"静态单链表（C语言） // 线性表的静态单链表存储结构 #define MAX_SIZE 100 // 链表的最大长度 typedef struct { ElemType data; //此處的ElemType可以自由代換（如int/float等） int cur; } component, SLinkList[MAX_SIZE]; // 一个数组只生成一个静态链表的基本操作(11个) #define DestroyList ClearList // DestroyList()和ClearList()的操作是一样的 void InitList(SLinkList L) { // 构造一个空的链表L，表头为L的最后一个单元L[MAX_SIZE-1]，其余单元链成 // 一个备用链表，表头为L的第一个单元L[0]，“0”表示空指针 int i; L[MAX_SIZE - 1].cur = 0; // L的最后一个单元为空链表的表头 for (i = 0; i < MAX_SIZE - 2; i++) // 将其余单元链接成以L[0]为表头的备用链表 L[i].cur = i + 1; L[MAX_SIZE - 2].cur = 0; } void ClearList(SLinkList L) { // 初始条件：线性表L已存在。操作结果：将L重置为空表 int i, j, k; i = L[MAX_SIZE - 1].cur; // 链表第一个结点的位置 L[MAX_SIZE - 1].cur = 0; // 链表空 k = L[0].cur; // 备用链表第一个结点的位置 L[0].cur = i; // 把链表的结点连到备用链表的表头 while (i) { // 没到链表尾 j = i; i = L[i].cur; // 指向下一个元素 } L[j].cur = k; // 备用链表的第一个结点接到链表的尾部 } Status ListEmpty(SLinkList L) { // 若L是空表，返回TRUE；否则返回FALSE if (L[MAX_SIZE - 1].cur == 0) // 若为空表 return TRUE; else return FALSE; } int ListLength(SLinkList L) { // 返回L中数据元素个数 int j = 0, i = L[MAX_SIZE - 1].cur; // i指向第一个元素 while (i) { // 没到静态链表尾 i = L[i].cur; // 指向下一个元素 j++; } return j; } Status GetElem(SLinkList L, int i, ElemType *e) { // 用e返回L中第i个元素的值 int l, k = MAX_SIZE - 1; // k指向表头序号 if (i < 1 || i > ListLength(L)) return ERROR; for (l = 1; l <= i; l++) // 移动到第i个元素处 k = L[k].cur; *e = L[k].data; return OK; } int LocateElem(SLinkList L, ElemType e) { // 算法2.13(有改动) // 在静态单链线性表L中查找第1个值为e的元素。若找到，则返回它在L中的 // 位序，否则返回0。(与其它LocateElem()的定义不同) int i = L[MAX_SIZE - 1].cur; // i指示表中第一个结点 while (i && L[i].data != e) // 在表中顺链查找(e不能是字符串) i = L[i].cur; return i; } Status PriorElem(SLinkList L, ElemType cur_e, ElemType *pre_e) { // 初始条件：线性表L已存在 // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， // 否则操作失败，pre_e无定义 int j, i = L[MAX_SIZE - 1].cur; // i指示链表第一个结点的位置 do { // 向后移动结点 j = i; i = L[i].cur; } while (i && cur_e != L[i].data); if (i) { // 找到该元素 *pre_e = L[j].data; return OK; } return ERROR; } Status NextElem(SLinkList L, ElemType cur_e, ElemType *next_e) { // 初始条件：线性表L已存在 // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继 // 否则操作失败，next_e无定义 int j, i = LocateElem(L, cur_e); // 在L中查找第一个值为cur_e的元素的位置 if (i) { // L中存在元素cur_e j = L[i].cur; // cur_e的后继的位置 if (j) { // cur_e有后继 *next_e = L[j].data; return OK; // cur_e元素有后继 } } return ERROR; // L不存在cur_e元素，cur_e元素无后继 } Status ListInsert(SLinkList L, int i, ElemType e) { // 在L中第i个元素之前插入新的数据元素e int l, j, k = MAX_SIZE - 1; // k指向表头 if (i < 1 || i > ListLength(L) + 1) return ERROR; j = Malloc(L); // 申请新单元 if (j) { // 申请成功 L[j].data = e; // 赋值给新单元 for (l = 1; l < i; l++) // 移动i-1个元素 k = L[k].cur; L[j].cur = L[k].cur; L[k].cur = j; return OK; } return ERROR; } Status ListDelete(SLinkList L, int i, ElemType *e) { // 删除在L中第i个数据元素e，并返回其值 int j, k = MAX_SIZE - 1; // k指向表头 if (i < 1 || i > ListLength(L)) return ERROR; for (j = 1; j < i; j++) // 移动i-1个元素 k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; *e = L[j].data; Free(L, j); return OK; } void ListTraverse(SLinkList L, void(*vi)(ElemType)) { // 初始条件：线性表L已存在。操作结果：依次对L的每个数据元素调用函数vi() int i = L[MAX_SIZE - 1].cur; // 指向第一个元素 while (i) { // 没到静态链表尾 vi(L[i].data); // 调用vi() i = L[i].cur; // 指向下一个元素 } printf("\n"); }",
            "assembleScratchTime":"2019-04-05 12:54:29",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870171,
            "assembleContent":"<h2><span style="font-size: medium;">一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。  </span></h2> ",
            "assembleText":"一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。  ",
            "assembleScratchTime":"2019-04-05 12:58:57",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870173,
            "assembleContent":"<h2><span style="font-size: medium;">相对于下面的双向链表，这种普通的，每个节点只有一个指针的链表也叫<b>单向链表</b>，或者<b>单链表</b>，通常用在每次都只会按顺序遍历这个链表的时候（例如图的邻接表，通常都是按固定顺序访问的）。  </span></h2> ",
            "assembleText":"相对于下面的双向链表，这种普通的，每个节点只有一个指针的链表也叫单向链表，或者单链表，通常用在每次都只会按顺序遍历这个链表的时候（例如图的邻接表，通常都是按固定顺序访问的）。  ",
            "assembleScratchTime":"2019-04-05 12:59:38",
            "facetId":556329,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870187,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表</span></p><pre></pre><p><span style="font-size: medium;">使用任意存储单元来存储线性表中的数据元素，节点类型如上。</span></p><pre></pre><p><span style="font-size: medium;">单链表分为带头结点和不带头结点两种，不管有没有头结点，头指针都指向链表的第一个节点（有头结点指向头结点）。</span></p><pre></pre><p><span style="font-size: medium;">头结点：数值域可不设任何信息，头结点的指针域指向链表的第一个元素。</span></p><pre></pre><p><span style="font-size: medium;">带头节点的好处有：</span></p><pre></pre><p><span style="font-size: medium;">（1）链表第一位置节点上的操作和其它位置上的操作一致</span></p><pre></pre><p><span style="font-size: medium;">（2）无论链表是否为空，头指针都指向头结点（非空），空表和非空表处理一样</span></p><pre></pre><p><span style="font-size: medium;">（这里我没有使用头结点）</span></p><pre></pre><p><span style="font-size: medium;">注：链表麻烦的地方是插入和删除时指针的修改，保证不断链，一般先断后链。</span></p><pre></pre><p><span style="font-size: medium;"><img src="https://images2015.cnblogs.com/blog/941605/201605/941605-20160511074219984-621617430.png" alt=""></span></p></h1> ",
            "assembleText":"单链表 使用任意存储单元来存储线性表中的数据元素，节点类型如上。 单链表分为带头结点和不带头结点两种，不管有没有头结点，头指针都指向链表的第一个节点（有头结点指向头结点）。 头结点：数值域可不设任何信息，头结点的指针域指向链表的第一个元素。 带头节点的好处有： （1）链表第一位置节点上的操作和其它位置上的操作一致 （2）无论链表是否为空，头指针都指向头结点（非空），空表和非空表处理一样 （这里我没有使用头结点） 注：链表麻烦的地方是插入和删除时指针的修改，保证不断链，一般先断后链。",
            "assembleScratchTime":"2019-04-05 13:04:22",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870188,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">1. 头插法</span></p><pre></pre><p><span style="font-size: medium;">将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图：</span></p><pre></pre><p><span style="font-size: medium;"><img src="https://images2015.cnblogs.com/blog/941605/201605/941605-20160511074306015-588143690.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
public void headInsert(T item) {
    Node old = first;
    first = new Node();
    first.item = item;
    first.next = old;
    count++;
}</span></pre></h1> ",
            "assembleText":"基本操作 1. 头插法 将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图： 核心代码：
public void headInsert(T item) {
    Node old = first;
    first = new Node();
    first.item = item;
    first.next = old;
    count++;
}",
            "assembleScratchTime":"2019-04-05 13:04:44",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870191,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">2. 尾插法</span></p><pre></pre><p><span style="font-size: medium;">增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图：</span></p><pre></pre><p><span style="font-size: medium;"><img src="https://images2015.cnblogs.com/blog/941605/201605/941605-20160511074357343-1701380488.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
public void tailInsert(T item) {
    Node old = last;
    last = new Node();
    last.item = item;
    last.next = null;
    if (isEmpty()) {
        first = last;
    } else {
        old.next = last;
    }
    count++;
}</span></pre><pre></pre><p><span style="font-size: medium;">节点的插入和删除，要点是<strong>先断后连</strong>，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。</span></p></h1> ",
            "assembleText":"基本操作 2. 尾插法 增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图： 核心代码：
public void tailInsert(T item) {
    Node old = last;
    last = new Node();
    last.item = item;
    last.next = null;
    if (isEmpty()) {
        first = last;
    } else {
        old.next = last;
    }
    count++;
} 节点的插入和删除，要点是先断后连，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。",
            "assembleScratchTime":"2019-04-05 13:05:21",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870192,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">3. 插入节点</span></p><pre></pre><p><span style="font-size: medium;">待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115G030-6.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码为：
p=getNodeByIndex(i-1);
s.next = p.next;
p.next = s;</span></pre><pre></pre><p><span style="font-size: medium;">还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)：</span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
s.next = p.next;
p.next = s;
temp = p.item;    // 交换内容
p.item = s.item;
s.item = temp;</span></pre></h1> ",
            "assembleText":"基本操作 3. 插入节点 待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。 核心代码为：
p=getNodeByIndex(i-1);
s.next = p.next;
p.next = s; 还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)： 核心代码：
s.next = p.next;
p.next = s;
temp = p.item;    // 交换内容
p.item = s.item;
s.item = temp;",
            "assembleScratchTime":"2019-04-05 13:05:40",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870202,
            "assembleContent":"<h1><p><span style="font-size: medium;">为了表示每个数据元素a与其直接后继数据元素之间的逻辑关系，对数据元素a来说，除了存储其本身的信息之外，还需存储一个指示其后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a的存储映像，称为结点。</span></p><p><span style="font-size: medium;">　　　　n个结点（a的存储映像）链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表</span></p><p><span style="font-size: medium;"> <img src="https://images2018.cnblogs.com/blog/1206298/201803/1206298-20180326133349561-899741460.png" alt=""></span></p></h1> ",
            "assembleText":"为了表示每个数据元素a与其直接后继数据元素之间的逻辑关系，对数据元素a来说，除了存储其本身的信息之外，还需存储一个指示其后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a的存储映像，称为结点。 　　　　n个结点（a的存储映像）链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表  ",
            "assembleScratchTime":"2019-04-05 13:08:37",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870204,
            "assembleContent":"<h1><p><span style="font-size: medium;">把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。</span></p><p><span style="font-size: medium;"><img src="https://images2018.cnblogs.com/blog/1206298/201803/1206298-20180326133522100-1928731505.png" alt=""></span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">　　有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</span></p></h1> ",
            "assembleText":"把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。   　　有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。",
            "assembleScratchTime":"2019-04-05 13:09:18",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870207,
            "assembleContent":"<h1><p><span style="font-size: medium;">代码实现</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//单链表存储结构</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  typedef struct LNode</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">      ElemType data;   //数据域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">      struct LNode *next; //指针域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  }LNode,*LinkList;</span></div></div></li></ol></code></pre><p><span style="font-size: medium;">为了提高程序的可阅读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode*,本质上两者是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针，用LNode *定义指向单链表中任意结点的指针变量。</span></p></h1> ",
            "assembleText":"代码实现 //单链表存储结构 typedef struct LNode { ElemType data; //数据域 struct LNode *next; //指针域 }LNode,*LinkList; 为了提高程序的可阅读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode*,本质上两者是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针，用LNode *定义指向单链表中任意结点的指针变量。",
            "assembleScratchTime":"2019-04-05 13:10:09",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870210,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">1.初始化</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//初始化 </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> Status InitList(LinkList &L)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     //构造一个单链表</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     L=new LNode;  //生成头结点，用头指针L指向头结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     L->next =NULL;  </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     return OK;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 1.初始化 基本算法： //初始化 Status InitList(LinkList &L) { //构造一个单链表 L=new LNode; //生成头结点，用头指针L指向头结点 L->next =NULL; return OK; }",
            "assembleScratchTime":"2019-04-05 13:10:46",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870211,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">2.取值</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//取值</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> Status Get(LinkList L,int i,ElemType &e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    //在带头结点的单链表L中根据序号I获取元素的值，用e返回L中第i个数据元素的值</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p=L->next;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    j=1;//计数器</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    while(p&&j<i)     //顺着链表向后扫描，直到j==i</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        p=p->next;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        ++j;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    if(!p||j>i) return ERROR; //不合法</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    e=p->data;   //找到该结点后获取该结点的数据域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    return OK;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 2.取值 基本算法： //取值 Status Get(LinkList L,int i,ElemType &e) { //在带头结点的单链表L中根据序号I获取元素的值，用e返回L中第i个数据元素的值 p=L->next; j=1;//计数器 while(p&&j<i) //顺着链表向后扫描，直到j==i { p=p->next; ++j; } if(!p||j>i) return ERROR; //不合法 e=p->data; //找到该结点后获取该结点的数据域 return OK; }",
            "assembleScratchTime":"2019-04-05 13:11:08",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870214,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">3.查找</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//查找</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> LNode *Find(LinkList L,ElemType e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     p=L->next; //使p指向首元结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     while(p && p->data!=e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">         p=p->next;  //不符合条件就一直滚下去</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     return p;   //这里有两种情况，找到的时候返回指针p，如果找不到那么这个p则为null,因为最后一个指向的是null</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 3.查找 基本算法： //查找 LNode *Find(LinkList L,ElemType e) { p=L->next; //使p指向首元结点 while(p && p->data!=e) { p=p->next; //不符合条件就一直滚下去 } return p; //这里有两种情况，找到的时候返回指针p，如果找不到那么这个p则为null,因为最后一个指向的是null }",
            "assembleScratchTime":"2019-04-05 13:12:07",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870215,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">插入</span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//插入</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">Status ListInsert(LinkList &L,int i,ElemType e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">{</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    //在带头结点的单链表L中第i个位置插入值为e的新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p=L;j=0;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    while(p&&(j<i-1))</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        p=p->next;         //查找第i-1个结点，p指向该结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        ++j;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    if(!p||j>i-1) return ERROR;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s=new LNode;   //生成一个新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->data=e;   //将结点*s的数据域置为e</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->next=p->next; //先接尾部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p->next=s;  //再接头部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">}</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 插入   基本算法： //插入 Status ListInsert(LinkList &L,int i,ElemType e) { //在带头结点的单链表L中第i个位置插入值为e的新结点 p=L;j=0; while(p&&(j<i-1)) { p=p->next; //查找第i-1个结点，p指向该结点 ++j; } if(!p||j>i-1) return ERROR; s=new LNode; //生成一个新结点 s->data=e; //将结点*s的数据域置为e s->next=p->next; //先接尾部 p->next=s; //再接头部 }",
            "assembleScratchTime":"2019-04-05 13:12:22",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870220,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">删除</span></p><p> </p><p>基本算法：</p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>//删除</div></div></li><li><div><div></div></div><div><div>Status ListDelete(LinkList &L,int i)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    //删除第i个元素</div></div></li><li><div><div></div></div><div><div>    p=L;j=0;</div></div></li><li><div><div></div></div><div><div>    while((p->next)&&(j<i-1))</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        p=p->next;    //查找i-1个结点</div></div></li><li><div><div></div></div><div><div>        ++j;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div>    if(!(p->next)||(j>i-1)) return ERROR;  //当i>n或i<1时，不符合条件</div></div></li><li><div><div></div></div><div><div>    q=p->next;   //临时保存被删除的地址</div></div></li><li><div><div></div></div><div><div>    p->next=q->next;  //将前驱结点指向后驱</div></div></li><li><div><div></div></div><div><div>    delete q;  //释放删除结点的空间</div></div></li><li><div><div></div></div><div><div>    return OK;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre></h1>  ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 删除   基本算法： //删除 Status ListDelete(LinkList &L,int i) { //删除第i个元素 p=L;j=0; while((p->next)&&(j<i-1)) { p=p->next; //查找i-1个结点 ++j; } if(!(p->next)||(j>i-1)) return ERROR; //当i>n或i<1时，不符合条件 q=p->next; //临时保存被删除的地址 p->next=q->next; //将前驱结点指向后驱 delete q; //释放删除结点的空间 return OK; }",
            "assembleScratchTime":"2019-04-05 13:13:16",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870221,
            "assembleContent":"<h1><p><span style="font-size: medium;">其实单链表可以想象成一列人在玩游戏，每个人都把手搭到后面那个人的肩膀上，每个人身上都有一个大口袋用来放数据，最后一个人没人可以搭就一直悬空着，第一个带头领队的就不用口袋了，它是一个头结点，是用来找到第一个有口袋的人的，也就是首元结点。</span></p><p><span style="font-size: medium;">  这样想的话就简单了，初始化的时候就是用一个人当头结点，它没有口袋，他的手是用来搭到第一个有口袋的人肩膀的，因为这个人还没来，所以它的next是Null，而取值时，通过参数i，我们就可以从首元结点开始数，数到第i个人，找到他后，就可以拿他口袋里面的东西，查找是知道口袋里面东西是什么，想找到这个东西的拥有者，也是一样从首元结点开始找。遍历下去，插入的话，比如要插入第i个位置，那么我们就先找到第i-1个人，然后让新来的手搭到第i个人身上，然后再让第i-1个人把之前放在第i个人的手挪开，放在新来的人的肩膀上，删除操作的话，例如删除第i个人，那么也是先找到第i-1个人，这里的重点是，因为链表的查询只能是从头开始找的，是不能逆回去的，所以我们需要找个变量把要删的那个人的地址先存起来，然后把第i-1个的手放到第i+1个人身上，如果我们不找个变量把那个人的地址存起来，这时候我们就没办法找到他了，因为我们用一个变量临时保存他的地址，于是我们只需要释放这个地址的空间就可以了。<img src="http://yotta.xjtushilei.com:8090/1554183429079/1522578597.png"></span></p></h1>  ",
            "assembleText":"其实单链表可以想象成一列人在玩游戏，每个人都把手搭到后面那个人的肩膀上，每个人身上都有一个大口袋用来放数据，最后一个人没人可以搭就一直悬空着，第一个带头领队的就不用口袋了，它是一个头结点，是用来找到第一个有口袋的人的，也就是首元结点。   这样想的话就简单了，初始化的时候就是用一个人当头结点，它没有口袋，他的手是用来搭到第一个有口袋的人肩膀的，因为这个人还没来，所以它的next是Null，而取值时，通过参数i，我们就可以从首元结点开始数，数到第i个人，找到他后，就可以拿他口袋里面的东西，查找是知道口袋里面东西是什么，想找到这个东西的拥有者，也是一样从首元结点开始找。遍历下去，插入的话，比如要插入第i个位置，那么我们就先找到第i-1个人，然后让新来的手搭到第i个人身上，然后再让第i-1个人把之前放在第i个人的手挪开，放在新来的人的肩膀上，删除操作的话，例如删除第i个人，那么也是先找到第i-1个人，这里的重点是，因为链表的查询只能是从头开始找的，是不能逆回去的，所以我们需要找个变量把要删的那个人的地址先存起来，然后把第i-1个的手放到第i+1个人身上，如果我们不找个变量把那个人的地址存起来，这时候我们就没办法找到他了，因为我们用一个变量临时保存他的地址，于是我们只需要释放这个地址的空间就可以了。",
            "assembleScratchTime":"2019-04-05 13:13:33",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870222,
            "assembleContent":"<h1><p>创建单链表  <br></p><pre><code>//前插法创建单链表<br> void CreateList(LinkList &L,int n)<br> {<br>     //逆次序输出n个元素的值<br>     L=new LNode;<br>     L->next=NULL;<br>     for(i=0;i<n;++i)<br>     {<br>         p=new LNode;  //生成新结点<br>         cin>>p->data;  //输入新结点的数据域内容<br>         p->next=L->next; //将新结点插到头结点之后<br>         L->next=p;<br>     }<br> }</code></pre></h1><h1><p><br></p></h1>  ",
            "assembleText":"创建单链表   //前插法创建单链表  void CreateList(LinkList &L,int n)  {      //逆次序输出n个元素的值      L=new LNode;      L->next=NULL;      for(i=0;i<n;++i)      {          p=new LNode;  //生成新结点          cin>>p->data;  //输入新结点的数据域内容          p->next=L->next; //将新结点插到头结点之后          L->next=p;      }  }",
            "assembleScratchTime":"2019-04-05 13:13:46",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870225,
            "assembleContent":"<h1><p>单链表</p><pre><code>//后插法<br> void CreateList(LinkList &L,int n)<br> {<br>     //正次序输入n个元素的值<br>     L=new LNode;<br>     L->next=NULL;  //建立一个带头结点的空链表<br>     r=L;   //尾指针r指向头结点<br>     for(i=0;i<n;++i)<br>     {<br>         p=new LNode; //生成新结点<br>         cin>>p->data; //输入新结点的数据域内容<br>         p->next=NULL;<br>         r->next=p;  //将新结点插入尾结点之后<br>         r=p;   //改变尾指针，使其指向新的尾结点<br>     }<br> }</code></pre><p><br></p></h1>  ",
            "assembleText":"单链表 //后插法  void CreateList(LinkList &L,int n)  {      //正次序输入n个元素的值      L=new LNode;      L->next=NULL;  //建立一个带头结点的空链表      r=L;   //尾指针r指向头结点      for(i=0;i<n;++i)      {          p=new LNode; //生成新结点          cin>>p->data; //输入新结点的数据域内容          p->next=NULL;          r->next=p;  //将新结点插入尾结点之后          r=p;   //改变尾指针，使其指向新的尾结点      }  }",
            "assembleScratchTime":"2019-04-05 13:14:07",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870226,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表头插法和尾插法</span></p><p><span style="font-size: medium;">两种方式的结果是一样的，区别就是前插法是把新的元素插到最前面，代替了首元结点的位置，就是明摆的插队，而后插法是插到最后面，有点类似于队列。而且后插法多了一个用来指向尾结点的尾指针。  </span></p></h1>  ",
            "assembleText":"单链表头插法和尾插法 两种方式的结果是一样的，区别就是前插法是把新的元素插到最前面，代替了首元结点的位置，就是明摆的插队，而后插法是插到最后面，有点类似于队列。而且后插法多了一个用来指向尾结点的尾指针。  ",
            "assembleScratchTime":"2019-04-05 13:14:20",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870274,
            "assembleContent":"<h1><div id="cnblogs_post_body"><p><span style="font-size: medium;">对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。    </span><br></p></div></h1> ",
            "assembleText":"对于插入和删除数据越频繁的操作，单链表的效率优势就越明显。    ",
            "assembleScratchTime":"2019-04-05 13:38:07",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870280,
            "assembleContent":"<p>单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。单链表的节点结构为如下所示：</p><p><img src="https://img-blog.csdn.net/2018032510145179?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Rvbmd4dWV4aWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p> ",
            "assembleText":"单链表是一种链式存取的数据结构，用一组任意地址空间（地址空间即存储单元）来存放线性表的数据元素。单链表中的数据是以节点的形式来表示，而节点是用结构体来描述，每个节点都是由元素和指针构成，即该结构体中包含两个成员变量：存放元素的成员变量和存放下一个节点地址的成员变量。单链表的节点结构为如下所示：",
            "assembleScratchTime":"2019-04-05 13:40:55",
            "facetId":556329,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870443,
            "assembleContent":"<h3><span id="Singly_linked_list">Singly linked list</span></h3><h2><p><span style="font-size: medium;">Singly linked lists contain nodes which have a data field as well as 'next' field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion and traversal.</span></p><div><a href="https://en.wikipedia.org/wiki/File:Singly-linked-list.svg"><img alt="Singly-linked-list.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/408px-Singly-linked-list.svg.png" decoding="async" width="408" height="41" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/612px-Singly-linked-list.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Singly-linked-list.svg/816px-Singly-linked-list.svg.png 2x"></a><br><small><i>A singly linked list whose nodes contain two fields: an integer value and a link to the next node</i></small></div></h2> ",
            "assembleText":"Singly linked list Singly linked lists contain nodes which have a data field as well as 'next' field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion and traversal. A singly linked list whose nodes contain two fields: an integer value and a link to the next node",
            "assembleScratchTime":"2019-04-05 14:21:36",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870445,
            "assembleContent":"<h3><p>The following code demonstrates how to add a new node with data "value" to the end of a singly linked list:</p><div dir="ltr"><pre>node addNode(node head, int value){
   node temp,p;// declare two nodes temp and p
   temp = createNode();// assume createNode creates a new node with data = 0 and next pointing to NULL.
   temp->data = value; // add element's value to data part of node
   if(head == NULL){
       head = temp;     //when linked list is empty
   }
   else{
       p  = head;//assign head to p 
       while(p->next != NULL){
           p = p->next;//traverse the list until p is the last node.The last node always points to NULL.
       }
       p->next = temp;//Point the previous last node to the new node created.
   }
   return head;

}</pre></div></h3> ",
            "assembleText":"The following code demonstrates how to add a new node with data "value" to the end of a singly linked list: node addNode(node head, int value){
   node temp,p;// declare two nodes temp and p
   temp = createNode();// assume createNode creates a new node with data = 0 and next pointing to NULL.
   temp->data = value; // add element's value to data part of node
   if(head == NULL){
       head = temp;     //when linked list is empty
   }
   else{
       p  = head;//assign head to p 
       while(p->next != NULL){
           p = p->next;//traverse the list until p is the last node.The last node always points to NULL.
       }
       p->next = temp;//Point the previous last node to the new node created.
   }
   return head;

}",
            "assembleScratchTime":"2019-04-05 14:21:50",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870472,
            "assembleContent":"<h4><span id="Singly_linked_lists">Singly linked lists</span></h4><div>Our node data structure will have two fields. We also keep a variable <i>firstNode</i> which always points to the first node in the list, or is <i>null</i> for an empty list.  <span><br></span></div><pre><b>record</b> <i>Node</i>
 {
    data; <i>// The data being stored in the node</i>
    <i>Node</i> next <i>// A <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" title="Reference (computer science)">reference</a> to the next node, null for last node</i>
 }</pre><pre> <b>record</b> <i>List</i>
 {
     <i>Node</i> firstNode <i>// points to first node of list; null for empty list</i>
 }</pre><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Singly linked lists Our node data structure will have two fields. We also keep a variable firstNode which always points to the first node in the list, or is null for an empty list.   record Node
 {
    data; // The data being stored in the node
    Node next // A reference to the next node, null for last node
 }  record List
 {
     Node firstNode // points to first node of list; null for empty list
 }",
            "assembleScratchTime":"2019-04-05 14:28:33",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870473,
            "assembleContent":"<h4><span id="Singly_linked_lists">Singly linked lists</span></h4><div>Our node data structure will have two fields. We also keep a variable <i>firstNode</i> which always points to the first node in the list, or is <i>null</i> for an empty list.  </div><p>Traversal of a singly linked list is simple, beginning at the first node and following each <i>next</i> link until we come to the end:</p><pre> node := list.firstNode
 <b>while</b> node not null
     <i>(do something with node.data)</i>
     node := node.next
</pre><p>The following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done directly; instead, one must keep track of the previous node and insert a node after it.</p><div><div><a href="https://en.wikipedia.org/wiki/File:CPT-LinkedLists-addingnode.svg"><img alt="CPT-LinkedLists-addingnode.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/CPT-LinkedLists-addingnode.svg/474px-CPT-LinkedLists-addingnode.svg.png" decoding="async" width="474" height="116" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/4b/CPT-LinkedLists-addingnode.svg/711px-CPT-LinkedLists-addingnode.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/4b/CPT-LinkedLists-addingnode.svg/948px-CPT-LinkedLists-addingnode.svg.png 2x"></a></div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Singly linked lists Our node data structure will have two fields. We also keep a variable firstNode which always points to the first node in the list, or is null for an empty list.   Traversal of a singly linked list is simple, beginning at the first node and following each next link until we come to the end:  node := list.firstNode
 while node not null
     (do something with node.data)
     node := node.next
 The following code inserts a node after an existing node in a singly linked list. The diagram shows how it works. Inserting a node before an existing one cannot be done directly; instead, one must keep track of the previous node and insert a node after it.",
            "assembleScratchTime":"2019-04-05 14:28:58",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870474,
            "assembleContent":"<h4><span id="Singly_linked_lists">Singly linked lists</span></h4><div><pre><b>function</b> insertAfter(<i>Node</i> node, <i>Node</i> newNode) <i>// insert newNode after node</i>
     newNode.next := node.next
     node.next    := newNode
</pre><p>Inserting at the beginning of the list requires a separate function. This requires updating <i>firstNode</i>.</p><pre> <b>function</b> insertBeginning(<i>List</i> list, <i>Node</i> newNode) <i>// insert node before current first node</i>
     newNode.next   := list.firstNode
     list.firstNode := newNode
</pre><p>Similarly, we have functions for removing the node <i>after</i> a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.</p><div><div><a href="https://en.wikipedia.org/wiki/File:CPT-LinkedLists-deletingnode.svg"><img alt="CPT-LinkedLists-deletingnode.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/CPT-LinkedLists-deletingnode.svg/380px-CPT-LinkedLists-deletingnode.svg.png" decoding="async" width="380" height="174" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/d4/CPT-LinkedLists-deletingnode.svg/570px-CPT-LinkedLists-deletingnode.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/d4/CPT-LinkedLists-deletingnode.svg/760px-CPT-LinkedLists-deletingnode.svg.png 2x"></a></div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Singly linked lists function insertAfter(Node node, Node newNode) // insert newNode after node
     newNode.next := node.next
     node.next    := newNode
 Inserting at the beginning of the list requires a separate function. This requires updating firstNode.  function insertBeginning(List list, Node newNode) // insert node before current first node
     newNode.next   := list.firstNode
     list.firstNode := newNode
 Similarly, we have functions for removing the node after a given node, and for removing a node from the beginning of the list. The diagram demonstrates the former. To find and remove a particular node, one must again keep track of the previous element.",
            "assembleScratchTime":"2019-04-05 14:29:16",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870475,
            "assembleContent":"<h4><span id="Singly_linked_lists">Singly linked lists</span></h4><div><pre><b>function</b> removeAfter(<i>Node</i> node) <i>// remove node past this one</i>
     obsoleteNode := node.next
     node.next := node.next.next
     destroy obsoleteNode
</pre><pre> <b>function</b> removeBeginning(<i>List</i> list) <i>// remove first node</i>
     obsoleteNode := list.firstNode
     list.firstNode := list.firstNode.next <i>// point past deleted node</i>
     destroy obsoleteNode
</pre><p>Notice that <code>removeBeginning()</code> sets <code>list.firstNode</code> to <code>null</code> when removing the last node in the list.</p><p>Since we can't iterate backwards, efficient <code>insertBefore</code> or <code>removeBefore</code> operations are not possible. Inserting to a list before a specific node requires traversing the list, which would have a worst case running time of O(n).</p><p>Appending one linked list to another can be inefficient unless a reference to the tail is kept as part of the List structure, because we must traverse the entire first list in order to find the tail, and then append the second list to this. Thus, if two linearly linked lists are each of length <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n}"><semantics><annotation encoding="application/x-tex">{\displaystyle n}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n">, list appending has <a href="https://en.wikipedia.org/wiki/Asymptotic_time_complexity" title="Asymptotic time complexity">asymptotic time complexity</a> of <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle O(n)}"><semantics><annotation encoding="application/x-tex">{\displaystyle O(n)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34109fe397fdcff370079185bfdb65826cb5565a" aria-hidden="true" alt="O(n)">. In the Lisp family of languages, list appending is provided by the <code><a href="https://en.wikipedia.org/wiki/Append" title="Append">append</a></code> procedure.</p><p>Many of the special cases of linked list operations can be eliminated by including a dummy element at the front of the list. This ensures that there are no special cases for the beginning of the list and renders both <code>insertBeginning()</code> and <code>removeBeginning()</code> unnecessary. In this case, the first useful data in the list will be found at <code>list.<b>firstNode</b>.next</code>.</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Singly linked lists function removeAfter(Node node) // remove node past this one
     obsoleteNode := node.next
     node.next := node.next.next
     destroy obsoleteNode
  function removeBeginning(List list) // remove first node
     obsoleteNode := list.firstNode
     list.firstNode := list.firstNode.next // point past deleted node
     destroy obsoleteNode
 Notice that removeBeginning() sets list.firstNode to null when removing the last node in the list. Since we can't iterate backwards, efficient insertBefore or removeBefore operations are not possible. Inserting to a list before a specific node requires traversing the list, which would have a worst case running time of O(n). Appending one linked list to another can be inefficient unless a reference to the tail is kept as part of the List structure, because we must traverse the entire first list in order to find the tail, and then append the second list to this. Thus, if two linearly linked lists are each of length  {\displaystyle n}, list appending has asymptotic time complexity of  {\displaystyle O(n)}. In the Lisp family of languages, list appending is provided by the append procedure. Many of the special cases of linked list operations can be eliminated by including a dummy element at the front of the list. This ensures that there are no special cases for the beginning of the list and renders both insertBeginning() and removeBeginning() unnecessary. In this case, the first useful data in the list will be found at list.firstNode.next.",
            "assembleScratchTime":"2019-04-05 14:29:37",
            "facetId":556329,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870930,
            "assembleContent":"<div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h3><strong>单向链表</strong></h3><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。</p><p>单链表的示意图如下：<br><a href="https://images0.cnblogs.com/blog/497634/201402/231244591436996.jpg"><img src="https://images0.cnblogs.com/blog/497634/201402/231244591436996.jpg" alt=""></a></p><p>表头为空，表头的后继节点是"节点10"(数据为10的节点)，"节点10"的后继节点是"节点20"(数据为10的节点)，...</p></div><div></div></div><div></div></div><div></div></div><div></div> ",
            "assembleText":"单向链表 单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 表头为空，表头的后继节点是"节点10"(数据为10的节点)，"节点10"的后继节点是"节点20"(数据为10的节点)，...",
            "assembleScratchTime":"2019-04-06 21:31:39",
            "facetId":556329,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/skywang12345/p/3561803.html#a31",
            "type":"text"
        },
        {
            "assembleId":2870931,
            "assembleContent":"<div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h3><p><strong>单链表删除节点</strong></p><p><a href="https://images0.cnblogs.com/blog/497634/201402/231246130639479.jpg"><img src="https://images0.cnblogs.com/blog/497634/201402/231246130639479.jpg" alt=""></a></p><p>删除"节点30"<br><strong>删除之前</strong>："节点20" 的后继节点为"节点30"，而"节点30" 的后继节点为"节点40"。<br><strong>删除之后</strong>："节点20" 的后继节点为"节点40"。</p><p> </p></h3></div><div></div></div><div></div></div><div></div></div><div></div> ",
            "assembleText":"单链表删除节点 删除"节点30" 删除之前："节点20" 的后继节点为"节点30"，而"节点30" 的后继节点为"节点40"。 删除之后："节点20" 的后继节点为"节点40"。  ",
            "assembleScratchTime":"2019-04-06 21:31:44",
            "facetId":556329,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/skywang12345/p/3561803.html#a31",
            "type":"text"
        },
        {
            "assembleId":2870932,
            "assembleContent":"<div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h3><p><strong>单链表添加节点</strong></p><p><a href="https://images0.cnblogs.com/blog/497634/201402/231246431888916.jpg"><img src="https://images0.cnblogs.com/blog/497634/201402/231246431888916.jpg" alt=""></a></p><p>在"节点10"与"节点20"之间添加"节点15"<br><strong>添加之前</strong>："节点10" 的后继节点为"节点20"。<br><strong>添加之后</strong>："节点10" 的后继节点为"节点15"，而"节点15" 的后继节点为"节点20"。</p><p>单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。</p></h3></div><div></div></div><div></div></div><div></div></div><div></div> ",
            "assembleText":"单链表添加节点 在"节点10"与"节点20"之间添加"节点15" 添加之前："节点10" 的后继节点为"节点20"。 添加之后："节点10" 的后继节点为"节点15"，而"节点15" 的后继节点为"节点20"。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。",
            "assembleScratchTime":"2019-04-06 21:32:01",
            "facetId":556329,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/skywang12345/p/3561803.html#a31",
            "type":"text"
        },
        {
            "assembleId":2870161,
            "assembleContent":"<h2><span style="font-size: medium;"><b>双向链表</b>，又称为<b>双链表</b>，是<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" title="链表">链表</a>的一种，它的每个数据结点中都有两个<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" title="指针 (计算机科学)">指针</a>，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向<a href="https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" title="循环链表">循环链表</a>。  <img src="http://yotta.xjtushilei.com:8090/1554120489770/861862098.png"></span></h2> ",
            "assembleText":"双向链表，又称为双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。  ",
            "assembleScratchTime":"2019-04-05 12:55:01",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870162,
            "assembleContent":"<h2><b>双向链表</b><br></h2><h2><div><pre><code>// 线性表的双向链表存储结构<br>typedef struct DuLNode {<br>    ElemType data;<br>    struct DuLNode *prior, *next;<br>} DuLNode, *DuLinkList;<br><br>// 带头结点的双向循环链表的基本操作(14个)<br>void InitList(DuLinkList *L) {<br>    // 产生空的双向循环链表L<br>    *L = (DuLinkList)malloc(sizeof(DuLNode));<br>    if (*L)<br>        (*L)->next = (*L)->prior = *L;<br>    else<br>        exit(OVERFLOW);<br>}<br><br>void DestroyList(DuLinkList *L) {<br>    // 操作结果：销毁双向循环链表L<br>    DuLinkList q, p = (*L)->next; // p指向第一个结点<br>    while (p != *L) { // p没到表头<br>        q = p->next;<br>        free(p);<br>        p = q;<br>    }<br>    free(*L);<br>    *L = NULL;<br>}<br><br>void ClearList(DuLinkList L) { // 不改变L<br>    // 初始条件：L已存在。操作结果：将L重置为空表<br>    DuLinkList q, p = L->next; // p指向第一个结点<br>    while (p != L) { // p没到表头<br>        q = p->next;<br>        free(p);<br>        p = q;<br>    }<br>    L->next = L->prior = L; // 头结点的两个指针域均指向自身<br>}<br><br>Status ListEmpty(DuLinkList L) {<br>    // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE<br>    if (L->next == L && L->prior == L)<br>        return TRUE;<br>    else<br>        return FALSE;<br>}<br><br>int ListLength(DuLinkList L) {<br>    // 初始条件：L已存在。操作结果：返回L中数据元素个数<br>    int i = 0;<br>    DuLinkList p = L->next; // p指向第一个结点<br>    while (p != L) { // p没到表头<br>        i++;<br>        p = p->next;<br>    }<br>    return i;<br>}<br><br>Status GetElem(DuLinkList L, int i, ElemType *e) {<br>    // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR<br>    int j = 1; // j为计数器<br>    DuLinkList p = L->next; // p指向第一个结点<br>    while (p != L && j < i) { // 顺指针向后查找，直到p指向第i个元素或p指向头结点<br>        p = p->next;<br>        j++;<br>    }<br>    if (p == L || j > i) // 第i个元素不存在<br>        return ERROR;<br>    *e = p->data; // 取第i个元素<br>    return OK;<br>}<br><br>int LocateElem(DuLinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) {<br>    // 初始条件：L已存在，compare()是数据元素判定函数<br>    // 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。<br>    // 若这样的数据元素不存在，则返回值为0<br>    int i = 0;<br>    DuLinkList p = L->next; // p指向第1个元素<br>    while (p != L) {<br>        i++;<br>        if (compare(p->data, e)) // 找到这样的数据元素<br>            return i;<br>        p = p->next;<br>    }<br>    return 0;<br>}<br><br>Status PriorElem(DuLinkList L, ElemType cur_e, ElemType *pre_e) {<br>    // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，<br>    // 否则操作失败，pre_e无定义<br>    DuLinkList p = L->next->next; // p指向第2个元素<br>    while (p != L) { // p没到表头<br>        if (p->data == cur_e) {<br>            *pre_e = p->prior->data;<br>            return TRUE;<br>        }<br>        p = p->next;<br>    }<br>    return FALSE;<br>}<br><br>Status NextElem(DuLinkList L, ElemType cur_e, ElemType *next_e) {<br>    // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，<br>    // 否则操作失败，next_e无定义<br>    DuLinkList p = L->next->next; // p指向第2个元素<br>    while (p != L) { // p没到表头<br>        if (p->prior->data == cur_e) {<br>            *next_e = p->data;<br>            return TRUE;<br>        }<br>        p = p->next;<br>    }<br>    return FALSE;<br>}<br><br>DuLinkList GetElemP(DuLinkList L, int i) { // 另加<br>    // 在双向链表L中返回第i个元素的地址。i为0，返回头结点的地址。若第i个元素不存在，<br>    // 返回NULL<br>    int j;<br>    DuLinkList p = L; // p指向头结点<br>    if (i < 0 || i > ListLength(L)) // i值不合法<br>        return NULL;<br>    for (j = 1; j <= i; j++)<br>        p = p->next;<br>    return p;<br>}<br><br>Status ListInsert(DuLinkList L, int i, ElemType e) {<br>    // 在带头结点的双链循环线性表L中第i个位置之前插入元素e，i的合法值为1≤i≤表长+1<br>    // 改进算法2.18，否则无法在第表长+1个结点之前插入元素<br>    DuLinkList p, s;<br>    if (i < 1 || i > ListLength(L) + 1) // i值不合法<br>        return ERROR;<br>    p = GetElemP(L, i - 1); // 在L中确定第i个元素前驱的位置指针p<br>    if (!p) // p=NULL,即第i个元素的前驱不存在(设头结点为第1个元素的前驱)<br>        return ERROR;<br>    s = (DuLinkList)malloc(sizeof(DuLNode));<br>    if (!s)<br>        return OVERFLOW;<br>    s->data = e;<br>    s->prior = p; // 在第i-1个元素之后插入<br>    s->next = p->next;<br>    p->next->prior = s;<br>    p->next = s;<br>    return OK;<br>}<br><br>Status ListDelete(DuLinkList L, int i, ElemType *e) {<br>    // 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1≤i≤表长<br>    DuLinkList p;<br>    if (i < 1) // i值不合法<br>        return ERROR;<br>    p = GetElemP(L, i); // 在L中确定第i个元素的位置指针p<br>    if (!p) // p = NULL,即第i个元素不存在<br>        return ERROR;<br>    *e = p->data;<br>    p->prior->next = p->next; // 此处并没有考虑链表头，链表尾<br>    p->next->prior = p->prior;<br>    free(p);<br>    return OK;<br>}<br><br>void ListTraverse(DuLinkList L, void(*visit)(ElemType)) {<br>    // 由双链循环线性表L的头结点出发，正序对每个数据元素调用函数visit()<br>    DuLinkList p = L->next; // p指向头结点<br>    while (p != L) {<br>        visit(p->data);<br>        p = p->next;<br>    }<br>    printf("\n");<br>}<br><br>void ListTraverseBack(DuLinkList L, void(*visit)(ElemType)) {<br>    // 由双链循环线性表L的头结点出发，逆序对每个数据元素调用函数visit()<br>    DuLinkList p = L->prior; // p指向尾结点<br>    while (p != L) {<br>        visit(p->data);<br>        p = p->prior;<br>    }<br>    printf("\n");<br>}</code></pre><br></div></h2> ",
            "assembleText":"双向链表 // 线性表的双向链表存储结构 typedef struct DuLNode {     ElemType data;     struct DuLNode *prior, *next; } DuLNode, *DuLinkList; // 带头结点的双向循环链表的基本操作(14个) void InitList(DuLinkList *L) {     // 产生空的双向循环链表L     *L = (DuLinkList)malloc(sizeof(DuLNode));     if (*L)         (*L)->next = (*L)->prior = *L;     else         exit(OVERFLOW); } void DestroyList(DuLinkList *L) {     // 操作结果：销毁双向循环链表L     DuLinkList q, p = (*L)->next; // p指向第一个结点     while (p != *L) { // p没到表头         q = p->next;         free(p);         p = q;     }     free(*L);     *L = NULL; } void ClearList(DuLinkList L) { // 不改变L     // 初始条件：L已存在。操作结果：将L重置为空表     DuLinkList q, p = L->next; // p指向第一个结点     while (p != L) { // p没到表头         q = p->next;         free(p);         p = q;     }     L->next = L->prior = L; // 头结点的两个指针域均指向自身 } Status ListEmpty(DuLinkList L) {     // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE     if (L->next == L && L->prior == L)         return TRUE;     else         return FALSE; } int ListLength(DuLinkList L) {     // 初始条件：L已存在。操作结果：返回L中数据元素个数     int i = 0;     DuLinkList p = L->next; // p指向第一个结点     while (p != L) { // p没到表头         i++;         p = p->next;     }     return i; } Status GetElem(DuLinkList L, int i, ElemType *e) {     // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR     int j = 1; // j为计数器     DuLinkList p = L->next; // p指向第一个结点     while (p != L && j < i) { // 顺指针向后查找，直到p指向第i个元素或p指向头结点         p = p->next;         j++;     }     if (p == L || j > i) // 第i个元素不存在         return ERROR;     *e = p->data; // 取第i个元素     return OK; } int LocateElem(DuLinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) {     // 初始条件：L已存在，compare()是数据元素判定函数     // 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。     // 若这样的数据元素不存在，则返回值为0     int i = 0;     DuLinkList p = L->next; // p指向第1个元素     while (p != L) {         i++;         if (compare(p->data, e)) // 找到这样的数据元素             return i;         p = p->next;     }     return 0; } Status PriorElem(DuLinkList L, ElemType cur_e, ElemType *pre_e) {     // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，     // 否则操作失败，pre_e无定义     DuLinkList p = L->next->next; // p指向第2个元素     while (p != L) { // p没到表头         if (p->data == cur_e) {             *pre_e = p->prior->data;             return TRUE;         }         p = p->next;     }     return FALSE; } Status NextElem(DuLinkList L, ElemType cur_e, ElemType *next_e) {     // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，     // 否则操作失败，next_e无定义     DuLinkList p = L->next->next; // p指向第2个元素     while (p != L) { // p没到表头         if (p->prior->data == cur_e) {             *next_e = p->data;             return TRUE;         }         p = p->next;     }     return FALSE; } DuLinkList GetElemP(DuLinkList L, int i) { // 另加     // 在双向链表L中返回第i个元素的地址。i为0，返回头结点的地址。若第i个元素不存在，     // 返回NULL     int j;     DuLinkList p = L; // p指向头结点     if (i < 0 || i > ListLength(L)) // i值不合法         return NULL;     for (j = 1; j <= i; j++)         p = p->next;     return p; } Status ListInsert(DuLinkList L, int i, ElemType e) {     // 在带头结点的双链循环线性表L中第i个位置之前插入元素e，i的合法值为1≤i≤表长+1     // 改进算法2.18，否则无法在第表长+1个结点之前插入元素     DuLinkList p, s;     if (i < 1 || i > ListLength(L) + 1) // i值不合法         return ERROR;     p = GetElemP(L, i - 1); // 在L中确定第i个元素前驱的位置指针p     if (!p) // p=NULL,即第i个元素的前驱不存在(设头结点为第1个元素的前驱)         return ERROR;     s = (DuLinkList)malloc(sizeof(DuLNode));     if (!s)         return OVERFLOW;     s->data = e;     s->prior = p; // 在第i-1个元素之后插入     s->next = p->next;     p->next->prior = s;     p->next = s;     return OK; } Status ListDelete(DuLinkList L, int i, ElemType *e) {     // 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1≤i≤表长     DuLinkList p;     if (i < 1) // i值不合法         return ERROR;     p = GetElemP(L, i); // 在L中确定第i个元素的位置指针p     if (!p) // p = NULL,即第i个元素不存在         return ERROR;     *e = p->data;     p->prior->next = p->next; // 此处并没有考虑链表头，链表尾     p->next->prior = p->prior;     free(p);     return OK; } void ListTraverse(DuLinkList L, void(*visit)(ElemType)) {     // 由双链循环线性表L的头结点出发，正序对每个数据元素调用函数visit()     DuLinkList p = L->next; // p指向头结点     while (p != L) {         visit(p->data);         p = p->next;     }     printf("\n"); } void ListTraverseBack(DuLinkList L, void(*visit)(ElemType)) {     // 由双链循环线性表L的头结点出发，逆序对每个数据元素调用函数visit()     DuLinkList p = L->prior; // p指向尾结点     while (p != L) {         visit(p->data);         p = p->prior;     }     printf("\n"); }",
            "assembleScratchTime":"2019-04-05 12:55:30",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870174,
            "assembleContent":"<h2><p><span style="font-size: medium;"><b>双向链表</b>也叫<b>双链表</b>。<b>双向链表</b>中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。</span></p><p><span style="font-size: medium;">由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84" title="数组">数组</a>里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。</span></p></h2> ",
            "assembleText":"双向链表也叫双链表。双向链表中不仅有指向后一个节点的指针，还有指向前一个节点的指针。这样可以从任何一个节点访问前一个节点，当然也可以访问后一个节点，以至整个链表。一般是在需要大批量的另外储存数据在链表中的位置的时候用。双向链表也可以配合下面的其他链表的扩展使用。 由于另外储存了指向链表内容的指针，并且可能会修改相邻的节点，有的时候第一个节点可能会被删除或者在之前添加一个新的节点。这时候就要修改指向首个节点的指针。有一种方便的可以消除这种特殊情况的方法是在最后一个节点之后、第一个节点之前储存一个永远不会被删除或者移动的虚拟节点，形成一个下面说的循环链表。这个虚拟节点之后的节点就是真正的第一个节点。这种情况通常可以用这个虚拟节点直接表示这个链表，对于把链表单独的存在数组里的情况，也可以直接用这个数组表示链表并用第0个或者第-1个（如果编译器支持）节点固定的表示这个虚拟节点。",
            "assembleScratchTime":"2019-04-05 12:59:54",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870180,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口声明" style="font-size: medium;">接口声明</span></h3><h2><div><pre><code><span style="font-size: medium;">#ifndef LLIST_H<br>#define LLIST_H<br><br>typedef void node_proc_fun_t(void*);<br>typedef int node_comp_fun_t(const void*, const void*);<br><br>typedef void LLIST_T;<br><br>LLIST_T *llist_new(int elmsize);<br>int llist_delete(LLIST_T *ptr);<br> <br>int llist_node_append(LLIST_T *ptr, const void *datap);<br>int llist_node_prepend(LLIST_T *ptr, const void *datap);<br><br>int llist_travel(LLIST_T *ptr, node_proc_fun_t *proc);<br> <br>void llist_node_delete(LLIST_T *ptr, node_comp_fun_t *comp, const void *key); <br>void *llist_node_find(LLIST_T *ptr, node_comp_fun_t *comp, const void *key);<br><br>#endif</span></code></pre><p><span style="font-size: medium;"><br></span></p></div></h2><h2><p><br></p></h2> ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口声明 #ifndef LLIST_H #define LLIST_H typedef void node_proc_fun_t(void*); typedef int node_comp_fun_t(const void*, const void*); typedef void LLIST_T; LLIST_T *llist_new(int elmsize); int llist_delete(LLIST_T *ptr); int llist_node_append(LLIST_T *ptr, const void *datap); int llist_node_prepend(LLIST_T *ptr, const void *datap); int llist_travel(LLIST_T *ptr, node_proc_fun_t *proc); void llist_node_delete(LLIST_T *ptr, node_comp_fun_t *comp, const void *key); void *llist_node_find(LLIST_T *ptr, node_comp_fun_t *comp, const void *key); #endif",
            "assembleScratchTime":"2019-04-05 13:01:59",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870181,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口实现" style="font-size: medium;">接口实现</span></h3><h4><span id=".E7.B1.BB.E5.9E.8B.E5.AE.9A"></span><span id="类型定">类型定</span></h4><h3><div dir="ltr"><pre> 1 struct node_st {
 2     void *datap;
 3     struct node_st *next, *prev;
 4 };
 5 
 6 struct llit_st {
 7     struct node_st head;
 8     int lmsize;
 9     int elmnr;
10 };</pre></div></h3><h2><p><br></p></h2>  ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口实现 类型定  1 struct node_st {
 2     void *datap;
 3     struct node_st *next, *prev;
 4 };
 5 
 6 struct llit_st {
 7     struct node_st head;
 8     int lmsize;
 9     int elmnr;
10 };",
            "assembleScratchTime":"2019-04-06 21:17:03",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870182,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口实现" style="font-size: medium;">接口实现</span></h3><h4><span id="初始化和销毁">初始化和销毁</span></h4><h4><div dir="ltr"><pre> 1 LLIST_T *
 2 llist_new(int elmsize) {
 3     struct llist_st *newlist;
 4     newlist = malloc(sizeof(struct llist_st));
 5     if (newlist == NULL)
 6         return NULL;
 7     newlist->head.datap = NULL;
 8     newlist->head.next = &newlist->head;
 9     newlist->head.prev = &newlist->head;
10     newlist->elmsize = elmsize;
11     return (void *)newlist;
12 }
13 
14 int llist_delete(LLIST_T *ptr) {
15     struct llist_st *me = ptr;
16     struct node_st *curr, *save;
17     for (curr = me->head.next ;
18             curr != &me->head ; curr = save) {
19         save = curr->next;
20         free(curr->datap);
21         free(curr);
22     }
23     free(me);
24     return 0;
25 }</pre></div></h4> ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口实现 初始化和销毁  1 LLIST_T *
 2 llist_new(int elmsize) {
 3     struct llist_st *newlist;
 4     newlist = malloc(sizeof(struct llist_st));
 5     if (newlist == NULL)
 6         return NULL;
 7     newlist->head.datap = NULL;
 8     newlist->head.next = &newlist->head;
 9     newlist->head.prev = &newlist->head;
10     newlist->elmsize = elmsize;
11     return (void *)newlist;
12 }
13 
14 int llist_delete(LLIST_T *ptr) {
15     struct llist_st *me = ptr;
16     struct node_st *curr, *save;
17     for (curr = me->head.next ;
18             curr != &me->head ; curr = save) {
19         save = curr->next;
20         free(curr->datap);
21         free(curr);
22     }
23     free(me);
24     return 0;
25 }",
            "assembleScratchTime":"2019-04-05 13:02:48",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870183,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口实现" style="font-size: medium;">接口实现</span></h3><h4><span id="节点插入">节点插入</span></h4><h4><div dir="ltr"><pre> 1 int llist_node_append(LLIST_T *ptr, const void *datap) {
 2     struct llist_st *me = ptr;
 3     struct node_st *newnodep;
 4     newnodep = malloc(sizeof(struct node_st));
 5     if (newnodep == NULL)
 6         return -1;
 7     newnodep->datap = malloc(me->elmsize);
 8     if (newnodep->datap == NULL) {
 9         free(newnodep);
10         return -1;
11     }
12     memcpy(newnodep->datap, datap, me->elmsize);
13     me->head.prev->next = newnodep;
14     newnodep->prev = me->head.prev;
15     me->head.prev = newnodep;
16     newnodep->next = &me->head;
17     return 0;
18 }
19 
20 int llist_node_prepend(LLIST_T *ptr, const void *datap) {
21     struct llist_st *me = ptr;
22     struct node_st *newnodep;
23     newnodep = malloc(sizeof(struct node_st));
24     if (newnodep == NULL)
25         return -1;
26     newnodep->datap = malloc(me->elmsize);
27     if (newnodep->datap == NULL) {
28         free(newnodep);
29         return -1;
30     }
31     memcpy(newnodep->datap, datap, me->elmsize);
32     me->head.next->prev = newnodep;
33     newnodep->next = me->head.next;
34     me->head.next = newnodep;
35     newnodep->prev = &me->head;
36     return 0;
37 }</pre></div></h4> ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口实现 节点插入  1 int llist_node_append(LLIST_T *ptr, const void *datap) {
 2     struct llist_st *me = ptr;
 3     struct node_st *newnodep;
 4     newnodep = malloc(sizeof(struct node_st));
 5     if (newnodep == NULL)
 6         return -1;
 7     newnodep->datap = malloc(me->elmsize);
 8     if (newnodep->datap == NULL) {
 9         free(newnodep);
10         return -1;
11     }
12     memcpy(newnodep->datap, datap, me->elmsize);
13     me->head.prev->next = newnodep;
14     newnodep->prev = me->head.prev;
15     me->head.prev = newnodep;
16     newnodep->next = &me->head;
17     return 0;
18 }
19 
20 int llist_node_prepend(LLIST_T *ptr, const void *datap) {
21     struct llist_st *me = ptr;
22     struct node_st *newnodep;
23     newnodep = malloc(sizeof(struct node_st));
24     if (newnodep == NULL)
25         return -1;
26     newnodep->datap = malloc(me->elmsize);
27     if (newnodep->datap == NULL) {
28         free(newnodep);
29         return -1;
30     }
31     memcpy(newnodep->datap, datap, me->elmsize);
32     me->head.next->prev = newnodep;
33     newnodep->next = me->head.next;
34     me->head.next = newnodep;
35     newnodep->prev = &me->head;
36     return 0;
37 }",
            "assembleScratchTime":"2019-04-05 13:03:01",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870184,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口实现" style="font-size: medium;">接口实现</span></h3><h4><span id="遍历">遍历</span></h4><h4><div dir="ltr"><pre>1 int llist_travel(LLIST_T *ptr, node_proc_fun_t *proc) {
2     struct llist_st *me = ptr;
3     struct node_st *curr;
4     for (curr = me->head.next;
5             curr != &me->head ; curr = curr->next)
6         proc(curr->datap); // proc(something you like)
7     return 0;
8 }</pre></div></h4> ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口实现 遍历 1 int llist_travel(LLIST_T *ptr, node_proc_fun_t *proc) {
2     struct llist_st *me = ptr;
3     struct node_st *curr;
4     for (curr = me->head.next;
5             curr != &me->head ; curr = curr->next)
6         proc(curr->datap); // proc(something you like)
7     return 0;
8 }",
            "assembleScratchTime":"2019-04-05 13:03:15",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870185,
            "assembleContent":"<h2><p><span style="font-size: medium;">范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" title="线程" style="">线程</a>安全机制），全部遵从<a href="https://zh.wikipedia.org/wiki/ANSI_C" title="ANSI C" style="">ANSI C</a>标准。  <br></span></p></h2><h3><span id="接口实现" style="font-size: medium;">接口实现</span></h3><h4><span id="删除和查找">删除和查找</span></h4><h4><div dir="ltr"><pre> 1 void llist_node_delete(LLIST_T *ptr,
 2                        node_comp_fun_t *comp,
 3                        const void *key) {
 4     struct llist_st *me = ptr;
 5     struct node_st *curr;
 6     for (curr = me->head.next;
 7             curr != &me->head; curr = curr->next) {
 8         if ( (*comp)(curr->datap, key) == 0 ) {
 9             struct node_st *_next, *_prev;
10             _prev = curr->prev; _next = curr->next;
11             _prev->next = _next; _next->prev = _prev;
12             free(curr->datap);
13             free(curr);
14             break;
15         }
16     }
17     return;
18 }
19 
20 void *llist_node_find(LLIST_T *ptr,
21                       node_comp_fun_t *comp, const void *key) {
22     struct llist_st *me = ptr;
23     struct node_st *curr;
24     for (curr = me->head.next;
25             curr != &me->head; curr = curr->next) {
26         if ( (*comp)(curr->datap, key) == 0 )
27             return curr->datap;
28     }
29     return NULL;
30 }</pre></div></h4> ",
            "assembleText":"范例代码是一个ADT（抽象数据类型）双向环形链表的基本操作部分的实例（未包含线程安全机制），全部遵从ANSI C标准。   接口实现 删除和查找  1 void llist_node_delete(LLIST_T *ptr,
 2                        node_comp_fun_t *comp,
 3                        const void *key) {
 4     struct llist_st *me = ptr;
 5     struct node_st *curr;
 6     for (curr = me->head.next;
 7             curr != &me->head; curr = curr->next) {
 8         if ( (*comp)(curr->datap, key) == 0 ) {
 9             struct node_st *_next, *_prev;
10             _prev = curr->prev; _next = curr->next;
11             _prev->next = _next; _next->prev = _prev;
12             free(curr->datap);
13             free(curr);
14             break;
15         }
16     }
17     return;
18 }
19 
20 void *llist_node_find(LLIST_T *ptr,
21                       node_comp_fun_t *comp, const void *key) {
22     struct llist_st *me = ptr;
23     struct node_st *curr;
24     for (curr = me->head.next;
25             curr != &me->head; curr = curr->next) {
26         if ( (*comp)(curr->datap, key) == 0 )
27             return curr->datap;
28     }
29     return NULL;
30 }",
            "assembleScratchTime":"2019-04-05 13:03:34",
            "facetId":556330,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870194,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表节点的缺点是只有一个后继节点，访问前驱节点只能从头遍历（如插入、删除），时间复杂度为O(n)。双链表，即添加一个指向前驱的节点，节点类型如下：</span></p><pre></pre><pre><span style="font-size: medium;">private class Node{
    // 链表节点的嵌套类
    T item; // 节点内容
    Node prior, next; // 前驱节点和后继节点
}</span></pre><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115I548-8.png" alt=""></span></p><pre></pre><p><span style="font-size: medium;">双链表的查找和单链表的相同再次不在赘述，双链表的构造也分为头插和尾插，与单链表唯一不同的是修改前驱指针prior，具体见源码。插入和删除时不同，因为需要修改两个指针，如果给定要操作的节点，插入和删除的时间复杂度为O(1)。</span></p><pre></pre><p><span style="font-size: medium;">注：插入删除操作同样也是先断后连。</span></p></h1> ",
            "assembleText":"单链表节点的缺点是只有一个后继节点，访问前驱节点只能从头遍历（如插入、删除），时间复杂度为O(n)。双链表，即添加一个指向前驱的节点，节点类型如下： private class Node{
    // 链表节点的嵌套类
    T item; // 节点内容
    Node prior, next; // 前驱节点和后继节点
} 双链表的查找和单链表的相同再次不在赘述，双链表的构造也分为头插和尾插，与单链表唯一不同的是修改前驱指针prior，具体见源码。插入和删除时不同，因为需要修改两个指针，如果给定要操作的节点，插入和删除的时间复杂度为O(1)。 注：插入删除操作同样也是先断后连。",
            "assembleScratchTime":"2019-04-05 13:06:17",
            "facetId":556330,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870195,
            "assembleContent":"<h1><p><span style="font-size: medium;">双链表</span></p><p><span style="font-size: medium;">1. 插入节点</span></p><pre></pre><p><span style="font-size: medium;">在p节点后插入s节点，先断后连，先把p和原后继节点的链条给断了，使后继节点只跟s节点有关：</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115H4H-9.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">①s.next = p.next; // 先断了p的后继
②p.next.prior = s; // 在断了p后继的前驱
③s.prior = p; // 让s的前驱指向p
④p.next = s; // p的后继指向s，重新连接上链条，此步必须在①②之后</span></pre></h1>  ",
            "assembleText":"双链表 1. 插入节点 在p节点后插入s节点，先断后连，先把p和原后继节点的链条给断了，使后继节点只跟s节点有关： ①s.next = p.next; // 先断了p的后继
②p.next.prior = s; // 在断了p后继的前驱
③s.prior = p; // 让s的前驱指向p
④p.next = s; // p的后继指向s，重新连接上链条，此步必须在①②之后",
            "assembleScratchTime":"2019-04-06 21:19:51",
            "facetId":556330,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870198,
            "assembleContent":"<h1><p><span style="font-size: medium;">双链表</span></p><p><span style="font-size: medium;">2. 删除节点</span></p><pre></pre><p><span style="font-size: medium;">删除节点p的后继节点q，也是先断后连，把q和其后继节点的关系，转让给p即可：</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115LW1-10.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">①p.next = q.next; // 先断了q的后继
②q.next.prior = p; // 在断了q后继的前驱

删除节点q的前驱节点p，把p和去前驱节点的关系转让给q即可：
①q = p.prior.next; // 把p前驱节点的后继改成q
②q.prior = p.prior; // 把q的前驱节点改成p的前驱节点</span></pre></h1> ",
            "assembleText":"双链表 2. 删除节点 删除节点p的后继节点q，也是先断后连，把q和其后继节点的关系，转让给p即可： ①p.next = q.next; // 先断了q的后继
②q.next.prior = p; // 在断了q后继的前驱

删除节点q的前驱节点p，把p和去前驱节点的关系转让给q即可：
①q = p.prior.next; // 把p前驱节点的后继改成q
②q.prior = p.prior; // 把q的前驱节点改成p的前驱节点",
            "assembleScratchTime":"2019-04-05 13:07:13",
            "facetId":556330,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870446,
            "assembleContent":"<h3><span id="Doubly_linked_list">Doubly linked list</span></h3><div><p>In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or 'next' and 'prev'('previous').</p><div><a href="https://en.wikipedia.org/wiki/File:Doubly-linked-list.svg"><img alt="Doubly-linked-list.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/610px-Doubly-linked-list.svg.png" decoding="async" width="610" height="41" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/915px-Doubly-linked-list.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Doubly-linked-list.svg/1220px-Doubly-linked-list.svg.png 2x"></a><br><small><i>A doubly linked list whose nodes contain three fields: an integer value, the link forward to the next node, and the link backward to the previous node</i></small></div><p>A technique known as <a href="https://en.wikipedia.org/wiki/XOR_linked_list" title="XOR linked list">XOR-linking</a> allows a doubly linked list to be implemented using a single link field in each node. However, this technique requires the ability to do bit operations on addresses, and therefore may not be available in some high-level languages.</p><p>Many modern operating systems use doubly linked lists to maintain references to active processes, threads, and other dynamic objects.<sup id="cite_ref-2"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-2">[2]</a></sup> A common strategy for <a href="https://en.wikipedia.org/wiki/Rootkits" title="Rootkits">rootkits</a> to evade detection is to unlink themselves from these lists.<sup id="cite_ref-3"><a href="https://en.wikipedia.org/wiki/Linked_list#cite_note-3">[3]</a></sup></p></div>  ",
            "assembleText":"Doubly linked list In a 'doubly linked list', each node contains, besides the next-node link, a second link field pointing to the 'previous' node in the sequence. The two links may be called 'forward('s') and 'backwards', or 'next' and 'prev'('previous'). A doubly linked list whose nodes contain three fields: an integer value, the link forward to the next node, and the link backward to the previous node A technique known as XOR-linking allows a doubly linked list to be implemented using a single link field in each node. However, this technique requires the ability to do bit operations on addresses, and therefore may not be available in some high-level languages. Many modern operating systems use doubly linked lists to maintain references to active processes, threads, and other dynamic objects.[2] A common strategy for rootkits to evade detection is to unlink themselves from these lists.[3]",
            "assembleScratchTime":"2019-04-06 21:20:41",
            "facetId":556330,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870163,
            "assembleContent":"<h2><span style="font-size: medium;"><b>循环链表</b>是一种<a href="https://zh.wikipedia.org/w/index.php?title=%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84&action=edit&redlink=1" title="链式存储结构（页面不存在）">链式存储结构</a>，它的最后一个<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BB%93%E7%82%B9&action=edit&redlink=1" title="结点（页面不存在）">结点</a>指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%93%BE%E8%A1%A8" title="单链表">单链表</a>的操作基本一致，差别仅仅在于算法中的循环条件有所不同。  </span></h2> ",
            "assembleText":"循环链表是一种链式存储结构，它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同。  ",
            "assembleScratchTime":"2019-04-05 12:55:53",
            "facetId":556331,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870164,
            "assembleContent":"<h2><span id="单向循环链表" style="font-size: medium;">单向循环链表</span></h2><h2><div><span style="font-size: medium;">存储结构和<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E9%93%BE%E8%A1%A8" title="单链表">单链表</a>相同。 </span></div><div><span style="font-size: medium;"><br></span></div><pre><code><span style="font-size: medium;">
</span><p><span style="font-size: medium;">// 设立尾指针的单循环链表的12个基本操作</span></p></code><code><span style="font-size: medium;">void InitList(LinkList *L) { // 操作结果：构造一个空的线性表L<br>    *L = (LinkList)malloc(sizeof(struct LNode)); // 产生头结点，并使L指向此头结点<br>    if (!*L) // 存储分配失败<br>        exit(OVERFLOW);<br>    (*L)->next = *L; // 指针域指向头结点<br>}<br><br>void DestroyList(LinkList *L) { // 操作结果：销毁线性表L<br>    LinkList q, p = (*L)->next; // p指向头结点<br>    while (p != *L) { // 没到表尾<br>        q = p->next;<br>        free(p);<br>        p = q;<br>    }<br>    free(*L);<br>    *L = NULL;<br>}<br><br>void ClearList(LinkList *L) /* 改变L */ { // 初始条件：线性表L已存在。操作结果：将L重置为空表<br>    LinkList p, q;<br>    *L = (*L)->next; // L指向头结点<br>    p = (*L)->next; // p指向第一个结点<br>    while (p != *L) { // 没到表尾<br>        q = p->next;<br>        free(p);<br>        p = q;<br>    }<br>    (*L)->next = *L; // 头结点指针域指向自身<br>}<br><br>Status ListEmpty(LinkList L) { // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE<br>    if (L->next == L) // 空<br>        return TRUE;<br>    else<br>        return FALSE;<br>}<br><br>int ListLength(LinkList L) { // 初始条件：L已存在。操作结果：返回L中数据元素个数<br>    int i = 0;<br>    LinkList p = L->next; // p指向头结点<br>    while (p != L) { // 没到表尾<br>        i++;<br>        p = p->next;<br>    }<br>    return i;<br>}<br><br>Status GetElem(LinkList L, int i, ElemType *e) { // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR<br>    int j = 1; // 初始化，j为计数器<br>    LinkList p = L->next->next; // p指向第一个结点<br>    if (i <= 0 || i > ListLength(L)) // 第i个元素不存在<br>        return ERROR;<br>    while (j < i) { // 顺指针向后查找，直到p指向第i个元素<br>        p = p->next;<br>        j++;<br>    }<br>    *e = p->data; // 取第i个元素<br>    return OK;<br>}<br><br>int LocateElem(LinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) { // 初始条件：线性表L已存在，compare()是数据元素判定函数<br>    // 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。<br>    //           若这样的数据元素不存在，则返回值为0<br>    int i = 0;<br>    LinkList p = L->next->next; // p指向第一个结点<br>    while (p != L->next) {<br>        i++;<br>        if (compare(p->data, e)) // 满足关系<br>            return i;<br>        p = p->next;<br>    }<br>    return 0;<br>}<br><br>Status PriorElem(LinkList L, ElemType cur_e, ElemType *pre_e) { // 初始条件：线性表L已存在<br>    // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，<br>    //           否则操作失败，pre_e无定义<br>    LinkList q, p = L->next->next; // p指向第一个结点<br>    q = p->next;<br>    while (q != L->next) { // p没到表尾<br>        if (q->data == cur_e) {<br>            *pre_e = p->data;<br>            return TRUE;<br>        }<br>        p = q;<br>        q = q->next;<br>    }<br>    return FALSE; // 操作失败<br>}<br><br>Status NextElem(LinkList L, ElemType cur_e, ElemType *next_e) { // 初始条件：线性表L已存在<br>    // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，<br>    //           否则操作失败，next_e无定义<br>    LinkList p = L->next->next; // p指向第一个结点<br>    while (p != L) { // p没到表尾<br>        if (p->data == cur_e) {<br>            *next_e = p->next->data;<br>            return TRUE;<br>        }<br>        p = p->next;<br>    }<br>    return FALSE; // 操作失败<br>}<br><br>Status ListInsert(LinkList *L, int i, ElemType e) /* 改变L */ { // 在L的第i个位置之前插入元素e<br>    LinkList p = (*L)->next, s; // p指向头结点<br>    int j = 0;<br>    if (i <= 0 || i > ListLength(*L) + 1) // 无法在第i个元素之前插入<br>        return ERROR;<br>    while (j < i - 1) { // 寻找第i-1个结点<br>        p = p->next;<br>        j++;<br>    }<br>    s = (LinkList)malloc(sizeof(struct LNode)); // 生成新结点<br>    s->data = e; // 插入L中<br>    s->next = p->next;<br>    p->next = s;<br>    if (p == *L) // 改变尾结点<br>        *L = s;<br>    return OK;<br>}<br><br>Status ListDelete(LinkList *L, int i, ElemType *e) /* 改变L */ { // 删除L的第i个元素，并由e返回其值<br>    LinkList p = (*L)->next, q; // p指向头结点<br>    int j = 0;<br>    if (i <= 0 || i > ListLength(*L)) // 第i个元素不存在<br>        return ERROR;<br>    while (j < i - 1) { // 寻找第i-1个结点<br>        p = p->next;<br>        j++;<br>    }<br>    q = p->next; // q指向待删除结点<br>    p->next = q->next;<br>    *e = q->data;<br>    if (*L == q) // 删除的是表尾元素<br>        *L = p;<br>    free(q); // 释放待删除结点<br>    return OK;<br>}<br><br>void ListTraverse(LinkList L, void(*vi)(ElemType)) { // 初始条件：L已存在。操作结果：依次对L的每个数据元素调用函数vi()<br>    LinkList p = L->next->next; // p指向首元结点<br>    while (p != L->next) { // p不指向头结点<br>        vi(p->data);<br>        p = p->next;<br>    }<br>    printf("\n");<br>}</span></code></pre><p><span style="font-size: medium;"><br></span></p><div><span style="font-size: medium;"> <br></span></div><br></h2> ",
            "assembleText":"单向循环链表 存储结构和单链表相同。  // 设立尾指针的单循环链表的12个基本操作void InitList(LinkList *L) { // 操作结果：构造一个空的线性表L *L = (LinkList)malloc(sizeof(struct LNode)); // 产生头结点，并使L指向此头结点 if (!*L) // 存储分配失败 exit(OVERFLOW); (*L)->next = *L; // 指针域指向头结点 } void DestroyList(LinkList *L) { // 操作结果：销毁线性表L LinkList q, p = (*L)->next; // p指向头结点 while (p != *L) { // 没到表尾 q = p->next; free(p); p = q; } free(*L); *L = NULL; } void ClearList(LinkList *L) /* 改变L */ { // 初始条件：线性表L已存在。操作结果：将L重置为空表 LinkList p, q; *L = (*L)->next; // L指向头结点 p = (*L)->next; // p指向第一个结点 while (p != *L) { // 没到表尾 q = p->next; free(p); p = q; } (*L)->next = *L; // 头结点指针域指向自身 } Status ListEmpty(LinkList L) { // 初始条件：线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE if (L->next == L) // 空 return TRUE; else return FALSE; } int ListLength(LinkList L) { // 初始条件：L已存在。操作结果：返回L中数据元素个数 int i = 0; LinkList p = L->next; // p指向头结点 while (p != L) { // 没到表尾 i++; p = p->next; } return i; } Status GetElem(LinkList L, int i, ElemType *e) { // 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR int j = 1; // 初始化，j为计数器 LinkList p = L->next->next; // p指向第一个结点 if (i <= 0 || i > ListLength(L)) // 第i个元素不存在 return ERROR; while (j < i) { // 顺指针向后查找，直到p指向第i个元素 p = p->next; j++; } *e = p->data; // 取第i个元素 return OK; } int LocateElem(LinkList L, ElemType e, Status(*compare)(ElemType, ElemType)) { // 初始条件：线性表L已存在，compare()是数据元素判定函数 // 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。 // 若这样的数据元素不存在，则返回值为0 int i = 0; LinkList p = L->next->next; // p指向第一个结点 while (p != L->next) { i++; if (compare(p->data, e)) // 满足关系 return i; p = p->next; } return 0; } Status PriorElem(LinkList L, ElemType cur_e, ElemType *pre_e) { // 初始条件：线性表L已存在 // 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， // 否则操作失败，pre_e无定义 LinkList q, p = L->next->next; // p指向第一个结点 q = p->next; while (q != L->next) { // p没到表尾 if (q->data == cur_e) { *pre_e = p->data; return TRUE; } p = q; q = q->next; } return FALSE; // 操作失败 } Status NextElem(LinkList L, ElemType cur_e, ElemType *next_e) { // 初始条件：线性表L已存在 // 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继， // 否则操作失败，next_e无定义 LinkList p = L->next->next; // p指向第一个结点 while (p != L) { // p没到表尾 if (p->data == cur_e) { *next_e = p->next->data; return TRUE; } p = p->next; } return FALSE; // 操作失败 } Status ListInsert(LinkList *L, int i, ElemType e) /* 改变L */ { // 在L的第i个位置之前插入元素e LinkList p = (*L)->next, s; // p指向头结点 int j = 0; if (i <= 0 || i > ListLength(*L) + 1) // 无法在第i个元素之前插入 return ERROR; while (j < i - 1) { // 寻找第i-1个结点 p = p->next; j++; } s = (LinkList)malloc(sizeof(struct LNode)); // 生成新结点 s->data = e; // 插入L中 s->next = p->next; p->next = s; if (p == *L) // 改变尾结点 *L = s; return OK; } Status ListDelete(LinkList *L, int i, ElemType *e) /* 改变L */ { // 删除L的第i个元素，并由e返回其值 LinkList p = (*L)->next, q; // p指向头结点 int j = 0; if (i <= 0 || i > ListLength(*L)) // 第i个元素不存在 return ERROR; while (j < i - 1) { // 寻找第i-1个结点 p = p->next; j++; } q = p->next; // q指向待删除结点 p->next = q->next; *e = q->data; if (*L == q) // 删除的是表尾元素 *L = p; free(q); // 释放待删除结点 return OK; } void ListTraverse(LinkList L, void(*vi)(ElemType)) { // 初始条件：L已存在。操作结果：依次对L的每个数据元素调用函数vi() LinkList p = L->next->next; // p指向首元结点 while (p != L->next) { // p不指向头结点 vi(p->data); p = p->next; } printf("\n"); }  ",
            "assembleScratchTime":"2019-04-05 12:56:12",
            "facetId":556331,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870175,
            "assembleContent":"<h2><p><span style="font-size: medium;">在一个 <b>循环链表</b>中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。</span></p><p><span style="font-size: medium;">指向整个列表的指针可以被称作访问指针。</span></p><center><span style="font-size: medium;"><a href="https://zh.wikipedia.org/wiki/File:Circularly-linked-list.svg"><img alt="Circularly-linked-list.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/350px-Circularly-linked-list.svg.png" decoding="async" width="350" height="60" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/525px-Circularly-linked-list.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/700px-Circularly-linked-list.svg.png 2x"></a><br><small><i>用单向链表构建的循环链表</i></small></span></center></h2> ",
            "assembleText":"在一个 循环链表中, 首节点和末节点被连接在一起。这种方式在单向和双向链表中皆可实现。要转换一个循环链表，你开始于任意一个节点然后沿着列表的任一方向直到返回开始的节点。再来看另一种方法，循环链表可以被视为“无头无尾”。这种列表很利于节约数据存储缓存， 假定你在一个列表中有一个对象并且希望所有其他对象迭代在一个非特殊的排列下。 指向整个列表的指针可以被称作访问指针。 用单向链表构建的循环链表",
            "assembleScratchTime":"2019-04-05 13:00:10",
            "facetId":556331,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870176,
            "assembleContent":"<h2><p><span style="font-size: medium;"><b>循环链表</b>中第一个节点之前就是最后一个节点，反之亦然。循环链表的<b>无边界</b>使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大(详见下面实例代码)。当然，如果只会在最后插入数据（或者只会在之前），处理也是很容易的。</span></p><p><span style="font-size: medium;">另外有一种模拟的循环链表，就是在访问到最后一个节点之后的时候，手工的跳转到第一个节点。访问到第一个节点之前的时候也一样。这样也可以实现循环链表的功能，在直接用循环链表比较麻烦或者可能会出现问题的时候可以用。</span></p></h2> ",
            "assembleText":"循环链表中第一个节点之前就是最后一个节点，反之亦然。循环链表的无边界使得在这样的链表上设计算法会比普通链表更加容易。对于新加入的节点应该是在第一个节点之前还是最后一个节点之后可以根据实际要求灵活处理，区别不大(详见下面实例代码)。当然，如果只会在最后插入数据（或者只会在之前），处理也是很容易的。 另外有一种模拟的循环链表，就是在访问到最后一个节点之后的时候，手工的跳转到第一个节点。访问到第一个节点之前的时候也一样。这样也可以实现循环链表的功能，在直接用循环链表比较麻烦或者可能会出现问题的时候可以用。",
            "assembleScratchTime":"2019-04-05 13:00:27",
            "facetId":556331,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870199,
            "assembleContent":"<h1><p><span style="font-size: medium;"> 循环链表</span></p><pre></pre><p><span style="font-size: medium;">1. 循环单链表</span></p><pre></pre><p><span style="font-size: medium;">与单链表的区别在于，表中最后一个节点的指针不为null，而改为指向头结点（第一个节点），从而整个链表形成一个环。判断循环单链表是否为空，判断是否等于头指针。</span></p><pre></pre><p><span style="font-size: medium;">只有一个尾指针的循环单例表，可以很方便的操作表头和表尾，因为尾指针的后继就是头指针O(1) 。</span></p><pre></pre><p><span style="font-size: medium;"> </span></p></h1> ",
            "assembleText":" 循环链表 1. 循环单链表 与单链表的区别在于，表中最后一个节点的指针不为null，而改为指向头结点（第一个节点），从而整个链表形成一个环。判断循环单链表是否为空，判断是否等于头指针。 只有一个尾指针的循环单例表，可以很方便的操作表头和表尾，因为尾指针的后继就是头指针O(1) 。  ",
            "assembleScratchTime":"2019-04-05 13:07:29",
            "facetId":556331,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870200,
            "assembleContent":"<h1><p><span style="font-size: medium;"> 循环链表</span></p><pre></pre><p><span style="font-size: medium;">2. 循环双链表</span></p><pre></pre><p><span style="font-size: medium;">与双链表的区别在于，头结点的prior指针指向尾节点，尾节点的next指针指向头结点。</span></p><pre></pre><p><span style="font-size: medium;"> </span></p></h1> ",
            "assembleText":" 循环链表 2. 循环双链表 与双链表的区别在于，头结点的prior指针指向尾节点，尾节点的next指针指向头结点。  ",
            "assembleScratchTime":"2019-04-05 13:07:45",
            "facetId":556331,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870449,
            "assembleContent":"<h3><span id="Circular_linked_list">Circular linked list</span></h3><div><p>In the last node of a list, the link field often contains a <a href="https://en.wikipedia.org/wiki/Null_pointer#Null_pointer" title="Null pointer">null</a> reference, a special value is used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node.</p><div><a href="https://en.wikipedia.org/wiki/File:Circularly-linked-list.svg"><img alt="Circularly-linked-list.svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/350px-Circularly-linked-list.svg.png" decoding="async" width="350" height="60" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/525px-Circularly-linked-list.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/d/df/Circularly-linked-list.svg/700px-Circularly-linked-list.svg.png 2x"></a><br><small><i>A circular linked list</i></small></div><p>In the case of a circular doubly linked list, the first node also points to the last node of the list.</p></div> ",
            "assembleText":"Circular linked list In the last node of a list, the link field often contains a null reference, a special value is used to indicate the lack of further nodes. A less common convention is to make it point to the first node of the list; in that case, the list is said to be 'circular' or 'circularly linked'; otherwise, it is said to be 'open' or 'linear'. It is a list where the last pointer points to the first node. A circular linked list In the case of a circular doubly linked list, the first node also points to the last node of the list.",
            "assembleScratchTime":"2019-04-05 14:22:54",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870476,
            "assembleContent":"<h3><span id="Circularly_linked_list">Circularly linked list</span></h3><div><p>In a circularly linked list, all nodes are linked in a continuous circle, without using <i>null.</i> For lists with a front and a back (such as a queue), one stores a reference to the last node in the list. The <i>next</i> node after the last node is the first node. Elements can be added to the back of the list and removed from the front in constant time.</p><p>Circularly linked lists can be either singly or doubly linked.</p><p>Both types of circularly linked lists benefit from the ability to traverse the full list beginning at any given node. This often allows us to avoid storing <i>firstNode</i> and <i>lastNode</i>, although if the list may be empty we need a special representation for the empty list, such as a <i>lastNode</i> variable which points to some node in the list or is <i>null</i> if it's empty; we use such a <i>lastNode</i> here. This representation significantly simplifies adding and removing nodes with a non-empty list, but empty lists are then a special case.</p></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked list In a circularly linked list, all nodes are linked in a continuous circle, without using null. For lists with a front and a back (such as a queue), one stores a reference to the last node in the list. The next node after the last node is the first node. Elements can be added to the back of the list and removed from the front in constant time. Circularly linked lists can be either singly or doubly linked. Both types of circularly linked lists benefit from the ability to traverse the full list beginning at any given node. This often allows us to avoid storing firstNode and lastNode, although if the list may be empty we need a special representation for the empty list, such as a lastNode variable which points to some node in the list or is null if it's empty; we use such a lastNode here. This representation significantly simplifies adding and removing nodes with a non-empty list, but empty lists are then a special case.",
            "assembleScratchTime":"2019-04-05 14:30:04",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870477,
            "assembleContent":"<h3><span id="Circularly_linked_list">Circularly linked list</span></h3><div><h4><span id="Algorithms">Algorithms</span></h4></div><div><p>Assuming that <i>someNode</i> is some node in a non-empty circular singly linked list, this code iterates through that list starting with <i>someNode</i>:</p><pre> <b>function</b> iterate(someNode)
   <b>if</b> someNode ≠ <b>null</b>
     node := someNode
     <b>do</b>
       do something with node.value
       node := node.next
     <b>while</b> node ≠ someNode</pre></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked list Algorithms Assuming that someNode is some node in a non-empty circular singly linked list, this code iterates through that list starting with someNode:  function iterate(someNode)
   if someNode ≠ null
     node := someNode
     do
       do something with node.value
       node := node.next
     while node ≠ someNode",
            "assembleScratchTime":"2019-04-05 14:30:24",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870478,
            "assembleContent":"<h3><span id="Circularly_linked_list">Circularly linked list</span></h3><div><h4><span id="Algorithms">Algorithms</span></h4></div><div><p>Notice that the test "<b>while</b> node ≠ someNode" must be at the end of the loop. If the test was moved to the beginning of the loop, the procedure would fail whenever the list had only one node.</p><p>This function inserts a node "newNode" into a circular linked list after a given node "node". If "node" is null, it assumes that the list is empty.</p><pre> <b>function</b> insertAfter(<i>Node</i> node, <i>Node</i> newNode)
     <b>if</b> node = <b>null</b>
       newNode.next := newNode
     <b>else</b>
       newNode.next := node.next
       node.next := newNode</pre></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked list Algorithms Notice that the test "while node ≠ someNode" must be at the end of the loop. If the test was moved to the beginning of the loop, the procedure would fail whenever the list had only one node. This function inserts a node "newNode" into a circular linked list after a given node "node". If "node" is null, it assumes that the list is empty.  function insertAfter(Node node, Node newNode)
     if node = null
       newNode.next := newNode
     else
       newNode.next := node.next
       node.next := newNode",
            "assembleScratchTime":"2019-04-05 14:30:35",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870481,
            "assembleContent":"<h3><span id="Circularly_linked_list">Circularly linked list</span></h3><div><h4><span id="Algorithms">Algorithms</span></h4></div><div><p>Suppose that "L" is a variable pointing to the last node of a circular linked list (or null if the list is empty). To append "newNode" to the <i>end</i> of the list, one may do</p><pre> insertAfter(L, newNode)
 L := newNode</pre></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked list Algorithms Suppose that "L" is a variable pointing to the last node of a circular linked list (or null if the list is empty). To append "newNode" to the end of the list, one may do  insertAfter(L, newNode)
 L := newNode",
            "assembleScratchTime":"2019-04-05 14:30:56",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870484,
            "assembleContent":"<h3><span id="Circularly_linked_list">Circularly linked list</span></h3><div><h4><span id="Algorithms">Algorithms</span></h4></div><div><p>To insert "newNode" at the <i>beginning</i> of the list, one may do</p><pre> insertAfter(L, newNode)
 <b>if</b> L = <b>null</b>
   L := newNode</pre></div><div><div></div></div><div></div><div><tdtable-na"><tdtable-na"><tdtable-na"></tdtable-na"></tdtable-na"></tdtable-na"></div> ",
            "assembleText":"Circularly linked list Algorithms To insert "newNode" at the beginning of the list, one may do  insertAfter(L, newNode)
 if L = null
   L := newNode",
            "assembleScratchTime":"2019-04-05 14:31:08",
            "facetId":556331,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Linked_list",
            "type":"text"
        },
        {
            "assembleId":2870205,
            "assembleContent":"<h1><p><span style="font-size: medium;">把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。</span></p><p><span style="font-size: medium;"><img src="https://images2018.cnblogs.com/blog/1206298/201803/1206298-20180326133522100-1928731505.png" alt=""></span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">　　有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。</span></p></h1> ",
            "assembleText":"把链表中的第一个结点的存储位置叫做头指针。规定，线性链表的最后一个结点指针为“空”。   　　有时，为了方便对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息。",
            "assembleScratchTime":"2019-04-05 13:09:24",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870206,
            "assembleContent":"<h1><p><span style="font-size: medium;">头指针与头结点的异同</span></p><p><span style="font-size: medium;">　　头指针：</span></p><p><span style="font-size: medium;">　　　　a、头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</span></p><p><span style="font-size: medium;">　　　　b、头指针具有标识作用，所以常用头指针冠以链表的名字。</span></p><p><span style="font-size: medium;">　　　　c、无论链表是否为空，头指针均不为空。头指针是链表的必要元素。</span></p><p><span style="font-size: medium;">　　头结点：</span></p><p><span style="font-size: medium;">　　　　a、头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）。</span></p><p><span style="font-size: medium;">　　　　b、有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就同一了。</span></p><p><span style="font-size: medium;">　　　　c、头结点不一定是链表必须元素。</span></p></h1> ",
            "assembleText":"头指针与头结点的异同 　　头指针： 　　　　a、头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。 　　　　b、头指针具有标识作用，所以常用头指针冠以链表的名字。 　　　　c、无论链表是否为空，头指针均不为空。头指针是链表的必要元素。 　　头结点： 　　　　a、头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）。 　　　　b、有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就同一了。 　　　　c、头结点不一定是链表必须元素。",
            "assembleScratchTime":"2019-04-05 13:09:44",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870208,
            "assembleContent":"<h1><p><span style="font-size: medium;">代码实现</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//单链表存储结构</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  typedef struct LNode</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">      ElemType data;   //数据域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">      struct LNode *next; //指针域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">  }LNode,*LinkList;</span></div></div></li></ol></code></pre><p><span style="font-size: medium;">为了提高程序的可阅读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode*,本质上两者是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针，用LNode *定义指向单链表中任意结点的指针变量。</span></p></h1> ",
            "assembleText":"代码实现 //单链表存储结构 typedef struct LNode { ElemType data; //数据域 struct LNode *next; //指针域 }LNode,*LinkList; 为了提高程序的可阅读性，在此对同一结构体指针类型起了两个名称，LinkList与LNode*,本质上两者是等价的。通常习惯上用LinkList定义单链表，强调定义的是某个单链表的头指针，用LNode *定义指向单链表中任意结点的指针变量。",
            "assembleScratchTime":"2019-04-05 13:10:32",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870209,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">1.初始化</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//初始化 </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> Status InitList(LinkList &L)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     //构造一个单链表</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     L=new LNode;  //生成头结点，用头指针L指向头结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     L->next =NULL;  </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     return OK;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 1.初始化 基本算法： //初始化 Status InitList(LinkList &L) { //构造一个单链表 L=new LNode; //生成头结点，用头指针L指向头结点 L->next =NULL; return OK; }",
            "assembleScratchTime":"2019-04-05 13:10:41",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870212,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">2.取值</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//取值</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> Status Get(LinkList L,int i,ElemType &e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    //在带头结点的单链表L中根据序号I获取元素的值，用e返回L中第i个数据元素的值</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p=L->next;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    j=1;//计数器</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    while(p&&j<i)     //顺着链表向后扫描，直到j==i</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        p=p->next;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        ++j;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    if(!p||j>i) return ERROR; //不合法</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    e=p->data;   //找到该结点后获取该结点的数据域</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    return OK;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> </span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 2.取值 基本算法： //取值 Status Get(LinkList L,int i,ElemType &e) { //在带头结点的单链表L中根据序号I获取元素的值，用e返回L中第i个数据元素的值 p=L->next; j=1;//计数器 while(p&&j<i) //顺着链表向后扫描，直到j==i { p=p->next; ++j; } if(!p||j>i) return ERROR; //不合法 e=p->data; //找到该结点后获取该结点的数据域 return OK; }",
            "assembleScratchTime":"2019-04-05 13:11:13",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870213,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">3.查找</span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//查找</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> LNode *Find(LinkList L,ElemType e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     p=L->next; //使p指向首元结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     while(p && p->data!=e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">         p=p->next;  //不符合条件就一直滚下去</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">     return p;   //这里有两种情况，找到的时候返回指针p，如果找不到那么这个p则为null,因为最后一个指向的是null</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;"> }</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 3.查找 基本算法： //查找 LNode *Find(LinkList L,ElemType e) { p=L->next; //使p指向首元结点 while(p && p->data!=e) { p=p->next; //不符合条件就一直滚下去 } return p; //这里有两种情况，找到的时候返回指针p，如果找不到那么这个p则为null,因为最后一个指向的是null }",
            "assembleScratchTime":"2019-04-05 13:12:02",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870216,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">插入</span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//插入</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">Status ListInsert(LinkList &L,int i,ElemType e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">{</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    //在带头结点的单链表L中第i个位置插入值为e的新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p=L;j=0;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    while(p&&(j<i-1))</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        p=p->next;         //查找第i-1个结点，p指向该结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        ++j;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    if(!p||j>i-1) return ERROR;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s=new LNode;   //生成一个新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->data=e;   //将结点*s的数据域置为e</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->next=p->next; //先接尾部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p->next=s;  //再接头部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">}</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 插入   基本算法： //插入 Status ListInsert(LinkList &L,int i,ElemType e) { //在带头结点的单链表L中第i个位置插入值为e的新结点 p=L;j=0; while(p&&(j<i-1)) { p=p->next; //查找第i-1个结点，p指向该结点 ++j; } if(!p||j>i-1) return ERROR; s=new LNode; //生成一个新结点 s->data=e; //将结点*s的数据域置为e s->next=p->next; //先接尾部 p->next=s; //再接头部 }",
            "assembleScratchTime":"2019-04-05 13:12:26",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870219,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">删除</span></p><p> </p><p>基本算法：</p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>//删除</div></div></li><li><div><div></div></div><div><div>Status ListDelete(LinkList &L,int i)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    //删除第i个元素</div></div></li><li><div><div></div></div><div><div>    p=L;j=0;</div></div></li><li><div><div></div></div><div><div>    while((p->next)&&(j<i-1))</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        p=p->next;    //查找i-1个结点</div></div></li><li><div><div></div></div><div><div>        ++j;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div>    if(!(p->next)||(j>i-1)) return ERROR;  //当i>n或i<1时，不符合条件</div></div></li><li><div><div></div></div><div><div>    q=p->next;   //临时保存被删除的地址</div></div></li><li><div><div></div></div><div><div>    p->next=q->next;  //将前驱结点指向后驱</div></div></li><li><div><div></div></div><div><div>    delete q;  //释放删除结点的空间</div></div></li><li><div><div></div></div><div><div>    return OK;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre></h1>  ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 删除   基本算法： //删除 Status ListDelete(LinkList &L,int i) { //删除第i个元素 p=L;j=0; while((p->next)&&(j<i-1)) { p=p->next; //查找i-1个结点 ++j; } if(!(p->next)||(j>i-1)) return ERROR; //当i>n或i<1时，不符合条件 q=p->next; //临时保存被删除的地址 p->next=q->next; //将前驱结点指向后驱 delete q; //释放删除结点的空间 return OK; }",
            "assembleScratchTime":"2019-04-05 13:13:11",
            "facetId":556333,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870348,
            "assembleContent":"<div><strong>不带头结点的单链表：</strong></div><div>1.不带头结点的单链表操作中，除了初始化，头插，尾插，删除，操作与带头结点的单链表有差别外，其它的操作基本上一样。</div><div><br></div><p>2.链表指针直接指向了首元节点，因此在首元节点前插入数据元素或者删除首元节点元素都会改变头指针的值。所以这里要引入二级指针。</p> ",
            "assembleText":"不带头结点的单链表： 1.不带头结点的单链表操作中，除了初始化，头插，尾插，删除，操作与带头结点的单链表有差别外，其它的操作基本上一样。 2.链表指针直接指向了首元节点，因此在首元节点前插入数据元素或者删除首元节点元素都会改变头指针的值。所以这里要引入二级指针。",
            "assembleScratchTime":"2019-04-05 13:54:48",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870349,
            "assembleContent":"<pre><code>typedef struct NNode<br>{<br> int data;<br> struct NNode *next;<br>}NNode,*NList;<br> <br> <br>//链表初始化<br>void InitList(NList *pplist)//NNode*<br>{<br> assert(pplist != NULL);<br> *pplist = NULL;<br>}</code></pre><p><br></p> ",
            "assembleText":"typedef struct NNode {  int data;  struct NNode *next; }NNode,*NList;   //链表初始化 void InitList(NList *pplist)//NNode* {  assert(pplist != NULL);  *pplist = NULL; }",
            "assembleScratchTime":"2019-04-05 13:55:10",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870351,
            "assembleContent":"<pre><code><p>//头插<br>bool Insert_head(NList *pplist,int val)<br>{<br> NNode *p = (NNode *)malloc(sizeof(NNode));<br> p->data = val;<br> p->next = *pplist;<br> *pplist = p;<br> return true;<br>}<br></p></code></pre><p><br></p> ",
            "assembleText":"//头插 bool Insert_head(NList *pplist,int val) { NNode *p = (NNode *)malloc(sizeof(NNode)); p->data = val; p->next = *pplist; *pplist = p; return true; }",
            "assembleScratchTime":"2019-04-05 13:55:23",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870354,
            "assembleContent":"<pre><code><ol><li><div><div>//尾插</div></div></li><li><div><div></div></div><div><div>bool Insert_tail(NList *pplist,int val)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div> NNode *p = (NNode *)malloc(sizeof(NNode));</div></div></li><li><div><div></div></div><div><div> p->data = val;</div></div></li><li><div><div></div></div><div><div> p->next = NULL;</div></div></li><li><div><div></div></div><div><div> if(*pplist == NULL)</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  *pplist = p;</div></div></li><li><div><div></div></div><div><div>  return true;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> NNode *q;</div></div></li><li><div><div></div></div><div><div> for(q=*pplist;q->next!=NULL;q=q->next) ;</div></div></li><li><div><div></div></div><div><div> p->next = q->next; //p->next = NULL;</div></div></li><li><div><div></div></div><div><div> q->next = p;</div></div></li><li><div><div></div></div><div><div> return true;</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div></div></li></ol><p><br>

</p></code></pre><p><br></p> ",
            "assembleText":"//尾插 bool Insert_tail(NList *pplist,int val) {  NNode *p = (NNode *)malloc(sizeof(NNode));  p->data = val;  p->next = NULL;  if(*pplist == NULL)  {   *pplist = p;   return true;  }  NNode *q;  for(q=*pplist;q->next!=NULL;q=q->next) ;  p->next = q->next; //p->next = NULL;  q->next = p;  return true; }",
            "assembleScratchTime":"2019-04-05 13:55:50",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870355,
            "assembleContent":"<pre><code><div>

<ol><li><div><div>//删除</div></div></li><li><div><div></div></div><div><div>bool Delete(NList *pplist,int key)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div> if(*pplist == NULL)链表为空</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  return false;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> NNode *p = *pplist;</div></div></li><li><div><div></div></div><div><div> if(p->data == key)//删除第一个点</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  *pplist = p->next;</div></div></li><li><div><div></div></div><div><div>  free(p);</div></div></li><li><div><div></div></div><div><div>  return true;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div> for(p=*pplist;p->next!=NULL;p=p->next)</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  if(p->next->data == key)</div></div></li><li><div><div></div></div><div><div>  {</div></div></li><li><div><div></div></div><div><div>   NNode *q = p->next;</div></div></li><li><div><div></div></div><div><div>   p->next = q->next;</div></div></li><li><div><div></div></div><div><div>   free(q);</div></div></li><li><div><div></div></div><div><div>   return true;</div></div></li><li><div><div></div></div><div><div>  }</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> return false;</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div></div></li></ol><br>

</div></code></pre> ",
            "assembleText":"//删除 bool Delete(NList *pplist,int key) {  if(*pplist == NULL)链表为空  {   return false;  }  NNode *p = *pplist;  if(p->data == key)//删除第一个点  {   *pplist = p->next;   free(p);   return true;  }    for(p=*pplist;p->next!=NULL;p=p->next)  {   if(p->next->data == key)   {    NNode *q = p->next;    p->next = q->next;    free(q);    return true;   }  }  return false; }",
            "assembleScratchTime":"2019-04-05 13:56:07",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870357,
            "assembleContent":"<p>不带头结点的操作我们一般用在环中，会更灵活。单链表的操作带头结点更方便。  <br></p> ",
            "assembleText":"不带头结点的操作我们一般用在环中，会更灵活。单链表的操作带头结点更方便。  ",
            "assembleScratchTime":"2019-04-05 13:56:23",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870359,
            "assembleContent":"<div>两者区别：</div><div>     1、不带头结点的单链表对于第一个节点的操作与其他节点不一样，需要特殊处理，这增加了程序的复杂性和出现bug的机会，因此，通常</div><div>          在单链表的开始结点之前附设一个头结点。</div><div>     2、带头结点的单链表,初始时一定返回的是指向头结点的地址，所以一定要用二维指针，否则将导致内存访问失败或异常。</div><div>     3、带头结点与不带头结点初始化、插入、删除、输出操作都不样，在遍历输出链表数据时，带头结点的判断条件是while(head->next!=NULL)，</div><div>          而不带头结点是while(head!=NULL)，虽然头指针可以在初始时设定，但是如1所述，对于特殊情况如只有一个节点会出现问题。</div><div>         </div><div> </div> ",
            "assembleText":"两者区别：      1、不带头结点的单链表对于第一个节点的操作与其他节点不一样，需要特殊处理，这增加了程序的复杂性和出现bug的机会，因此，通常           在单链表的开始结点之前附设一个头结点。      2、带头结点的单链表,初始时一定返回的是指向头结点的地址，所以一定要用二维指针，否则将导致内存访问失败或异常。      3、带头结点与不带头结点初始化、插入、删除、输出操作都不样，在遍历输出链表数据时，带头结点的判断条件是while(head->next!=NULL)，           而不带头结点是while(head!=NULL)，虽然头指针可以在初始时设定，但是如1所述，对于特殊情况如只有一个节点会出现问题。            ",
            "assembleScratchTime":"2019-04-05 13:56:59",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/xlf13872135090/article/details/8857632",
            "type":"text"
        },
        {
            "assembleId":2870362,
            "assembleContent":"<div>为什么不带头结点初始化有2种方式，而带头结点只有1种方式呢？</div><div> </div><div>     因为不带头结点声明Node *head 时；C编译器将其自动初始化为NULL，于是根本不需要调用InitList(head)；也即不带头结点的初始化</div><div>是个伪操作。而带头结点的初始化在堆开辟了一段内存，需要修改head指针变量指向的地址(即head的值)，所以要修改head的值，必须传保</div><div>存head变量的地址(即二维指针)。而直接调用CreatList(head);相当于传head变量的值，函数修改的是head的副本，无法真正改变head的值。 </div><div> </div><div>     注：这里可以将head指针看成一个变量(不管它保存的是地址)，就比较好理解了。</div><div>      </div> ",
            "assembleText":"为什么不带头结点初始化有2种方式，而带头结点只有1种方式呢？        因为不带头结点声明Node *head 时；C编译器将其自动初始化为NULL，于是根本不需要调用InitList(head)；也即不带头结点的初始化 是个伪操作。而带头结点的初始化在堆开辟了一段内存，需要修改head指针变量指向的地址(即head的值)，所以要修改head的值，必须传保 存head变量的地址(即二维指针)。而直接调用CreatList(head);相当于传head变量的值，函数修改的是head的副本，无法真正改变head的值。         注：这里可以将head指针看成一个变量(不管它保存的是地址)，就比较好理解了。       ",
            "assembleScratchTime":"2019-04-05 13:57:13",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/xlf13872135090/article/details/8857632",
            "type":"text"
        },
        {
            "assembleId":2870365,
            "assembleContent":"<div>不带头结点初始化</div><div>方式一：</div><div>void InitList(Node **head){</div><div>     *head=NULL;</div><div>}</div><div>调用InitList(&head)；</div><div> </div><div>方式二：</div><div>void InitList(Node *head){</div><div>     head=NULL;</div><div>}</div><div>调用InitList(head)；</div> ",
            "assembleText":"不带头结点初始化 方式一： void InitList(Node **head){      *head=NULL; } 调用InitList(&head)；   方式二： void InitList(Node *head){      head=NULL; } 调用InitList(head)；",
            "assembleScratchTime":"2019-04-05 13:57:39",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/xlf13872135090/article/details/8857632",
            "type":"text"
        },
        {
            "assembleId":2870367,
            "assembleContent":"<div>不带头结点尾插入，第一个节点与其他节点分开操作</div><div>void CreatList(Node  **head){<br>     Node *p,*t;         /*p工作指针,t临时指针*/<br>     int a,i=1;<br>     while(scanf("%d",&a)){<br>          if(a!=0){<br>               t=(Node *)malloc(sizeof(Node));<br>               t->value=a;<br>               if(i==1){<br>                    *head=t;    <br>               }<br>               else{<br>                    p->next=t;<br>               }<br>               p=t;<br>          }<br>          else{    <br>               p->next=NULL;<br>               break;    <br>          }<br>          i++;<br>     }<br>}</div><div>调用CreatList(&head)；</div><p><br></p> ",
            "assembleText":"不带头结点尾插入，第一个节点与其他节点分开操作 void CreatList(Node  **head){      Node *p,*t;         /*p工作指针,t临时指针*/      int a,i=1;      while(scanf("%d",&a)){           if(a!=0){                t=(Node *)malloc(sizeof(Node));                t->value=a;                if(i==1){                     *head=t;                    }                else{                     p->next=t;                }                p=t;           }           else{                    p->next=NULL;                break;               }           i++;      } } 调用CreatList(&head)；",
            "assembleScratchTime":"2019-04-05 13:57:51",
            "facetId":556334,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/xlf13872135090/article/details/8857632",
            "type":"text"
        },
        {
            "assembleId":2870282,
            "assembleContent":"<p>我们需要定义一个结构体用于表示节点信息，故还结构体需要存放节点元素和下一节点地址，即：</p><p>typedef struct LinkNode<br>{<br>    char data;<br>    struct LinkNode* next;<br></p><p>}LinkNode;</p><p>      那么我如果需要的不是char类型的节点元素呢？那么就得修改每次操作的节点元素的数据类型，这使得代码不具有可拓展性，那么就想到了宏定义一个节点元素的数据类型，从而只要修改该宏即可修改该节点元素的数据类型，具体如下：<br></p><p>#define LinkListType char<br>typedef struct LinkNode<br>{<br>    LinkListType data;<br>    struct LinkNode* next;<br></p><p>}LinkNode;</p> ",
            "assembleText":"我们需要定义一个结构体用于表示节点信息，故还结构体需要存放节点元素和下一节点地址，即： typedef struct LinkNode {     char data;     struct LinkNode* next; }LinkNode;       那么我如果需要的不是char类型的节点元素呢？那么就得修改每次操作的节点元素的数据类型，这使得代码不具有可拓展性，那么就想到了宏定义一个节点元素的数据类型，从而只要修改该宏即可修改该节点元素的数据类型，具体如下： #define LinkListType char typedef struct LinkNode {     LinkListType data;     struct LinkNode* next; }LinkNode;",
            "assembleScratchTime":"2019-04-05 13:41:40",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870284,
            "assembleContent":"<p>根据已有的思路，下面具体写头文件linklist.h的代码：</p><p>//头文件只被编译一次<br>#pragma once<br>//自定义元素的类型，方便用户去修改元素的数据类型<br>typedef char LinkListType;<br>//定义一个结构体，用于元素的存放和查找下一个元素所在的位置<br>typedef struct LinkNode<br>{<br>    LinkListType data;<br>    struct LinkNode* next;<br>}LinkNode;   //其中LinkNode是对所定义的结构体的重命名，LinkList*是定义指向该结构<br>体的指针类型<br>//宏定义一个标识符，用于测试函数时打印其对应的函数名，方便了代码的编写<br></p><p>#define HEADER printf("============%s===========\n",__FUNCTION__);</p> ",
            "assembleText":"根据已有的思路，下面具体写头文件linklist.h的代码： //头文件只被编译一次 #pragma once //自定义元素的类型，方便用户去修改元素的数据类型 typedef char LinkListType; //定义一个结构体，用于元素的存放和查找下一个元素所在的位置 typedef struct LinkNode {     LinkListType data;     struct LinkNode* next; }LinkNode;   //其中LinkNode是对所定义的结构体的重命名，LinkList*是定义指向该结构 体的指针类型 //宏定义一个标识符，用于测试函数时打印其对应的函数名，方便了代码的编写 #define HEADER printf("============%s===========\n",__FUNCTION__);",
            "assembleScratchTime":"2019-04-05 13:41:53",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870285,
            "assembleContent":"<p>4.1 链表的初始化     </p><p>#include<stdio.h><br>#include<stdlib.h><br>#include<unistd.h><br>#include"linklist.h"<br>//思路：初始链表中的节点个数为0，故只需要一个头指针指向一个NULL，则表明该链表为空链表<br>void LinkListInit(LinkNode** phead)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    *phead=NULL;<br></p><p>}</p><p>注：为了方便表述，以下的代码不再引用头文件，所需头文件与上述相同。</p> ",
            "assembleText":"4.1 链表的初始化      #include<stdio.h> #include<stdlib.h> #include<unistd.h> #include"linklist.h" //思路：初始链表中的节点个数为0，故只需要一个头指针指向一个NULL，则表明该链表为空链表 void LinkListInit(LinkNode** phead) {     //判断非法输入     if(phead==NULL)         return;     *phead=NULL; } 注：为了方便表述，以下的代码不再引用头文件，所需头文件与上述相同。",
            "assembleScratchTime":"2019-04-05 13:42:05",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870286,
            "assembleContent":"<p>4.2 链表的打印</p><p>//思路：第一个参数接收链表的头指针，第二个参数接收字符串的地址，用于打印时显示关于打印的具体信息</p><p>void LinkListPrintChar(LinkNode* head,const char* msg)<br>{<br>    printf("[%s]\n",msg);<br>    LinkNode* cur=head;<br>    for(cur=head;cur!=NULL;cur=cur->next)<br>    {   <br>        printf("[%p]|[%c] ",cur,cur->data);<br>    }   <br>    printf("\n");<br>}  <br></p> ",
            "assembleText":"4.2 链表的打印 //思路：第一个参数接收链表的头指针，第二个参数接收字符串的地址，用于打印时显示关于打印的具体信息 void LinkListPrintChar(LinkNode* head,const char* msg) {     printf("[%s]\n",msg);     LinkNode* cur=head;     for(cur=head;cur!=NULL;cur=cur->next)     {            printf("[%p]|[%c] ",cur,cur->data);     }        printf("\n"); }  ",
            "assembleScratchTime":"2019-04-05 13:42:15",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870287,
            "assembleContent":"<p>4.3 链表的尾插</p><p>//思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容<br>//创建一个节点，用函数封装起来从而提高代码的可维护性<br>LinkNode* CreateNode(LinkListType value)<br>{<br>    LinkNode* new_node=(LinkNode*)malloc(sizeof(LinkNode));<br>    new_node->data=value;<br>    new_node->next=NULL;<br>    return new_node;<br></p><p>}                                                                                                                                                                                  </p><p>void LinkListPushBack(LinkNode** phead,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //链表为空时，是通过创建新节点并修改头指针的指向<br>    if(*phead==NULL)<br>    {<br>        LinkNode* new_node=CreateNode(value);<br>        *phead=new_node;<br>        return;<br>    }<br>    //链表非空时，通过创建新节点并遍历找到最后一个节点，将其的next进行修改<br>    LinkNode* cur=*phead;<br>    while(cur->next!=NULL)<br>    {<br>        cur=cur->next;<br>    }<br>    cur->next=CreateNode(value);<br>}  <br></p> ",
            "assembleText":"4.3 链表的尾插 //思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容 //创建一个节点，用函数封装起来从而提高代码的可维护性 LinkNode* CreateNode(LinkListType value) {     LinkNode* new_node=(LinkNode*)malloc(sizeof(LinkNode));     new_node->data=value;     new_node->next=NULL;     return new_node; }                                                                                                                                                                                   void LinkListPushBack(LinkNode** phead,LinkListType value) {     //判断非法输入     if(phead==NULL)         return;     //链表为空时，是通过创建新节点并修改头指针的指向     if(*phead==NULL)     {         LinkNode* new_node=CreateNode(value);         *phead=new_node;         return;     }     //链表非空时，通过创建新节点并遍历找到最后一个节点，将其的next进行修改     LinkNode* cur=*phead;     while(cur->next!=NULL)     {         cur=cur->next;     }     cur->next=CreateNode(value); }  ",
            "assembleScratchTime":"2019-04-05 13:42:26",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870294,
            "assembleContent":"<p>链表的尾删</p><p>//销毁一个节点，用函数封装起来从而提高代码的可维护性<br>void DestroyNode(LinkNode* node)<br>{<br>    free(node);<br>}<br>//思路：有三种情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点<br>void LinkListPopBack(LinkNode** phead)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //判断链表是否为空<br>    if(*phead==NULL)<br>        return;<br>    //链表为一个节点时，销毁该节点的空间并修改头指针的指向<br>    if((*phead)->next==NULL)<br>    {<br>        DestroyNode(*phead);<br>        *phead=NULL;<br>    }<br>    //链表至少为两个节点时，遍历链表需要两个指针：存放倒数第二个节点的地址和需要释放的最后一个节点的地址<br>    LinkNode* cur=*phead;  //存放要释放的最后一个节点的地址<br>    LinkNode* pre=NULL;    //存放倒数第二个节点的地址<br>    while(cur->next!=NULL)<br>    {<br>        pre=cur;<br>        cur=cur->next;<br>    }<br>    //当循环结束后，cur就指向最后一个节点，pre就指向倒数第二个节点<br>    pre->next=NULL;<br>    DestroyNode(cur);<br>}</p> ",
            "assembleText":"链表的尾删 //销毁一个节点，用函数封装起来从而提高代码的可维护性 void DestroyNode(LinkNode* node) {     free(node); } //思路：有三种情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点 void LinkListPopBack(LinkNode** phead) {     //判断非法输入     if(phead==NULL)         return;     //判断链表是否为空     if(*phead==NULL)         return;     //链表为一个节点时，销毁该节点的空间并修改头指针的指向     if((*phead)->next==NULL)     {         DestroyNode(*phead);         *phead=NULL;     }     //链表至少为两个节点时，遍历链表需要两个指针：存放倒数第二个节点的地址和需要释放的最后一个节点的地址     LinkNode* cur=*phead;  //存放要释放的最后一个节点的地址     LinkNode* pre=NULL;    //存放倒数第二个节点的地址     while(cur->next!=NULL)     {         pre=cur;         cur=cur->next;     }     //当循环结束后，cur就指向最后一个节点，pre就指向倒数第二个节点     pre->next=NULL;     DestroyNode(cur); }",
            "assembleScratchTime":"2019-04-05 13:43:56",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870295,
            "assembleContent":"<p> 链表的头插</p><p>//思路：创建一个新节点，并修改头结点的指向和新节点的next值<br>void LinkListPushFront(LinkNode** phead,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //空链表与非空链表一致处理<br>    LinkNode* new_node=CreateNode(value);<br>    new_node->next=*phead;<br>    *phead=new_node;<br>}</p> ",
            "assembleText":" 链表的头插 //思路：创建一个新节点，并修改头结点的指向和新节点的next值 void LinkListPushFront(LinkNode** phead,LinkListType value) {     //判断非法输入     if(phead==NULL)         return;     //空链表与非空链表一致处理     LinkNode* new_node=CreateNode(value);     new_node->next=*phead;     *phead=new_node; }",
            "assembleScratchTime":"2019-04-05 13:44:06",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870305,
            "assembleContent":"<p>链表任意位置的插入</p><p>4.7.1任意位置的插入(pos后插)<br>//思路：创建新节点并修改新节点的next值和pos的next值<br>void LinkListInsert(LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入，pos表示一个节点的地址，若pos==NULL则表示不存在这样的节点<br>    if(pos==NULL)<br>        return;<br>    LinkNode* new_node=CreateNode(value);<br>    new_node->next=pos->next;<br>    pos->next=new_node;<br>}</p> ",
            "assembleText":"链表任意位置的插入 4.7.1任意位置的插入(pos后插) //思路：创建新节点并修改新节点的next值和pos的next值 void LinkListInsert(LinkNode* pos,LinkListType value) {     //判断非法输入，pos表示一个节点的地址，若pos==NULL则表示不存在这样的节点     if(pos==NULL)         return;     LinkNode* new_node=CreateNode(value);     new_node->next=pos->next;     pos->next=new_node; }",
            "assembleScratchTime":"2019-04-05 13:45:44",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870306,
            "assembleContent":"<p>任意位置的插入(pos前插)<br>//思路：去遍历链表找到pos的前一个节点，在用LinkListInsert()函数进行插入<br>void LinkListInsertBefore(LinkNode** phead,LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL||pos==NULL)<br>        return;<br>    //链表中只有一个节点时<br>    if(*phead==pos)<br>    {<br>        //要插入的位置为第一个节点，用头插法<br>        LinkListPushFront(phead,value);<br>        return;<br>    }<br>    //链表中至少有两个节点<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->next==pos)<br>            break;<br>    }<br>    //循环结束之后，需要知道是找到pos了还是没找到<br>    if(cur==NULL)<br>        //没找到<br>        return;<br>    //找到pos的前一个节点后使用LinkListInsert()函数<br>    LinkListInsert(cur,value);<br>}  <br></p> ",
            "assembleText":"任意位置的插入(pos前插) //思路：去遍历链表找到pos的前一个节点，在用LinkListInsert()函数进行插入 void LinkListInsertBefore(LinkNode** phead,LinkNode* pos,LinkListType value) {     //判断非法输入     if(phead==NULL||pos==NULL)         return;     //链表中只有一个节点时     if(*phead==pos)     {         //要插入的位置为第一个节点，用头插法         LinkListPushFront(phead,value);         return;     }     //链表中至少有两个节点     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->next==pos)             break;     }     //循环结束之后，需要知道是找到pos了还是没找到     if(cur==NULL)         //没找到         return;     //找到pos的前一个节点后使用LinkListInsert()函数     LinkListInsert(cur,value); }  ",
            "assembleScratchTime":"2019-04-05 13:45:57",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870310,
            "assembleContent":"<p>不允许遍历单链表，在pos位置前插入,使得时间复杂度变为O(1)<br>//思路：先插在pos后面，再修改两个节点的值<br>void LinkListInsertBeforeEx(LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入，当pos==NULL时表示不存在这样的节点<br>    if(pos==NULL)<br>        return;<br>    LinkNode* new_node=CreateNode(pos->data);<br>    new_node->next=pos->next;<br>    pos->next=new_node;<br>    pos->data=value;<br>    //以上四条语句的功能可以用以下两条语句代替<br>    //LinkListInsert(pos,pos->data);<br>    //pos->data=value;<br>}  <br></p> ",
            "assembleText":"不允许遍历单链表，在pos位置前插入,使得时间复杂度变为O(1) //思路：先插在pos后面，再修改两个节点的值 void LinkListInsertBeforeEx(LinkNode* pos,LinkListType value) {     //判断非法输入，当pos==NULL时表示不存在这样的节点     if(pos==NULL)         return;     LinkNode* new_node=CreateNode(pos->data);     new_node->next=pos->next;     pos->next=new_node;     pos->data=value;     //以上四条语句的功能可以用以下两条语句代替     //LinkListInsert(pos,pos->data);     //pos->data=value; }  ",
            "assembleScratchTime":"2019-04-05 13:46:22",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870311,
            "assembleContent":"<p>查找元素在链表中的位置</p><p>//思路：通过遍历查找，返回所查找到的节点地址<br>LinkNode* LinkListFind(LinkNode* head,LinkListType to_find)<br>{<br>    //判断链表是否为空<br>    if(head==NULL)<br>        return NULL;<br>    LinkNode* cur=head;<br>    while(cur!=NULL)<br>    {<br>        if(cur->data==to_find)<br>            return cur;<br>        cur=cur->next;<br>    }<br>    return NULL;<br>}</p> ",
            "assembleText":"查找元素在链表中的位置 //思路：通过遍历查找，返回所查找到的节点地址 LinkNode* LinkListFind(LinkNode* head,LinkListType to_find) {     //判断链表是否为空     if(head==NULL)         return NULL;     LinkNode* cur=head;     while(cur!=NULL)     {         if(cur->data==to_find)             return cur;         cur=cur->next;     }     return NULL; }",
            "assembleScratchTime":"2019-04-05 13:46:32",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870316,
            "assembleContent":"<p>删除指定位置的元素</p><p>//思路：通过遍历销毁pos位置的节点，并修改pos位置的前一个节点的next值<br>void LinkListErase(LinkNode** phead,LinkNode* pos)<br>{<br>    //判断非法输入<br>    if(phead==NULL||pos==NULL)<br>        return;<br>    //空链表时<br>    if(*phead==NULL)<br>        return;<br>    //删除第一个节点时<br>    if((*phead)==pos)<br>    {<br>        //当只有一个节点时<br>        if((*phead)->next==NULL)<br>            {<br>                *phead=NULL;<br>                DestroyNode(pos);<br>                return;<br>            }<br>        else<br>        {<br>            *phead=pos->next;<br>            DestroyNode(pos);<br>        }<br>    }<br>    //链表节点至少为2时，遍历链表，并判断是否找到pos<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->next==pos)<br>            break;<br>    }<br>    //循环结束，判断是否找到pos<br>    if(cur==NULL)  //未找到pos<br>        return;<br>    cur->next=pos->next;<br>    DestroyNode(pos);<br>}</p> ",
            "assembleText":"删除指定位置的元素 //思路：通过遍历销毁pos位置的节点，并修改pos位置的前一个节点的next值 void LinkListErase(LinkNode** phead,LinkNode* pos) {     //判断非法输入     if(phead==NULL||pos==NULL)         return;     //空链表时     if(*phead==NULL)         return;     //删除第一个节点时     if((*phead)==pos)     {         //当只有一个节点时         if((*phead)->next==NULL)             {                 *phead=NULL;                 DestroyNode(pos);                 return;             }         else         {             *phead=pos->next;             DestroyNode(pos);         }     }     //链表节点至少为2时，遍历链表，并判断是否找到pos     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->next==pos)             break;     }     //循环结束，判断是否找到pos     if(cur==NULL)  //未找到pos         return;     cur->next=pos->next;     DestroyNode(pos); }",
            "assembleScratchTime":"2019-04-05 13:47:17",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870318,
            "assembleContent":"<p> 删除指定值的元素（如有重复的元素只删除一个即可）</p><p>//思路：通过LinkListFind()找到对应元素的地址，再使用对任意位置做删除的函数LinkListErase()即可<br>void LinkListRemove(LinkNode** phead,LinkListType to_delete)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    LinkNode* to_find=LinkListFind(*phead,to_delete);<br>    LinkListErase(phead,to_find);<br>}</p> ",
            "assembleText":" 删除指定值的元素（如有重复的元素只删除一个即可） //思路：通过LinkListFind()找到对应元素的地址，再使用对任意位置做删除的函数LinkListErase()即可 void LinkListRemove(LinkNode** phead,LinkListType to_delete) {     //判断非法输入     if(phead==NULL)         return;     LinkNode* to_find=LinkListFind(*phead,to_delete);     LinkListErase(phead,to_find); }",
            "assembleScratchTime":"2019-04-05 13:47:29",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870323,
            "assembleContent":"<p>指定值的所有元素都删除</p><p>//思路1：通过遍历链表以及利用LinkListRemove()删除所有指定的元素<br>void LinkListRemoveAll(LinkNode** phead,LinkListType remove)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->data==remove)<br>            LinkListRemove(phead,remove);<br>    }<br></p><p>}</p><p>//思路2：通过遍历链表以及利用LinkListFind()和LinkListErase()删除所有指定的元素<br>void LinkListRemoveAllEx(LinkNode** phead,LinkListType remove)<br>{<br>    if(phead==NULL)<br>    //非法输入<br>        return;<br>    while(1)<br>    {<br>        LinkNode* pos=LinkListFind(*phead,remove);<br>        if(pos==NULL)<br>            return;<br>        LinkListErase(phead,pos);<br>    }<br></p><p>}</p><p>//思路3:时间复杂度变为O(n)<br>void LinkListRemoveAllExp(LinkNode** phead,LinkListType remove)<br>{<br>    if(phead==NULL)<br>        //非法输入<br>        return;  <br>    //空链表<br>    if(*phead==NULL)<br>        return;<br>    LinkNode* cur=*phead;<br>    //非空链表<br>    while(cur!=NULL)<br>    {<br>        //当删除的元素为第一个元素时<br>        if((*phead)->data==remove)<br>        {<br>            LinkNode* delete=*phead;<br>            *phead=delete->next;<br>            cur=*phead;<br>            DestroyNode(delete);<br>        }<br>        //当删除的元素不是第一个元素，第二个元素存在时   <br>        else if(cur->next!=NULL)<br>        {<br>            //第二个元素存在时，判断第二个元素是否是想要删除的元素<br>            if(cur->next->data==remove)<br>            {<br>                LinkNode* delete=cur->next;<br>                cur->next=delete->next;<br>                DestroyNode(delete);<br>            }<br>            else<br>                cur=cur->next;<br>        }<br>        //删除后，第二个元素不存在<br>        else<br>            return;<br>    }<br>}</p> ",
            "assembleText":"指定值的所有元素都删除 //思路1：通过遍历链表以及利用LinkListRemove()删除所有指定的元素 void LinkListRemoveAll(LinkNode** phead,LinkListType remove) {     //判断非法输入     if(phead==NULL)         return;     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->data==remove)             LinkListRemove(phead,remove);     } } //思路2：通过遍历链表以及利用LinkListFind()和LinkListErase()删除所有指定的元素 void LinkListRemoveAllEx(LinkNode** phead,LinkListType remove) {     if(phead==NULL)     //非法输入         return;     while(1)     {         LinkNode* pos=LinkListFind(*phead,remove);         if(pos==NULL)             return;         LinkListErase(phead,pos);     } } //思路3:时间复杂度变为O(n) void LinkListRemoveAllExp(LinkNode** phead,LinkListType remove) {     if(phead==NULL)         //非法输入         return;       //空链表     if(*phead==NULL)         return;     LinkNode* cur=*phead;     //非空链表     while(cur!=NULL)     {         //当删除的元素为第一个元素时         if((*phead)->data==remove)         {             LinkNode* delete=*phead;             *phead=delete->next;             cur=*phead;             DestroyNode(delete);         }         //当删除的元素不是第一个元素，第二个元素存在时            else if(cur->next!=NULL)         {             //第二个元素存在时，判断第二个元素是否是想要删除的元素             if(cur->next->data==remove)             {                 LinkNode* delete=cur->next;                 cur->next=delete->next;                 DestroyNode(delete);             }             else                 cur=cur->next;         }         //删除后，第二个元素不存在         else             return;     } }",
            "assembleScratchTime":"2019-04-05 13:47:57",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870324,
            "assembleContent":"<p>判定链表为空</p><p>//思路：返回类型为int，链表为空返回1，链表非空返回0<br>int LinkListEmpty(LinkNode* head)<br>{<br>    if(head==NULL)<br>        return 1;<br>    return 0;</p><p>}</p><p>//方法二思路：返回类型为int，链表为空返回1，链表非空返回0<br>int LinkListEmpty(LinkNode* head)<br>{<br></p><p>      return head==NULL?1：0;</p><p>}</p> ",
            "assembleText":"判定链表为空 //思路：返回类型为int，链表为空返回1，链表非空返回0 int LinkListEmpty(LinkNode* head) {     if(head==NULL)         return 1;     return 0; } //方法二思路：返回类型为int，链表为空返回1，链表非空返回0 int LinkListEmpty(LinkNode* head) {       return head==NULL?1：0; }",
            "assembleScratchTime":"2019-04-05 13:48:08",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870326,
            "assembleContent":"<p>求链表的元素个数</p><p>//思路：遍历链表去统计元素个数<br>size_t LinkListSize(LinkNode* head)<br>{<br>    if(head==NULL)<br>        return 0;<br>    size_t size=0;<br>    LinkNode* cur=head;<br>    while(cur!=NULL)<br>    {<br>        size++;<br>        cur=cur->next;<br>    }<br>    return size;<br>}</p> ",
            "assembleText":"求链表的元素个数 //思路：遍历链表去统计元素个数 size_t LinkListSize(LinkNode* head) {     if(head==NULL)         return 0;     size_t size=0;     LinkNode* cur=head;     while(cur!=NULL)     {         size++;         cur=cur->next;     }     return size; }",
            "assembleScratchTime":"2019-04-05 13:48:17",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870327,
            "assembleContent":"<p>逆序打印单链表</p><p>//思路1：分三种情况：1. 链表为空 2.链表只有一个元素 3.链表至少有两个元素<br>void LinkListReservePrintChar(LinkNode* head)<br>{<br>    //判断链表是否为空<br>    if(head==NULL)<br>        return;<br>    //判断链表是否只有一个元素<br>    if(head->next==NULL)<br>    {<br>        printf("[%p][%c] \n",head,head->data);<br>        return;<br>    }<br>    //链表至少有两个元素时<br>    LinkNode* end=NULL;<br>    LinkNode* cur=head->next;<br>    while(cur!=head)<br>    {<br>        for(cur=head;cur!=NULL;cur=cur->next)<br>        {<br>            if((cur->next)==end)<br>            {<br>                printf("[%p][%c] ",cur,cur->data);<br>                end=cur;<br>                break;<br>            }<br>        }<br>    }<br>    //printf("[%p][%c]\n",head,head->data);<br>    printf("\n");<br></p><p>}</p><p>//思路2：上述的方式是非递归的方式，下面将利用递归的思想逆序打印链表元素<br>void LinkListReversePrintCharEx(LinkNode* head)<br>{<br>    LinkNode* cur=head;<br>    if(cur==NULL)<br>        return;<br>    LinkListReversePrintCharEx(cur->next);<br>    printf("%c ",cur->data);<br></p><p>}</p> ",
            "assembleText":"逆序打印单链表 //思路1：分三种情况：1. 链表为空 2.链表只有一个元素 3.链表至少有两个元素 void LinkListReservePrintChar(LinkNode* head) {     //判断链表是否为空     if(head==NULL)         return;     //判断链表是否只有一个元素     if(head->next==NULL)     {         printf("[%p][%c] \n",head,head->data);         return;     }     //链表至少有两个元素时     LinkNode* end=NULL;     LinkNode* cur=head->next;     while(cur!=head)     {         for(cur=head;cur!=NULL;cur=cur->next)         {             if((cur->next)==end)             {                 printf("[%p][%c] ",cur,cur->data);                 end=cur;                 break;             }         }     }     //printf("[%p][%c]\n",head,head->data);     printf("\n"); } //思路2：上述的方式是非递归的方式，下面将利用递归的思想逆序打印链表元素 void LinkListReversePrintCharEx(LinkNode* head) {     LinkNode* cur=head;     if(cur==NULL)         return;     LinkListReversePrintCharEx(cur->next);     printf("%c ",cur->data); }",
            "assembleScratchTime":"2019-04-05 13:48:30",
            "facetId":556398,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870179,
            "assembleContent":"<h2><p><span style="font-size: medium;">链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。</span></p><p><span style="font-size: medium;">节点的数据域也可以成为另一个链表。通过这种手段，我们可以用列表来构建许多链性数据结构；这个实例产生于Lisp编程语言，在Lisp中链表是初级数据结构，并且现在成为了常见的基础编程模式。 有时候，链表用来生成联合数组，在这种情况下我们称之为联合数列。这种情况下用链表会优于其它数据结构，如自平对分查找树（self-balancing binary search trees）甚至是一些小的数据集合。不管怎样，一些时候一个链表在这样一个树中创建一个节点子集，并且以此来更有效率地转换这个集合。</span></p></h2> ",
            "assembleText":"链表用来构建许多其它数据结构，如堆栈，队列和他们的派生。 节点的数据域也可以成为另一个链表。通过这种手段，我们可以用列表来构建许多链性数据结构；这个实例产生于Lisp编程语言，在Lisp中链表是初级数据结构，并且现在成为了常见的基础编程模式。 有时候，链表用来生成联合数组，在这种情况下我们称之为联合数列。这种情况下用链表会优于其它数据结构，如自平对分查找树（self-balancing binary search trees）甚至是一些小的数据集合。不管怎样，一些时候一个链表在这样一个树中创建一个节点子集，并且以此来更有效率地转换这个集合。",
            "assembleScratchTime":"2019-04-05 13:01:39",
            "facetId":556399,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8",
            "type":"text"
        },
        {
            "assembleId":2870244,
            "assembleContent":"<h1><p><span style="font-size: medium;">已知带头结点的单链表L中的结点是按整数值递增排列的，试写一算法，将值为x的结点插入到表L中，使得L仍然递增有序（这里我们将插入和排序用一个函数完成，不用排序和插入两个函数实现） </span></p><pre><code><span style="font-size: medium;">#include <stdio.h><br>#include <stdlib.h><br>#define maxsize 1000<br>typedef struct node<br>{<br>    int data;<br>    struct lnode *next;<br>} LNode,*LinkList;<br> <br>LinkList init_LNode()<br>{<br>    LinkList L;<br>    L=(LinkList)malloc(sizeof(LNode));<br>    L->data=0;<br>    L->next=NULL;<br>    return L;<br>}<br> <br>LinkList insert_linklist(LinkList L,int insert_data)<br>{<br>    LNode *p,*q,*s;<br>    p=L->next;<br>    q=p;<br>    while(p!=NULL&&insert_data<p->data)<br>    {<br>        q=p;//q记录前驱结点<br>        p=p->next;<br>    }<br>    if(p==NULL)//为空代表走到了最后或表开始为空<br>    {<br>        s=(LinkList)malloc(sizeof(LNode));<br>        s->data=insert_data;<br>        s->next=NULL;<br>        q->next=s;<br>    }<br>    else<br>    {<br>        s=(LinkList)malloc(sizeof(LNode));<br>        s->data=insert_data;<br>        s->next=p;<br>        q->next=s;<br>    }<br>    return L;<br>}<br> <br>void output_link(LinkList L)<br>{<br>    LNode *p;<br>    p=L->next;<br>    while(p!=NULL)<br>    {<br>        printf("%d ",p->data);<br>        p=p->next;<br>    }<br>}<br> <br>int main()<br>{<br>    int input_data;<br>    LinkList L=init_LNode();<br>    printf("please input the data for the list,100 represent the end\n");<br>    scanf("%d",&input_data);<br>    while(input_data!=100)<br>    {<br>        L=insert_linklist(L,input_data);<br>        scanf("%d",&input_data);<br>    }<br>    output_link(L);//输入结束，输出该表内容<br>    printf("please input the insert data:");<br>    scanf("%d",&input_data);<br>    L=insert_linklist(L,input_data);<br>    output_link(L);<br>    return 0;<br>}</span></code></pre><p><span style="font-size: medium;"><br></span></p><p><span style="font-size: medium;"> </span></p></h1>  ",
            "assembleText":"已知带头结点的单链表L中的结点是按整数值递增排列的，试写一算法，将值为x的结点插入到表L中，使得L仍然递增有序（这里我们将插入和排序用一个函数完成，不用排序和插入两个函数实现）  #include <stdio.h> #include <stdlib.h> #define maxsize 1000 typedef struct node { int data; struct lnode *next; } LNode,*LinkList; LinkList init_LNode() { LinkList L; L=(LinkList)malloc(sizeof(LNode)); L->data=0; L->next=NULL; return L; } LinkList insert_linklist(LinkList L,int insert_data) { LNode *p,*q,*s; p=L->next; q=p; while(p!=NULL&&insert_data<p->data) { q=p;//q记录前驱结点 p=p->next; } if(p==NULL)//为空代表走到了最后或表开始为空 { s=(LinkList)malloc(sizeof(LNode)); s->data=insert_data; s->next=NULL; q->next=s; } else { s=(LinkList)malloc(sizeof(LNode)); s->data=insert_data; s->next=p; q->next=s; } return L; } void output_link(LinkList L) { LNode *p; p=L->next; while(p!=NULL) { printf("%d ",p->data); p=p->next; } } int main() { int input_data; LinkList L=init_LNode(); printf("please input the data for the list,100 represent the end\n"); scanf("%d",&input_data); while(input_data!=100) { L=insert_linklist(L,input_data); scanf("%d",&input_data); } output_link(L);//输入结束，输出该表内容 printf("please input the insert data:"); scanf("%d",&input_data); L=insert_linklist(L,input_data); output_link(L); return 0; }  ",
            "assembleScratchTime":"2019-04-05 13:23:27",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870331,
            "assembleContent":"<p><strong>求表长</strong> <br>设一个移动工作指针p和一个计数器j，初始时p=L->next，J=0，若p非空，则计数器加1，并将指针下移一个位置，直到达链表尾，算法描述如下：  <br></p><pre><code>int LinkListLen(LinkList L)<br>{<br>//求带头结点的单链表L的长度<br>    LNode *p<br>    int j=0;<br>    p=L->next;//p指向第一个结点<br>    while(p){j++;p=p->next;}//p指向第j个节点<br>    return j;<br>}</code></pre><p><br></p> ",
            "assembleText":"求表长  设一个移动工作指针p和一个计数器j，初始时p=L->next，J=0，若p非空，则计数器加1，并将指针下移一个位置，直到达链表尾，算法描述如下：   int LinkListLen(LinkList L) { //求带头结点的单链表L的长度     LNode *p     int j=0;     p=L->next;//p指向第一个结点     while(p){j++;p=p->next;}//p指向第j个节点     return j; }",
            "assembleScratchTime":"2019-04-05 13:49:22",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870332,
            "assembleContent":"<p><strong>求表长</strong> <br>设一<strong>编写一个将单循环链表逆置的算法</strong> <br></p><pre><code><p>int conrrayCirLinkList(CirLinkList &L){//头插法建立<br>    LNode *p ,*q;<br>    p=->next;<br>    L->next=L;//建立空单循环链表<br>    while(p!=L)<br>    {<br>        q=p;<br>        p=p->next;<br>        q->next=L->next;<br>        L->next=q;<br>    }<br>    return OK;<br>}</p></code></pre><p><br></p> ",
            "assembleText":"求表长  设一编写一个将单循环链表逆置的算法  int conrrayCirLinkList(CirLinkList &L){//头插法建立 LNode *p ,*q; p=->next; L->next=L;//建立空单循环链表 while(p!=L) { q=p; p=p->next; q->next=L->next; L->next=q; } return OK; }",
            "assembleScratchTime":"2019-04-05 13:49:43",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870333,
            "assembleContent":"<p><strong>求</strong><strong>一直有两个带头结点的循环单链表，设计一个算法，用最快速度将这两个表合成一个带头结点的循环单链表。要求时间复杂度O(1),且占用辅助空间最小。</strong><br></p><pre><code><p>

void UnionCirLinkList(CirLinkList &Ls,CirLinkList &Lb){
//La和Lb是带头结点的单循环链表
    LNode *q;
    q=Lb->next;//q指向Lb的头结点
    Lb->next=La->next;//Lb的后继结点为La的头结点
    La->next=q->next;//La的后继结点为原Lb的第一个元素结点
    delete q;//释放原Lb的头结点
    }

</p></code></pre> ",
            "assembleText":"求一直有两个带头结点的循环单链表，设计一个算法，用最快速度将这两个表合成一个带头结点的循环单链表。要求时间复杂度O(1),且占用辅助空间最小。 void UnionCirLinkList(CirLinkList &Ls,CirLinkList &Lb){ //La和Lb是带头结点的单循环链表 LNode *q; q=Lb->next;//q指向Lb的头结点 Lb->next=La->next;//Lb的后继结点为La的头结点 La->next=q->next;//La的后继结点为原Lb的第一个元素结点 delete q;//释放原Lb的头结点 }",
            "assembleScratchTime":"2019-04-05 13:49:59",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870335,
            "assembleContent":"<p>将两个有序表La和Lb归并成一个有序表，要求不能另设新空间。<br></p><pre><code><p>

void mergelist(LinkList &La,LinkList &Lb,LinkList &Lb)
{
LinkList pa,pb,pc;
pa=La->next;pb=Lb->next;
Lc=pc=La;
while(pa&&pb)
{
    if(pa->data<=pb->data)
    {
        pc->next=pa;
        pc=pa;
        pa=pc->next;        
    }
    else
    {
        pc->next=pb;
        pc=pb;
        pb=pb->next;
    }
}
if(!pa)pc->next=pb;
if(!pb)pc->next=pa;
delete Lb;
}


</p></code></pre> ",
            "assembleText":"将两个有序表La和Lb归并成一个有序表，要求不能另设新空间。 void mergelist(LinkList &La,LinkList &Lb,LinkList &Lb) { LinkList pa,pb,pc; pa=La->next;pb=Lb->next; Lc=pc=La; while(pa&&pb) { if(pa->data<=pb->data) { pc->next=pa; pc=pa; pa=pc->next; } else { pc->next=pb; pc=pb; pb=pb->next; } } if(!pa)pc->next=pb; if(!pb)pc->next=pa; delete Lb; }",
            "assembleScratchTime":"2019-04-05 13:50:24",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870337,
            "assembleContent":"<p>一元稀疏多项式相加。   </p><pre><code>typedef struct<br>{<br>    float coef;//系数<br>    int expn;//指数<br>}term,ElemType;<br>typedef struct Lnode<br>{<br>    Elemtype data;<br>    struct Lnode *next;<br>}Lnode,*LinkList</code></pre><p><br></p> ",
            "assembleText":"一元稀疏多项式相加。    typedef struct {     float coef;//系数     int expn;//指数 }term,ElemType; typedef struct Lnode {     Elemtype data;     struct Lnode *next; }Lnode,*LinkList",
            "assembleScratchTime":"2019-04-05 13:50:57",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870339,
            "assembleContent":"<p>设L是带头结点的头指针，试编写算法，按照递增次序输出单链表各节点的数据元素，并释放所占的存储空间。要求不允许使用数组作为辅助空间。 <br><strong>解：</strong> 应对链表进行遍历，每次遍历中查找出整个链表的最小元素，输出并释放头结点所占空间。算法如下：  <br></p><pre><code><p>void deleteMin(LinkList &L)<br>{<br>    LNode *pre,*p,*q;<br>    while(L->next)<br>    {<br>        pre=L;<br>        p=L->next;//p为工作指针<br>        while(p->next)<br>            if(p->next->data < pre->next->data)<br>            {<br>                pre=p;<br>                p=p->next;<br>            }<br>            else<br>                p=p->next;<br>            printf("%d",pre->next->data);//输出元素最小结点的数据<br>            q=pre->next;<br>            pre->next=q->next;<br>            delete (q);//删除元素最小结点<br>    }<br>    delete （L）；//释放头结点<br>}</p></code></pre> ",
            "assembleText":"设L是带头结点的头指针，试编写算法，按照递增次序输出单链表各节点的数据元素，并释放所占的存储空间。要求不允许使用数组作为辅助空间。  解： 应对链表进行遍历，每次遍历中查找出整个链表的最小元素，输出并释放头结点所占空间。算法如下：   void deleteMin(LinkList &L) { LNode *pre,*p,*q; while(L->next) { pre=L; p=L->next;//p为工作指针 while(p->next) if(p->next->data < pre->next->data) { pre=p; p=p->next; } else p=p->next; printf("%d",pre->next->data);//输出元素最小结点的数据 q=pre->next; pre->next=q->next; delete (q);//删除元素最小结点 } delete （L）；//释放头结点 }",
            "assembleScratchTime":"2019-04-05 13:51:17",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870341,
            "assembleContent":"<p>有一个双向链表从第二个结点到表尾递增有序。试编写算法，将第一个结点删除并插入到适当位置，使整个链表递增有序。 <br><strong>解：</strong> 算法如下：  </p><pre><code><p>void insertnode(DuLinkLinst &L)
{
    DuNode *p,*q,*r;
    p=L->next;
    L->next=p->next;
    p->next->prior=L;
    q=L->next;//q为工作指针
    r=L;//r为q的前驱
    while (q&&q->data < p->data)
    {
        r=q;
        q=q->next;
    }
    if(q)
    {
        q->prior->next=p;
        p->prior=q->prior;
        p->next=q;
        q->prior=p;
    }
    else
    {//插在尾部
        p->next=r->next;
        r->next=q;
        p->prior=r;
    }
}

</p></code></pre> ",
            "assembleText":"有一个双向链表从第二个结点到表尾递增有序。试编写算法，将第一个结点删除并插入到适当位置，使整个链表递增有序。  解： 算法如下：   void insertnode(DuLinkLinst &L) { DuNode *p,*q,*r; p=L->next; L->next=p->next; p->next->prior=L; q=L->next;//q为工作指针 r=L;//r为q的前驱 while (q&&q->data < p->data) { r=q; q=q->next; } if(q) { q->prior->next=p; p->prior=q->prior; p->next=q; q->prior=p; } else {//插在尾部 p->next=r->next; r->next=q; p->prior=r; } }",
            "assembleScratchTime":"2019-04-05 13:51:39",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhangli401X/article/details/47209415",
            "type":"text"
        },
        {
            "assembleId":2870344,
            "assembleContent":"<blockquote><p>题目：输入n个数，输出前n-1个数中“和第n个数相等的”数。</p><p>思路：用链表存储输入的数，接着就是链表的相关操作，包括定义结点，声明结点，插入结点。</p></blockquote><p><img src="http://yotta.xjtushilei.com:8090/863579759/1719119275.png" style="max-width:100%;"><img src="http://yotta.xjtushilei.com:8090/863579765/910040035.png" style="max-width: 100%;"><br></p>  ",
            "assembleText":"题目：输入n个数，输出前n-1个数中“和第n个数相等的”数。 思路：用链表存储输入的数，接着就是链表的相关操作，包括定义结点，声明结点，插入结点。",
            "assembleScratchTime":"2019-04-05 13:53:11",
            "facetId":556399,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/lollollol777/article/details/81479256",
            "type":"text"
        },
        {
            "assembleId":2870227,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表头插法和尾插法</span></p><p><span style="font-size: medium;">两种方式的结果是一样的，区别就是前插法是把新的元素插到最前面，代替了首元结点的位置，就是明摆的插队，而后插法是插到最后面，有点类似于队列。而且后插法多了一个用来指向尾结点的尾指针。  </span></p></h1>  ",
            "assembleText":"单链表头插法和尾插法 两种方式的结果是一样的，区别就是前插法是把新的元素插到最前面，代替了首元结点的位置，就是明摆的插队，而后插法是插到最后面，有点类似于队列。而且后插法多了一个用来指向尾结点的尾指针。  ",
            "assembleScratchTime":"2019-04-05 13:14:25",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870256,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表第i个数据插入结点的算法思路：</span></p><p><span style="font-size: medium;">　　　　　　a、声明一结点P指向链表第一个结点，初始化j从1开始。</span></p><p><span style="font-size: medium;">　　　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累计1.</span></p><p><span style="font-size: medium;">　　　　　　c、若到链表末尾p为空，则说明第i个元素不存在。</span></p><p><span style="font-size: medium;">　　　　　　d、否则查找成功，在系统中生成一个空结点s。</span></p><p><span style="font-size: medium;">　　　　　　e、将数据元素e赋值给s->data。</span></p><p><span style="font-size: medium;">　　　　　　f、单链表的拆标准语句s->next=p->;p->next=s。</span></p><p><span style="font-size: medium;">　　　　　　g、返回成功。</span></p></h1> ",
            "assembleText":"单链表第i个数据插入结点的算法思路： 　　　　　　a、声明一结点P指向链表第一个结点，初始化j从1开始。 　　　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累计1. 　　　　　　c、若到链表末尾p为空，则说明第i个元素不存在。 　　　　　　d、否则查找成功，在系统中生成一个空结点s。 　　　　　　e、将数据元素e赋值给s->data。 　　　　　　f、单链表的拆标准语句s->next=p->;p->next=s。 　　　　　　g、返回成功。",
            "assembleScratchTime":"2019-04-05 13:30:23",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870289,
            "assembleContent":"<p> 链表的尾插</p><p>//思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容<br>//创建一个节点，用函数封装起来从而提高代码的可维护性</p> ",
            "assembleText":" 链表的尾插 //思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容 //创建一个节点，用函数封装起来从而提高代码的可维护性",
            "assembleScratchTime":"2019-04-05 13:43:03",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870297,
            "assembleContent":"<p>链表的头插</p><p>//思路：创建一个新节点，并修改头结点的指向和新节点的next值</p> ",
            "assembleText":"链表的头插 //思路：创建一个新节点，并修改头结点的指向和新节点的next值",
            "assembleScratchTime":"2019-04-05 13:44:20",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870417,
            "assembleContent":"<p><em><strong>插入节点：</strong></em></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>s→next=p→next</div></div></li><li><div><div></div></div><div><div>p→next=s<img src="http://yotta.xjtushilei.com:8090/863580300/1525587064.png" style="color: inherit; font-size: inherit; max-width: 100%;"></div></div></li></ol></code></pre>  ",
            "assembleText":"插入节点： s→next=p→next p→next=s",
            "assembleScratchTime":"2019-04-05 14:09:04",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870424,
            "assembleContent":"<p><em><strong>头插法建表</strong></em> <img src="http://yotta.xjtushilei.com:8090/863580347/843686779.png" style="max-width: 100%;"> </p><pre><code>void CreatListF(LinkNode *&L,ElemType a[],int n)<br>{<br>    LinkNode *s;<br>    L=(LinkNode *)malloc(sizeof(LinkNode));<br>    L→next=NULL;  //创建头节点，其next域置为NULL<br>    for(int i=0;i<n;i++)  //循环建立数据节点s<br>    {<br>        s=(LinkNode *)malloc(sizeof(LinkNode));<br>        s→data=a[i];  //创建数据节点s<br>        s→next=L→next;  //将s插入到原首节点之前、头节点之后<br>        L→next=s;<br>    }<br>}</code></pre><p><br></p><p><br></p><p>这个算法的时间复杂度为O（N）。</p><p>链表的节点顺序和逻辑顺序正好相反。</p>  ",
            "assembleText":"头插法建表   void CreatListF(LinkNode *&L,ElemType a[],int n) {     LinkNode *s;     L=(LinkNode *)malloc(sizeof(LinkNode));     L→next=NULL;  //创建头节点，其next域置为NULL     for(int i=0;i<n;i++)  //循环建立数据节点s     {         s=(LinkNode *)malloc(sizeof(LinkNode));         s→data=a[i];  //创建数据节点s         s→next=L→next;  //将s插入到原首节点之前、头节点之后         L→next=s;     } } 这个算法的时间复杂度为O（N）。 链表的节点顺序和逻辑顺序正好相反。",
            "assembleScratchTime":"2019-04-05 14:10:53",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870425,
            "assembleContent":"<p><strong><em>尾插法建表</em></strong></p><br><p><img src="http://yotta.xjtushilei.com:8090/863580376/1809316742.png" style="max-width: 100%;"> </p><pre><code><p>void CreateListR(ListNode *&L,ElemType a[],int n)<br>{<br>    LinkNode *s,*r;<br>    L=(LinkNode *)malloc(sizeof(LinkNode));  //创建头结点<br>    r=L;  //r始终指向尾结点，初始时指向头结点<br>    for(int i=0;i<n;i++)  //循环建立数据结点<br>    {<br>        s=(LinkNode *)malloc(sizeof(LinkNode));  <br>        s→data=a[i];  //创建数据结点s<br>        r→next=s;<br>        r=s;<br>    }<br>    r→next=NULL;  //尾结点的next域置为空<br>}</p></code></pre><p><br></p><p>链表的节点顺序与逻辑次序正好相同。  <br></p>  ",
            "assembleText":"尾插法建表   void CreateListR(ListNode *&L,ElemType a[],int n) { LinkNode *s,*r; L=(LinkNode *)malloc(sizeof(LinkNode)); //创建头结点 r=L; //r始终指向尾结点，初始时指向头结点 for(int i=0;i<n;i++) //循环建立数据结点 { s=(LinkNode *)malloc(sizeof(LinkNode)); s→data=a[i]; //创建数据结点s r→next=s; r=s; } r→next=NULL; //尾结点的next域置为空 } 链表的节点顺序与逻辑次序正好相同。  ",
            "assembleScratchTime":"2019-04-05 14:11:38",
            "facetId":556414,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870255,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表</span></p><p><span style="font-size: medium;">插入节点</span></p><pre></pre><p><span style="font-size: medium;">待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。</span></p><p><span style="font-size: medium;">还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)  </span></p></h1> ",
            "assembleText":"单链表 插入节点 待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。 还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)  ",
            "assembleScratchTime":"2019-04-05 13:29:55",
            "facetId":556415,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870189,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">1. 头插法</span></p><pre></pre><p><span style="font-size: medium;">将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图：</span></p><pre></pre><p><span style="font-size: medium;"><img src="https://images2015.cnblogs.com/blog/941605/201605/941605-20160511074306015-588143690.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
public void headInsert(T item) {
    Node old = first;
    first = new Node();
    first.item = item;
    first.next = old;
    count++;
}</span></pre></h1> ",
            "assembleText":"基本操作 1. 头插法 将新节点插入到当前链表的表头，（头结点之后），插入的顺序与链表中的顺序相反，关键点就是记住旧的表头，生成一个新的放到旧表头前面，如图： 核心代码：
public void headInsert(T item) {
    Node old = first;
    first = new Node();
    first.item = item;
    first.next = old;
    count++;
}",
            "assembleScratchTime":"2019-04-05 13:04:56",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870190,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">2. 尾插法</span></p><pre></pre><p><span style="font-size: medium;">增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图：</span></p><pre></pre><p><span style="font-size: medium;"><img src="https://images2015.cnblogs.com/blog/941605/201605/941605-20160511074357343-1701380488.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
public void tailInsert(T item) {
    Node old = last;
    last = new Node();
    last.item = item;
    last.next = null;
    if (isEmpty()) {
        first = last;
    } else {
        old.next = last;
    }
    count++;
}</span></pre><pre></pre><p><span style="font-size: medium;">节点的插入和删除，要点是<strong>先断后连</strong>，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。</span></p></h1> ",
            "assembleText":"基本操作 2. 尾插法 增加一个尾指针，新节点插到链表的尾部，插入的顺序和链表的顺序一致，如图： 核心代码：
public void tailInsert(T item) {
    Node old = last;
    last = new Node();
    last.item = item;
    last.next = null;
    if (isEmpty()) {
        first = last;
    } else {
        old.next = last;
    }
    count++;
} 节点的插入和删除，要点是先断后连，关键就是不要断链了，以插入为例（把s插入p和q之间），先断意思是先把p->q断了，变成s->q，后连，最后再把p和s连接起来。",
            "assembleScratchTime":"2019-04-05 13:05:17",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870193,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">3. 插入节点</span></p><pre></pre><p><span style="font-size: medium;">待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115G030-6.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码为：
p=getNodeByIndex(i-1);
s.next = p.next;
p.next = s;</span></pre><pre></pre><p><span style="font-size: medium;">还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)：</span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
s.next = p.next;
p.next = s;
temp = p.item;    // 交换内容
p.item = s.item;
s.item = temp;</span></pre></h1> ",
            "assembleText":"基本操作 3. 插入节点 待插入节点为s，一般采用后插法，即先找到插入位置节点的前驱节点，然后插入，时间复杂度O(n)。 核心代码为：
p=getNodeByIndex(i-1);
s.next = p.next;
p.next = s; 还有一种方法是，直接插入到位置的后面（前插法），然后交换两个节点的值，插入的节点到了指定位置，时间复杂度O(1)： 核心代码：
s.next = p.next;
p.next = s;
temp = p.item;    // 交换内容
p.item = s.item;
s.item = temp;",
            "assembleScratchTime":"2019-04-05 13:05:46",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870196,
            "assembleContent":"<h1><p><span style="font-size: medium;">双链表</span></p><p><span style="font-size: medium;">1. 插入节点</span></p><pre></pre><p><span style="font-size: medium;">在p节点后插入s节点，先断后连，先把p和原后继节点的链条给断了，使后继节点只跟s节点有关：</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115H4H-9.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">①s.next = p.next; // 先断了p的后继
②p.next.prior = s; // 在断了p后继的前驱
③s.prior = p; // 让s的前驱指向p
④p.next = s; // p的后继指向s，重新连接上链条，此步必须在①②之后</span></pre></h1> ",
            "assembleText":"双链表 1. 插入节点 在p节点后插入s节点，先断后连，先把p和原后继节点的链条给断了，使后继节点只跟s节点有关： ①s.next = p.next; // 先断了p的后继
②p.next.prior = s; // 在断了p后继的前驱
③s.prior = p; // 让s的前驱指向p
④p.next = s; // p的后继指向s，重新连接上链条，此步必须在①②之后",
            "assembleScratchTime":"2019-04-05 13:06:45",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870217,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">插入</span></p><p><span style="font-size: medium;"> </span></p><p><span style="font-size: medium;">基本算法：</span></p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div><span style="font-size: medium;">//插入</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">Status ListInsert(LinkList &L,int i,ElemType e)</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">{</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    //在带头结点的单链表L中第i个位置插入值为e的新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p=L;j=0;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    while(p&&(j<i-1))</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    {</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        p=p->next;         //查找第i-1个结点，p指向该结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">        ++j;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    }</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    if(!p||j>i-1) return ERROR;</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s=new LNode;   //生成一个新结点</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->data=e;   //将结点*s的数据域置为e</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    s->next=p->next; //先接尾部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">    p->next=s;  //再接头部</span></div></div></li><li><div><div></div></div><div><div><span style="font-size: medium;">}</span></div></div></li></ol></code></pre></h1> ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 插入   基本算法： //插入 Status ListInsert(LinkList &L,int i,ElemType e) { //在带头结点的单链表L中第i个位置插入值为e的新结点 p=L;j=0; while(p&&(j<i-1)) { p=p->next; //查找第i-1个结点，p指向该结点 ++j; } if(!p||j>i-1) return ERROR; s=new LNode; //生成一个新结点 s->data=e; //将结点*s的数据域置为e s->next=p->next; //先接尾部 p->next=s; //再接头部 }",
            "assembleScratchTime":"2019-04-05 13:12:32",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870223,
            "assembleContent":"<h1><p>创建单链表  <br></p><pre><code>//前插法创建单链表<br> void CreateList(LinkList &L,int n)<br> {<br>     //逆次序输出n个元素的值<br>     L=new LNode;<br>     L->next=NULL;<br>     for(i=0;i<n;++i)<br>     {<br>         p=new LNode;  //生成新结点<br>         cin>>p->data;  //输入新结点的数据域内容<br>         p->next=L->next; //将新结点插到头结点之后<br>         L->next=p;<br>     }<br> }</code></pre></h1><h1><p><br></p></h1>  ",
            "assembleText":"创建单链表   //前插法创建单链表  void CreateList(LinkList &L,int n)  {      //逆次序输出n个元素的值      L=new LNode;      L->next=NULL;      for(i=0;i<n;++i)      {          p=new LNode;  //生成新结点          cin>>p->data;  //输入新结点的数据域内容          p->next=L->next; //将新结点插到头结点之后          L->next=p;      }  }",
            "assembleScratchTime":"2019-04-05 13:13:52",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870224,
            "assembleContent":"<h1><p>单链表</p><pre><code>//后插法<br> void CreateList(LinkList &L,int n)<br> {<br>     //正次序输入n个元素的值<br>     L=new LNode;<br>     L->next=NULL;  //建立一个带头结点的空链表<br>     r=L;   //尾指针r指向头结点<br>     for(i=0;i<n;++i)<br>     {<br>         p=new LNode; //生成新结点<br>         cin>>p->data; //输入新结点的数据域内容<br>         p->next=NULL;<br>         r->next=p;  //将新结点插入尾结点之后<br>         r=p;   //改变尾指针，使其指向新的尾结点<br>     }<br> }</code></pre><p><br></p></h1>  ",
            "assembleText":"单链表 //后插法  void CreateList(LinkList &L,int n)  {      //正次序输入n个元素的值      L=new LNode;      L->next=NULL;  //建立一个带头结点的空链表      r=L;   //尾指针r指向头结点      for(i=0;i<n;++i)      {          p=new LNode; //生成新结点          cin>>p->data; //输入新结点的数据域内容          p->next=NULL;          r->next=p;  //将新结点插入尾结点之后          r=p;   //改变尾指针，使其指向新的尾结点      }  }",
            "assembleScratchTime":"2019-04-05 13:14:02",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870290,
            "assembleContent":"<p> 链表的尾插</p><p>//思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容<br>//创建一个节点，用函数封装起来从而提高代码的可维护性<br>LinkNode* CreateNode(LinkListType value)<br>{<br>    LinkNode* new_node=(LinkNode*)malloc(sizeof(LinkNode));<br>    new_node->data=value;<br>    new_node->next=NULL;<br>    return new_node;<br></p><p>}                                                                                                                                                                                  </p><p>void LinkListPushBack(LinkNode** phead,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //链表为空时，是通过创建新节点并修改头指针的指向<br>    if(*phead==NULL)<br>    {<br>        LinkNode* new_node=CreateNode(value);<br>        *phead=new_node;<br>        return;<br>    }<br>    //链表非空时，通过创建新节点并遍历找到最后一个节点，将其的next进行修改<br>    LinkNode* cur=*phead;<br>    while(cur->next!=NULL)<br>    {<br>        cur=cur->next;<br>    }<br>    cur->next=CreateNode(value);<br>}  <br></p> ",
            "assembleText":" 链表的尾插 //思路：创建一个新节点并修改链表中最后一个节点的next值，当为空链表时，则需要修改头指针的内容 //创建一个节点，用函数封装起来从而提高代码的可维护性 LinkNode* CreateNode(LinkListType value) {     LinkNode* new_node=(LinkNode*)malloc(sizeof(LinkNode));     new_node->data=value;     new_node->next=NULL;     return new_node; }                                                                                                                                                                                   void LinkListPushBack(LinkNode** phead,LinkListType value) {     //判断非法输入     if(phead==NULL)         return;     //链表为空时，是通过创建新节点并修改头指针的指向     if(*phead==NULL)     {         LinkNode* new_node=CreateNode(value);         *phead=new_node;         return;     }     //链表非空时，通过创建新节点并遍历找到最后一个节点，将其的next进行修改     LinkNode* cur=*phead;     while(cur->next!=NULL)     {         cur=cur->next;     }     cur->next=CreateNode(value); }  ",
            "assembleScratchTime":"2019-04-05 13:43:21",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870299,
            "assembleContent":"<p>链表的头插</p><p>//思路：创建一个新节点，并修改头结点的指向和新节点的next值<br>void LinkListPushFront(LinkNode** phead,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //空链表与非空链表一致处理<br>    LinkNode* new_node=CreateNode(value);<br>    new_node->next=*phead;<br>    *phead=new_node;<br>}</p> ",
            "assembleText":"链表的头插 //思路：创建一个新节点，并修改头结点的指向和新节点的next值 void LinkListPushFront(LinkNode** phead,LinkListType value) {     //判断非法输入     if(phead==NULL)         return;     //空链表与非空链表一致处理     LinkNode* new_node=CreateNode(value);     new_node->next=*phead;     *phead=new_node; }",
            "assembleScratchTime":"2019-04-05 13:44:31",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870304,
            "assembleContent":"<p>链表任意位置的插入</p><p>4.7.1任意位置的插入(pos后插)<br>//思路：创建新节点并修改新节点的next值和pos的next值<br>void LinkListInsert(LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入，pos表示一个节点的地址，若pos==NULL则表示不存在这样的节点<br>    if(pos==NULL)<br>        return;<br>    LinkNode* new_node=CreateNode(value);<br>    new_node->next=pos->next;<br>    pos->next=new_node;<br>}</p> ",
            "assembleText":"链表任意位置的插入 4.7.1任意位置的插入(pos后插) //思路：创建新节点并修改新节点的next值和pos的next值 void LinkListInsert(LinkNode* pos,LinkListType value) {     //判断非法输入，pos表示一个节点的地址，若pos==NULL则表示不存在这样的节点     if(pos==NULL)         return;     LinkNode* new_node=CreateNode(value);     new_node->next=pos->next;     pos->next=new_node; }",
            "assembleScratchTime":"2019-04-05 13:45:35",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870307,
            "assembleContent":"<p>任意位置的插入(pos前插)<br>//思路：去遍历链表找到pos的前一个节点，在用LinkListInsert()函数进行插入<br>void LinkListInsertBefore(LinkNode** phead,LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入<br>    if(phead==NULL||pos==NULL)<br>        return;<br>    //链表中只有一个节点时<br>    if(*phead==pos)<br>    {<br>        //要插入的位置为第一个节点，用头插法<br>        LinkListPushFront(phead,value);<br>        return;<br>    }<br>    //链表中至少有两个节点<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->next==pos)<br>            break;<br>    }<br>    //循环结束之后，需要知道是找到pos了还是没找到<br>    if(cur==NULL)<br>        //没找到<br>        return;<br>    //找到pos的前一个节点后使用LinkListInsert()函数<br>    LinkListInsert(cur,value);<br>}  <br></p> ",
            "assembleText":"任意位置的插入(pos前插) //思路：去遍历链表找到pos的前一个节点，在用LinkListInsert()函数进行插入 void LinkListInsertBefore(LinkNode** phead,LinkNode* pos,LinkListType value) {     //判断非法输入     if(phead==NULL||pos==NULL)         return;     //链表中只有一个节点时     if(*phead==pos)     {         //要插入的位置为第一个节点，用头插法         LinkListPushFront(phead,value);         return;     }     //链表中至少有两个节点     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->next==pos)             break;     }     //循环结束之后，需要知道是找到pos了还是没找到     if(cur==NULL)         //没找到         return;     //找到pos的前一个节点后使用LinkListInsert()函数     LinkListInsert(cur,value); }  ",
            "assembleScratchTime":"2019-04-05 13:46:06",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870309,
            "assembleContent":"<p>不允许遍历单链表，在pos位置前插入,使得时间复杂度变为O(1)<br>//思路：先插在pos后面，再修改两个节点的值<br>void LinkListInsertBeforeEx(LinkNode* pos,LinkListType value)<br>{<br>    //判断非法输入，当pos==NULL时表示不存在这样的节点<br>    if(pos==NULL)<br>        return;<br>    LinkNode* new_node=CreateNode(pos->data);<br>    new_node->next=pos->next;<br>    pos->next=new_node;<br>    pos->data=value;<br>    //以上四条语句的功能可以用以下两条语句代替<br>    //LinkListInsert(pos,pos->data);<br>    //pos->data=value;<br>}  <br></p> ",
            "assembleText":"不允许遍历单链表，在pos位置前插入,使得时间复杂度变为O(1) //思路：先插在pos后面，再修改两个节点的值 void LinkListInsertBeforeEx(LinkNode* pos,LinkListType value) {     //判断非法输入，当pos==NULL时表示不存在这样的节点     if(pos==NULL)         return;     LinkNode* new_node=CreateNode(pos->data);     new_node->next=pos->next;     pos->next=new_node;     pos->data=value;     //以上四条语句的功能可以用以下两条语句代替     //LinkListInsert(pos,pos->data);     //pos->data=value; }  ",
            "assembleScratchTime":"2019-04-05 13:46:15",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870352,
            "assembleContent":"<pre><code><p>//头插<br>bool Insert_head(NList *pplist,int val)<br>{<br> NNode *p = (NNode *)malloc(sizeof(NNode));<br> p->data = val;<br> p->next = *pplist;<br> *pplist = p;<br> return true;<br>}<br></p></code></pre><p><br></p> ",
            "assembleText":"//头插 bool Insert_head(NList *pplist,int val) { NNode *p = (NNode *)malloc(sizeof(NNode)); p->data = val; p->next = *pplist; *pplist = p; return true; }",
            "assembleScratchTime":"2019-04-05 13:55:30",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870353,
            "assembleContent":"<pre><code><ol><li><div><div>//尾插</div></div></li><li><div><div></div></div><div><div>bool Insert_tail(NList *pplist,int val)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div> NNode *p = (NNode *)malloc(sizeof(NNode));</div></div></li><li><div><div></div></div><div><div> p->data = val;</div></div></li><li><div><div></div></div><div><div> p->next = NULL;</div></div></li><li><div><div></div></div><div><div> if(*pplist == NULL)</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  *pplist = p;</div></div></li><li><div><div></div></div><div><div>  return true;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> NNode *q;</div></div></li><li><div><div></div></div><div><div> for(q=*pplist;q->next!=NULL;q=q->next) ;</div></div></li><li><div><div></div></div><div><div> p->next = q->next; //p->next = NULL;</div></div></li><li><div><div></div></div><div><div> q->next = p;</div></div></li><li><div><div></div></div><div><div> return true;</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div></div></li></ol><p><br>

</p></code></pre><p><br></p> ",
            "assembleText":"//尾插 bool Insert_tail(NList *pplist,int val) {  NNode *p = (NNode *)malloc(sizeof(NNode));  p->data = val;  p->next = NULL;  if(*pplist == NULL)  {   *pplist = p;   return true;  }  NNode *q;  for(q=*pplist;q->next!=NULL;q=q->next) ;  p->next = q->next; //p->next = NULL;  q->next = p;  return true; }",
            "assembleScratchTime":"2019-04-05 13:55:44",
            "facetId":556416,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870197,
            "assembleContent":"<h1><p><span style="font-size: medium;">双链表</span></p><p><span style="font-size: medium;">2. 删除节点</span></p><pre></pre><p><span style="font-size: medium;">删除节点p的后继节点q，也是先断后连，把q和其后继节点的关系，转让给p即可：</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115LW1-10.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">①p.next = q.next; // 先断了q的后继
②q.next.prior = p; // 在断了q后继的前驱

删除节点q的前驱节点p，把p和去前驱节点的关系转让给q即可：
①q = p.prior.next; // 把p前驱节点的后继改成q
②q.prior = p.prior; // 把q的前驱节点改成p的前驱节点</span></pre></h1> ",
            "assembleText":"双链表 2. 删除节点 删除节点p的后继节点q，也是先断后连，把q和其后继节点的关系，转让给p即可： ①p.next = q.next; // 先断了q的后继
②q.next.prior = p; // 在断了q后继的前驱

删除节点q的前驱节点p，把p和去前驱节点的关系转让给q即可：
①q = p.prior.next; // 把p前驱节点的后继改成q
②q.prior = p.prior; // 把q的前驱节点改成p的前驱节点",
            "assembleScratchTime":"2019-04-05 13:07:07",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870218,
            "assembleContent":"<h1><p><span style="font-size: medium;">例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。</span></p><p><span style="font-size: medium;">删除</span></p><p> </p><p>基本算法：</p><pre name="code" onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>//删除</div></div></li><li><div><div></div></div><div><div>Status ListDelete(LinkList &L,int i)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    //删除第i个元素</div></div></li><li><div><div></div></div><div><div>    p=L;j=0;</div></div></li><li><div><div></div></div><div><div>    while((p->next)&&(j<i-1))</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        p=p->next;    //查找i-1个结点</div></div></li><li><div><div></div></div><div><div>        ++j;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div>    if(!(p->next)||(j>i-1)) return ERROR;  //当i>n或i<1时，不符合条件</div></div></li><li><div><div></div></div><div><div>    q=p->next;   //临时保存被删除的地址</div></div></li><li><div><div></div></div><div><div>    p->next=q->next;  //将前驱结点指向后驱</div></div></li><li><div><div></div></div><div><div>    delete q;  //释放删除结点的空间</div></div></li><li><div><div></div></div><div><div>    return OK;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre></h1>  ",
            "assembleText":"例如，定义LinkList L,则L为单链表的头指针，若定义LNode *p ,则p为指向单链表中某个结点的指针，用*p代表该结点。 删除   基本算法： //删除 Status ListDelete(LinkList &L,int i) { //删除第i个元素 p=L;j=0; while((p->next)&&(j<i-1)) { p=p->next; //查找i-1个结点 ++j; } if(!(p->next)||(j>i-1)) return ERROR; //当i>n或i<1时，不符合条件 q=p->next; //临时保存被删除的地址 p->next=q->next; //将前驱结点指向后驱 delete q; //释放删除结点的空间 return OK; }",
            "assembleScratchTime":"2019-04-05 13:13:06",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_38378384/article/details/80430396",
            "type":"text"
        },
        {
            "assembleId":2870250,
            "assembleContent":"<h1><p><span style="font-size: medium;">删除一链表中的重复结点 </span></p><pre><code>typedef struct lnode<br>{<br>    int data;<br>    struct lnode *next;<br>}LNode,*LinkList;<br> <br>void put_linklist(LinkList *L)<br>{<br>    LinkList *q,*p,*r;<br>    p=L->next;//p指向第一个数据结点<br>    while(p->next)//p作为基准比较<br>    {<br>        q=p;<br>        if(p==NULL)return;<br>        while(q->next)//q作为待删前驱结点  <br>        {<br>            if(q->next->data==p->data)<br>            {<br>                r=q->next;//r为待删结点<br>                q->next=r->next;<br>                free(r);<br>            }<br>            q=q->next;<br>        }<br>        p=p->next;<br>    }<br>}</code></pre><p><br></p><p> </p></h1>  ",
            "assembleText":"删除一链表中的重复结点  typedef struct lnode {     int data;     struct lnode *next; }LNode,*LinkList;  void put_linklist(LinkList *L) {     LinkList *q,*p,*r;     p=L->next;//p指向第一个数据结点     while(p->next)//p作为基准比较     {         q=p;         if(p==NULL)return;         while(q->next)//q作为待删前驱结点          {             if(q->next->data==p->data)             {                 r=q->next;//r为待删结点                 q->next=r->next;                 free(r);             }             q=q->next;         }         p=p->next;     } }  ",
            "assembleScratchTime":"2019-04-05 13:26:36",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/weixin_42107106/article/details/82817061",
            "type":"text"
        },
        {
            "assembleId":2870263,
            "assembleContent":"<h1><p><span style="font-size: medium;">基本操作</span></p><pre></pre><p><span style="font-size: medium;">4. 删除节点</span></p><pre></pre><p><span style="font-size: medium;">待删除节点为q，也是先找到前驱节点，修改指针域即可，时间复杂度O(n)。</span></p><pre></pre><p><span style="font-size: medium;"><img src="http://www.bkjia.com/uploads/allimg/160511/16115G020-7.png" alt=""></span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
P = getNodeByIndex(i-1);
q = p.next;
p.next = q.next;
q = null;</span></pre><pre></pre><p><span style="font-size: medium;">删除节点也能直接删除其后继节点，然后将后继节点的内容赋给自己即可，时间复杂度为O(1)：</span></p><pre></pre><pre><span style="font-size: medium;">核心代码：
q = p.next;
p.item = p.next.item;
p.next = q.next;
q = null;</span></pre></h1> ",
            "assembleText":"基本操作 4. 删除节点 待删除节点为q，也是先找到前驱节点，修改指针域即可，时间复杂度O(n)。 核心代码：
P = getNodeByIndex(i-1);
q = p.next;
p.next = q.next;
q = null; 删除节点也能直接删除其后继节点，然后将后继节点的内容赋给自己即可，时间复杂度为O(1)： 核心代码：
q = p.next;
p.item = p.next.item;
p.next = q.next;
q = null;",
            "assembleScratchTime":"2019-04-05 13:35:03",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        },
        {
            "assembleId":2870293,
            "assembleContent":"<p>链表的尾删</p><p>//销毁一个节点，用函数封装起来从而提高代码的可维护性<br>void DestroyNode(LinkNode* node)<br>{<br>    free(node);<br>}<br>//思路：有三种情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点<br>void LinkListPopBack(LinkNode** phead)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //判断链表是否为空<br>    if(*phead==NULL)<br>        return;<br>    //链表为一个节点时，销毁该节点的空间并修改头指针的指向<br>    if((*phead)->next==NULL)<br>    {<br>        DestroyNode(*phead);<br>        *phead=NULL;<br>    }<br>    //链表至少为两个节点时，遍历链表需要两个指针：存放倒数第二个节点的地址和需要释放的最后一个节点的地址<br>    LinkNode* cur=*phead;  //存放要释放的最后一个节点的地址<br>    LinkNode* pre=NULL;    //存放倒数第二个节点的地址<br>    while(cur->next!=NULL)<br>    {<br>        pre=cur;<br>        cur=cur->next;<br>    }<br>    //当循环结束后，cur就指向最后一个节点，pre就指向倒数第二个节点<br>    pre->next=NULL;<br>    DestroyNode(cur);<br>}</p> ",
            "assembleText":"链表的尾删 //销毁一个节点，用函数封装起来从而提高代码的可维护性 void DestroyNode(LinkNode* node) {     free(node); } //思路：有三种情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点 void LinkListPopBack(LinkNode** phead) {     //判断非法输入     if(phead==NULL)         return;     //判断链表是否为空     if(*phead==NULL)         return;     //链表为一个节点时，销毁该节点的空间并修改头指针的指向     if((*phead)->next==NULL)     {         DestroyNode(*phead);         *phead=NULL;     }     //链表至少为两个节点时，遍历链表需要两个指针：存放倒数第二个节点的地址和需要释放的最后一个节点的地址     LinkNode* cur=*phead;  //存放要释放的最后一个节点的地址     LinkNode* pre=NULL;    //存放倒数第二个节点的地址     while(cur->next!=NULL)     {         pre=cur;         cur=cur->next;     }     //当循环结束后，cur就指向最后一个节点，pre就指向倒数第二个节点     pre->next=NULL;     DestroyNode(cur); }",
            "assembleScratchTime":"2019-04-05 13:43:49",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870303,
            "assembleContent":"<p>链表的头删</p><p>//思路：分情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点<br>void LinkListPopFront(LinkNode** phead)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    //判断链表是否为空<br>    if(*phead==NULL)<br>        return;<br>    //链表只有一个节点时，直接释放第一个节点的空间并修改头指针的指向<br>    if((*phead)->next==NULL)<br>    {<br>        DestroyNode(*phead);<br>        *phead=NULL;<br>        return;<br>    }<br>    //链表至少有两个节点时，将头指针指向第二个节点位置，释放第一个节点空间<br>    LinkNode* freenode=*phead;<br>    DestroyNode(freenode);<br>    *phead=(*phead)->next;<br>    //也可以将2.3情况一并处理<br>}</p> ",
            "assembleText":"链表的头删 //思路：分情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点 void LinkListPopFront(LinkNode** phead) {     //判断非法输入     if(phead==NULL)         return;     //判断链表是否为空     if(*phead==NULL)         return;     //链表只有一个节点时，直接释放第一个节点的空间并修改头指针的指向     if((*phead)->next==NULL)     {         DestroyNode(*phead);         *phead=NULL;         return;     }     //链表至少有两个节点时，将头指针指向第二个节点位置，释放第一个节点空间     LinkNode* freenode=*phead;     DestroyNode(freenode);     *phead=(*phead)->next;     //也可以将2.3情况一并处理 }",
            "assembleScratchTime":"2019-04-05 13:45:16",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870315,
            "assembleContent":"<p>删除指定位置的元素</p><p>//思路：通过遍历销毁pos位置的节点，并修改pos位置的前一个节点的next值<br>void LinkListErase(LinkNode** phead,LinkNode* pos)<br>{<br>    //判断非法输入<br>    if(phead==NULL||pos==NULL)<br>        return;<br>    //空链表时<br>    if(*phead==NULL)<br>        return;<br>    //删除第一个节点时<br>    if((*phead)==pos)<br>    {<br>        //当只有一个节点时<br>        if((*phead)->next==NULL)<br>            {<br>                *phead=NULL;<br>                DestroyNode(pos);<br>                return;<br>            }<br>        else<br>        {<br>            *phead=pos->next;<br>            DestroyNode(pos);<br>        }<br>    }<br>    //链表节点至少为2时，遍历链表，并判断是否找到pos<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->next==pos)<br>            break;<br>    }<br>    //循环结束，判断是否找到pos<br>    if(cur==NULL)  //未找到pos<br>        return;<br>    cur->next=pos->next;<br>    DestroyNode(pos);<br>}</p> ",
            "assembleText":"删除指定位置的元素 //思路：通过遍历销毁pos位置的节点，并修改pos位置的前一个节点的next值 void LinkListErase(LinkNode** phead,LinkNode* pos) {     //判断非法输入     if(phead==NULL||pos==NULL)         return;     //空链表时     if(*phead==NULL)         return;     //删除第一个节点时     if((*phead)==pos)     {         //当只有一个节点时         if((*phead)->next==NULL)             {                 *phead=NULL;                 DestroyNode(pos);                 return;             }         else         {             *phead=pos->next;             DestroyNode(pos);         }     }     //链表节点至少为2时，遍历链表，并判断是否找到pos     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->next==pos)             break;     }     //循环结束，判断是否找到pos     if(cur==NULL)  //未找到pos         return;     cur->next=pos->next;     DestroyNode(pos); }",
            "assembleScratchTime":"2019-04-05 13:47:13",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870319,
            "assembleContent":"<p> 删除指定值的元素（如有重复的元素只删除一个即可）</p><p>//思路：通过LinkListFind()找到对应元素的地址，再使用对任意位置做删除的函数LinkListErase()即可<br>void LinkListRemove(LinkNode** phead,LinkListType to_delete)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    LinkNode* to_find=LinkListFind(*phead,to_delete);<br>    LinkListErase(phead,to_find);<br>}</p> ",
            "assembleText":" 删除指定值的元素（如有重复的元素只删除一个即可） //思路：通过LinkListFind()找到对应元素的地址，再使用对任意位置做删除的函数LinkListErase()即可 void LinkListRemove(LinkNode** phead,LinkListType to_delete) {     //判断非法输入     if(phead==NULL)         return;     LinkNode* to_find=LinkListFind(*phead,to_delete);     LinkListErase(phead,to_find); }",
            "assembleScratchTime":"2019-04-05 13:47:34",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870321,
            "assembleContent":"<p>指定值的所有元素都删除</p><p>//思路1：通过遍历链表以及利用LinkListRemove()删除所有指定的元素<br>void LinkListRemoveAll(LinkNode** phead,LinkListType remove)<br>{<br>    //判断非法输入<br>    if(phead==NULL)<br>        return;<br>    LinkNode* cur=*phead;<br>    for(cur=*phead;cur!=NULL;cur=cur->next)<br>    {<br>        if(cur->data==remove)<br>            LinkListRemove(phead,remove);<br>    }<br></p><p>}</p><p>//思路2：通过遍历链表以及利用LinkListFind()和LinkListErase()删除所有指定的元素<br>void LinkListRemoveAllEx(LinkNode** phead,LinkListType remove)<br>{<br>    if(phead==NULL)<br>    //非法输入<br>        return;<br>    while(1)<br>    {<br>        LinkNode* pos=LinkListFind(*phead,remove);<br>        if(pos==NULL)<br>            return;<br>        LinkListErase(phead,pos);<br>    }<br></p><p>}</p><p>//思路3:时间复杂度变为O(n)<br>void LinkListRemoveAllExp(LinkNode** phead,LinkListType remove)<br>{<br>    if(phead==NULL)<br>        //非法输入<br>        return;  <br>    //空链表<br>    if(*phead==NULL)<br>        return;<br>    LinkNode* cur=*phead;<br>    //非空链表<br>    while(cur!=NULL)<br>    {<br>        //当删除的元素为第一个元素时<br>        if((*phead)->data==remove)<br>        {<br>            LinkNode* delete=*phead;<br>            *phead=delete->next;<br>            cur=*phead;<br>            DestroyNode(delete);<br>        }<br>        //当删除的元素不是第一个元素，第二个元素存在时   <br>        else if(cur->next!=NULL)<br>        {<br>            //第二个元素存在时，判断第二个元素是否是想要删除的元素<br>            if(cur->next->data==remove)<br>            {<br>                LinkNode* delete=cur->next;<br>                cur->next=delete->next;<br>                DestroyNode(delete);<br>            }<br>            else<br>                cur=cur->next;<br>        }<br>        //删除后，第二个元素不存在<br>        else<br>            return;<br>    }<br>}</p> ",
            "assembleText":"指定值的所有元素都删除 //思路1：通过遍历链表以及利用LinkListRemove()删除所有指定的元素 void LinkListRemoveAll(LinkNode** phead,LinkListType remove) {     //判断非法输入     if(phead==NULL)         return;     LinkNode* cur=*phead;     for(cur=*phead;cur!=NULL;cur=cur->next)     {         if(cur->data==remove)             LinkListRemove(phead,remove);     } } //思路2：通过遍历链表以及利用LinkListFind()和LinkListErase()删除所有指定的元素 void LinkListRemoveAllEx(LinkNode** phead,LinkListType remove) {     if(phead==NULL)     //非法输入         return;     while(1)     {         LinkNode* pos=LinkListFind(*phead,remove);         if(pos==NULL)             return;         LinkListErase(phead,pos);     } } //思路3:时间复杂度变为O(n) void LinkListRemoveAllExp(LinkNode** phead,LinkListType remove) {     if(phead==NULL)         //非法输入         return;       //空链表     if(*phead==NULL)         return;     LinkNode* cur=*phead;     //非空链表     while(cur!=NULL)     {         //当删除的元素为第一个元素时         if((*phead)->data==remove)         {             LinkNode* delete=*phead;             *phead=delete->next;             cur=*phead;             DestroyNode(delete);         }         //当删除的元素不是第一个元素，第二个元素存在时            else if(cur->next!=NULL)         {             //第二个元素存在时，判断第二个元素是否是想要删除的元素             if(cur->next->data==remove)             {                 LinkNode* delete=cur->next;                 cur->next=delete->next;                 DestroyNode(delete);             }             else                 cur=cur->next;         }         //删除后，第二个元素不存在         else             return;     } }",
            "assembleScratchTime":"2019-04-05 13:47:51",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870356,
            "assembleContent":"<pre><code><div>

<ol><li><div><div>//删除</div></div></li><li><div><div></div></div><div><div>bool Delete(NList *pplist,int key)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div> if(*pplist == NULL)链表为空</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  return false;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> NNode *p = *pplist;</div></div></li><li><div><div></div></div><div><div> if(p->data == key)//删除第一个点</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  *pplist = p->next;</div></div></li><li><div><div></div></div><div><div>  free(p);</div></div></li><li><div><div></div></div><div><div>  return true;</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div> for(p=*pplist;p->next!=NULL;p=p->next)</div></div></li><li><div><div></div></div><div><div> {</div></div></li><li><div><div></div></div><div><div>  if(p->next->data == key)</div></div></li><li><div><div></div></div><div><div>  {</div></div></li><li><div><div></div></div><div><div>   NNode *q = p->next;</div></div></li><li><div><div></div></div><div><div>   p->next = q->next;</div></div></li><li><div><div></div></div><div><div>   free(q);</div></div></li><li><div><div></div></div><div><div>   return true;</div></div></li><li><div><div></div></div><div><div>  }</div></div></li><li><div><div></div></div><div><div> }</div></div></li><li><div><div></div></div><div><div> return false;</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div></div></li></ol><br>

</div></code></pre> ",
            "assembleText":"//删除 bool Delete(NList *pplist,int key) {  if(*pplist == NULL)链表为空  {   return false;  }  NNode *p = *pplist;  if(p->data == key)//删除第一个点  {   *pplist = p->next;   free(p);   return true;  }    for(p=*pplist;p->next!=NULL;p=p->next)  {   if(p->next->data == key)   {    NNode *q = p->next;    p->next = q->next;    free(q);    return true;   }  }  return false; }",
            "assembleScratchTime":"2019-04-05 13:56:12",
            "facetId":556417,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_40657299/article/details/78441330",
            "type":"text"
        },
        {
            "assembleId":2870257,
            "assembleContent":"<h1><p><span style="font-size: medium;">单链表第i个数据删除结点的算法思路：</span></p><p><span style="font-size: medium;">　　　　　　a、声明一结点p指向链表第一个结点，初始化j从1开始。</span></p><p><span style="font-size: medium;">　　　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1。</span></p><p><span style="font-size: medium;">　　　　　　c、若到链表末尾p为空，则说明第i个元素不存在。</span></p><p><span style="font-size: medium;">　　　　　　d、否则查找成功，将欲删除的结点p->next赋值给q。</span></p><p><span style="font-size: medium;">　　　　　　e、单链表的删除标准语句p->next=q->next。</span></p><p><span style="font-size: medium;">　　　　　　f、将q结点中的数据赋值给e，作为返回。</span></p><p><span style="font-size: medium;">　　　　　　g、释放q结点。</span></p><p><span style="font-size: medium;">　　　　　　h、返回成功。</span></p></h1> ",
            "assembleText":"单链表第i个数据删除结点的算法思路： 　　　　　　a、声明一结点p指向链表第一个结点，初始化j从1开始。 　　　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1。 　　　　　　c、若到链表末尾p为空，则说明第i个元素不存在。 　　　　　　d、否则查找成功，将欲删除的结点p->next赋值给q。 　　　　　　e、单链表的删除标准语句p->next=q->next。 　　　　　　f、将q结点中的数据赋值给e，作为返回。 　　　　　　g、释放q结点。 　　　　　　h、返回成功。",
            "assembleScratchTime":"2019-04-05 13:30:47",
            "facetId":556418,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870302,
            "assembleContent":"<p>链表的头删</p><p>//思路：分情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点</p><p>//链表只有一个节点时，直接释放第一个节点的空间并修改头指针的指向  <br></p><p>//链表至少有两个节点时，将头指针指向第二个节点位置，释放第一个节点空间  <br></p> ",
            "assembleText":"链表的头删 //思路：分情况处理：1.链表为空 2.链表只有一个节点 3.链表至少有两个节点 //链表只有一个节点时，直接释放第一个节点的空间并修改头指针的指向   //链表至少有两个节点时，将头指针指向第二个节点位置，释放第一个节点空间  ",
            "assembleScratchTime":"2019-04-05 13:45:09",
            "facetId":556418,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870421,
            "assembleContent":"<p><strong><em>删除节点：</em></strong></p><p>p→next=p→next→next  <strong><em><br></em></strong></p><p><img src="http://yotta.xjtushilei.com:8090/863580320/1656839956.png" style="max-width:100%;"></p>  ",
            "assembleText":"删除节点： p→next=p→next→next  ",
            "assembleScratchTime":"2019-04-05 14:10:02",
            "facetId":556418,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/qq_41903671/article/details/83047219",
            "type":"text"
        },
        {
            "assembleId":2870254,
            "assembleContent":"<p>手动输入一个<a href="https://www.baidu.com/s?wd=%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank">线性链表</a>，然后通过Treserve( Sqlist &L,visit())遍历该线性表中的每个元素，并输出。 </p><pre><code>#include <stdio.h><br>#include <stdlib.h><br>#include <malloc.h><br>typedef char ElemType;<br>typedef struct Node<br>{<br>ElemType data;<br>struct Node *next;<br>}Node,*Sqlist;<br>void IniList(Sqlist *L) /*初始化*/<br>{<br>*L=(Sqlist)malloc(sizeof(Node));<br>(*L)->next=*L;<br>}<br>void Create_cLinkList(Sqlist L) /*尾插法建立链表*/<br>{<br>Node *s;<br>char c;<br>int flag=1;<br>L->data=NULL;<br>while(flag)<br>{<br>c=getchar();<br>if(c!='$')<br>{<br>s=(Node *)malloc(sizeof(Node));<br>s->data=c;<br>s->next=L->next;<br>L->next=s;<br>}<br>else<br>flag=0;<br>}<br>}<br>void visit(Node *p)<br>{<br>printf("%c",p->data);<br>}<br>void Treserve( Sqlist &L,void (*visit)(Node *p))</code></pre><p><br></p><p> </p> ",
            "assembleText":"手动输入一个线性链表，然后通过Treserve( Sqlist &L,visit())遍历该线性表中的每个元素，并输出。  #include <stdio.h> #include <stdlib.h> #include <malloc.h> typedef char ElemType; typedef struct Node { ElemType data; struct Node *next; }Node,*Sqlist; void IniList(Sqlist *L) /*初始化*/ { *L=(Sqlist)malloc(sizeof(Node)); (*L)->next=*L; } void Create_cLinkList(Sqlist L) /*尾插法建立链表*/ { Node *s; char c; int flag=1; L->data=NULL; while(flag) { c=getchar(); if(c!='$') { s=(Node *)malloc(sizeof(Node)); s->data=c; s->next=L->next; L->next=s; } else flag=0; } } void visit(Node *p) { printf("%c",p->data); } void Treserve( Sqlist &L,void (*visit)(Node *p))  ",
            "assembleScratchTime":"2019-04-05 13:28:58",
            "facetId":556419,
            "sourceId":3,
            "domainId":413,
            "url":"https://zhidao.baidu.com/question/458090259.html",
            "type":"text"
        },
        {
            "assembleId":2870266,
            "assembleContent":"<h1><pre>package com.zby.queue;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * 
 * @author zby
 * @date 2018年9月30日
 * @Description 测试【顺序存储结构的线性表】和【链式存储结构的线性表】的【迭代遍历】和【索引遍历】效率，学会RandomAccess接口的作用
 */
public class ListPK {
    // 遍历次数
    public static final int TIMES = 1000000;
    // 线性表初始化大小
    public static final int LIST_SIZE = 1000;

    public static void main(String[] args) {
        List<String> arrayList = new ArrayList<String>();
        fillList(arrayList);
        List<String> linkedList = new LinkedList<String>();
        fillList(linkedList);
        iterator(arrayList, "顺序存储结构的线性表");
        index(arrayList, "顺序存储结构的线性表");
        iterator(linkedList, "链式存储结构的线性表");
        index(linkedList, "链式存储结构的线性表");
    }

    public static void iterator(List<String> list, String name) {
        long start = System.currentTimeMillis();
        for (int times = 0; times < TIMES; times++) {
            Iterator<String> iterator = list.iterator();
            while (iterator.hasNext()) {
                String str = iterator.next();
                noOp(str);
            }
        }
        System.out.println(name + "迭代遍历时间：" + (System.currentTimeMillis() - start));
    }

    public static void index(List<String> list, String name) {
        long start = System.currentTimeMillis();
        for (int times = 0; times < TIMES; times++) {
            int size = list.size();
            for (int i = 0; i < size; i++) {
                String str = list.get(i);
                noOp(str);
            }
        }
        System.out.println(name + "索引遍历时间：" + (System.currentTimeMillis() - start));
    }

    public static String noOp(String str) {
        return str;
    }

    /**
     * 
     * @author zby
     * @date 2018年9月30日
     * @param list
     * @Description 初始化线性表
     */
    public static void fillList(List<String> list) {
        for (int i = 0; i < LIST_SIZE; i++) {
            list.add("list" + i);
        }
    }
}</pre></h1> ",
            "assembleText":"package com.zby.queue;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

/**
 * 
 * @author zby
 * @date 2018年9月30日
 * @Description 测试【顺序存储结构的线性表】和【链式存储结构的线性表】的【迭代遍历】和【索引遍历】效率，学会RandomAccess接口的作用
 */
public class ListPK {
    // 遍历次数
    public static final int TIMES = 1000000;
    // 线性表初始化大小
    public static final int LIST_SIZE = 1000;

    public static void main(String[] args) {
        List<String> arrayList = new ArrayList<String>();
        fillList(arrayList);
        List<String> linkedList = new LinkedList<String>();
        fillList(linkedList);
        iterator(arrayList, "顺序存储结构的线性表");
        index(arrayList, "顺序存储结构的线性表");
        iterator(linkedList, "链式存储结构的线性表");
        index(linkedList, "链式存储结构的线性表");
    }

    public static void iterator(List<String> list, String name) {
        long start = System.currentTimeMillis();
        for (int times = 0; times < TIMES; times++) {
            Iterator<String> iterator = list.iterator();
            while (iterator.hasNext()) {
                String str = iterator.next();
                noOp(str);
            }
        }
        System.out.println(name + "迭代遍历时间：" + (System.currentTimeMillis() - start));
    }

    public static void index(List<String> list, String name) {
        long start = System.currentTimeMillis();
        for (int times = 0; times < TIMES; times++) {
            int size = list.size();
            for (int i = 0; i < size; i++) {
                String str = list.get(i);
                noOp(str);
            }
        }
        System.out.println(name + "索引遍历时间：" + (System.currentTimeMillis() - start));
    }

    public static String noOp(String str) {
        return str;
    }

    /**
     * 
     * @author zby
     * @date 2018年9月30日
     * @param list
     * @Description 初始化线性表
     */
    public static void fillList(List<String> list) {
        for (int i = 0; i < LIST_SIZE; i++) {
            list.add("list" + i);
        }
    }
}",
            "assembleScratchTime":"2019-04-05 13:36:10",
            "facetId":556419,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/zby9527/p/9729462.html",
            "type":"text"
        },
        {
            "assembleId":2870313,
            "assembleContent":"<p>查找元素在链表中的位置</p><p>//思路：通过遍历查找，返回所查找到的节点地址<br>LinkNode* LinkListFind(LinkNode* head,LinkListType to_find)<br>{<br>    //判断链表是否为空<br>    if(head==NULL)<br>        return NULL;<br>    LinkNode* cur=head;<br>    while(cur!=NULL)<br>    {<br>        if(cur->data==to_find)<br>            return cur;<br>        cur=cur->next;<br>    }<br>    return NULL;<br>}</p> ",
            "assembleText":"查找元素在链表中的位置 //思路：通过遍历查找，返回所查找到的节点地址 LinkNode* LinkListFind(LinkNode* head,LinkListType to_find) {     //判断链表是否为空     if(head==NULL)         return NULL;     LinkNode* cur=head;     while(cur!=NULL)     {         if(cur->data==to_find)             return cur;         cur=cur->next;     }     return NULL; }",
            "assembleScratchTime":"2019-04-05 13:46:39",
            "facetId":556419,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870429,
            "assembleContent":"<dl><dt><strong>题目描述：</strong></dt><dd><p>建立一个升序链表并遍历输出。</p></dd></dl><dl><dt><strong>输入：</strong></dt><dd><p>输入的每个案例中第一行包括1个整数：n(1<=n<=1000)，接下来的一行包括n个整数。</p></dd></dl><dl><dt><strong>输出：</strong></dt><dd><p>可能有多组测试数据，对于每组数据，<br>将n个整数建立升序链表，之后遍历链表并输出。</p></dd></dl><dl><dt><strong>样例输入：</strong></dt><dd><pre>4
3 5 7 9</pre></dd></dl><dl><dt><strong>样例输出：</strong></dt><dd><pre>3 5 7 9</pre></dd><dd><pre><p>#include<stdio.h><br>#include<malloc.h><br>typedef struct Node //存储节点信息<br>{<br>    int data;<br>    struct Node *next;<br>} linklist;<br>int main()<br>{<br>    int n;<br>    while(scanf("%d",&n)!=EOF)<br>    {<br>        linklist *head,*p,*pre,*newNode  ;<br>        head=(linklist*)malloc(sizeof(linklist));<br>        head->next=NULL;<br>        for(int i=0; i<n; i++) //构建链表<br>        {<br>            newNode=(linklist*)malloc(sizeof(linklist));<br>            scanf("%d",&newNode->data);<br>            p=head->next;<br>            pre=head;<br>            while(p)<br>            {<br>                if(newNode->data<p->data)<br>                {<br>                    break;<br>                }<br>                pre=p;<br>                p=p->next;<br> <br>            }<br>            newNode->next=p;<br>            pre->next=newNode;<br>        }<br>        //输出<br>        p=head->next;<br>        printf("%d ",p->data);<br>        while(p->next)<br>        {<br>            p=p->next;<br>            printf("%d ",p->data);<br>        }<br>        printf("\n");<br> <br>    }<br> <br>    return 0;<br> <br>}</p></pre></dd></dl>  ",
            "assembleText":"题目描述： 建立一个升序链表并遍历输出。 输入： 输入的每个案例中第一行包括1个整数：n(1<=n<=1000)，接下来的一行包括n个整数。 输出： 可能有多组测试数据，对于每组数据， 将n个整数建立升序链表，之后遍历链表并输出。 样例输入： 4
3 5 7 9 样例输出： 3 5 7 9 #include<stdio.h> #include<malloc.h> typedef struct Node //存储节点信息 {     int data;     struct Node *next; } linklist; int main() {     int n;     while(scanf("%d",&n)!=EOF)     {         linklist *head,*p,*pre,*newNode  ;         head=(linklist*)malloc(sizeof(linklist));         head->next=NULL;         for(int i=0; i<n; i++) //构建链表         {             newNode=(linklist*)malloc(sizeof(linklist));             scanf("%d",&newNode->data);             p=head->next;             pre=head;             while(p)             {                 if(newNode->data<p->data)                 {                     break;                 }                 pre=p;                 p=p->next;              }             newNode->next=p;             pre->next=newNode;         }         //输出         p=head->next;         printf("%d ",p->data);         while(p->next)         {             p=p->next;             printf("%d ",p->data);         }         printf("\n");      }      return 0;  }",
            "assembleScratchTime":"2019-04-05 14:13:11",
            "facetId":556419,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/xs_211314/article/details/75453626",
            "type":"text"
        },
        {
            "assembleId":2870431,
            "assembleContent":"<dl><dt><h2>三、遍历函数原型设计</h2><h2><pre onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>bool move(int i, int step=1);</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>Node* current();</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>bool next();</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>bool end();</div></div></li></ol></code></pre></h2><h2></h2><h2></h2><h2><a name="t8"></a>四、遍历函数的实现</h2><h2><p></p><pre onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>bool move(int i, int step = 1)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    bool ret = ((0 <= i) && (i < m_length) && (step > 0));</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>    if( ret )</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        m_current = position(i)->next;</div></div></li><li><div><div></div></div><div><div>        m_step = step;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>    return ret;</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>bool next()</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    int i = 0;</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>    while( (i<m_step) && !end() )</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        m_current = m_current->next;</div></div></li><li><div><div></div></div><div><div>        i++;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>    return (i == m_step);</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>T current()</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    if( !end() )</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        return m_current->value;</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div>    else</div></div></li><li><div><div></div></div><div><div>    {</div></div></li><li><div><div></div></div><div><div>        THROW_EXCEPTION(InvalidOperationException, "No value at current ps");</div></div></li><li><div><div></div></div><div><div>    }</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>bool end()</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    return (m_current == NULL);</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre></h2><h2><a name="t9"></a>四、新式的链表遍历方法</h2><h2><pre onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>//时间复杂度：O(n) </div></div></li><li><div><div></div></div><div><div>for(list.move(0); !list.end(); list.next())</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    cout << list.current() << endl;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre><p></p></h2><h2><a name="t10"></a>五、单链表内部的一次封装</h2><h2></h2><h2><pre onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>virtual Node* create()</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    return new Node();</div></div></li><li><div><div></div></div><div><div>}</div></div></li><li><div><div></div></div><div><div> </div></div></li><li><div><div></div></div><div><div>virtual void destroy(Node* pn)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div>    delete pn;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre></h2></dt></dl>  ",
            "assembleText":"三、遍历函数原型设计 bool move(int i, int step=1); Node* current(); bool next(); bool end(); 四、遍历函数的实现 bool move(int i, int step = 1) { bool ret = ((0 <= i) && (i < m_length) && (step > 0)); if( ret ) { m_current = position(i)->next; m_step = step; } return ret; } bool next() { int i = 0; while( (i<m_step) && !end() ) { m_current = m_current->next; i++; } return (i == m_step); } T current() { if( !end() ) { return m_current->value; } else { THROW_EXCEPTION(InvalidOperationException, "No value at current ps"); } } bool end() { return (m_current == NULL); } 四、新式的链表遍历方法 //时间复杂度：O(n) for(list.move(0); !list.end(); list.next()) { cout << list.current() << endl; } 五、单链表内部的一次封装 virtual Node* create() { return new Node(); } virtual void destroy(Node* pn) { delete pn; }",
            "assembleScratchTime":"2019-04-05 14:14:29",
            "facetId":556419,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/iiiiiiwwooo/article/details/80061909",
            "type":"text"
        },
        {
            "assembleId":2870432,
            "assembleContent":"<dl><dt><h2><pre><code>#include<stdio.h><br> <br>//定义了<br>struct Node<br>{<br> int data;<br> struct Node * pNext;<br>};<br>/*<br>头结点：是头结点是首节点前的那个节点<br> 并不存放数据的数据<br> 头结点的数据类型和首节点的类型一模一样<br> 未来方便对链表的操作<br>头指针：存放头结点地址的指针变量<br>首节点：存放第一个有效数据的节点<br>尾节点：存放最后一个有效数据的节点<br>*/<br>struct Node * CreateList(void);<br>void TraverseList(struct Node * pHead);<br>int main(void)<br>{<br> struct Node * pHead=NULL;//定义头指针,用来存放链表<br> <br> pHead=CreateList();<br> TraverseList(pHead);<br> <br> return 0;<br>}<br>struct Node * CreateList(void)<br>{<br> int len;<br> int i;<br> int val;<br> struct Node * pHead=(struct Node *)malloc(sizeof(struct Node));<br> if(NULL==pHead)<br> {<br> printf("分配失败，程序终止!\n");<br> exit(-1);<br> }<br> struct Node * pTail=pHead;<br> pTail->pNext=NULL;<br> <br> printf("请输入需要生成的链接节点的个数：len=");<br> scanf("%d",&len);<br> for(i=0;i<len;++i)<br> {<br> printf("请输入第%d个节点的值：",i+1);<br> scanf("%d",&val);<br> <br> struct Node * pNew=(struct Node *)malloc(sizeof(struct Node));<br> if(NULL==pNew)<br> {<br> printf("分配失败,程序终止!\n");<br> exit(-1);<br> }<br> pNew->data=val;<br> pTail->pNext=pNew;<br> pNew->pNext=NULL;<br> pTail=pNew;<br> }<br> return pHead;<br>}<br> <br>void TraverseList(struct Node * pHead)<br>{<br> struct Node * p=pHead->pNext;<br> if(pHead->pNext==NULL)<br> {<br> printf("链表为空！");<br> }<br> else<br> {<br> while(p!=NULL)<br> {<br> printf("%d",p->data);<br> p=p->pNext;<br> }<br> <br> }<br>}</code></pre><p><br></p></h2></dt></dl>   ",
            "assembleText":"#include<stdio.h>  //定义了 struct Node {  int data;  struct Node * pNext; }; /* 头结点：是头结点是首节点前的那个节点  并不存放数据的数据  头结点的数据类型和首节点的类型一模一样  未来方便对链表的操作 头指针：存放头结点地址的指针变量 首节点：存放第一个有效数据的节点 尾节点：存放最后一个有效数据的节点 */ struct Node * CreateList(void); void TraverseList(struct Node * pHead); int main(void) {  struct Node * pHead=NULL;//定义头指针,用来存放链表   pHead=CreateList();  TraverseList(pHead);   return 0; } struct Node * CreateList(void) {  int len;  int i;  int val;  struct Node * pHead=(struct Node *)malloc(sizeof(struct Node));  if(NULL==pHead)  {  printf("分配失败，程序终止!\n");  exit(-1);  }  struct Node * pTail=pHead;  pTail->pNext=NULL;   printf("请输入需要生成的链接节点的个数：len=");  scanf("%d",&len);  for(i=0;i<len;++i)  {  printf("请输入第%d个节点的值：",i+1);  scanf("%d",&val);   struct Node * pNew=(struct Node *)malloc(sizeof(struct Node));  if(NULL==pNew)  {  printf("分配失败,程序终止!\n");  exit(-1);  }  pNew->data=val;  pTail->pNext=pNew;  pNew->pNext=NULL;  pTail=pNew;  }  return pHead; }  void TraverseList(struct Node * pHead) {  struct Node * p=pHead->pNext;  if(pHead->pNext==NULL)  {  printf("链表为空！");  }  else  {  while(p!=NULL)  {  printf("%d",p->data);  p=p->pNext;  }   } }",
            "assembleScratchTime":"2019-04-05 14:15:17",
            "facetId":556419,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tihumenjiang/article/details/64125937",
            "type":"text"
        },
        {
            "assembleId":2870433,
            "assembleContent":"<h2 id="题目描述">题目描述：</h2><p>建立一个升序链表并遍历输出</p><h2 id="输入描述"><a name="t1"></a>输入描述:</h2><p>输入的每个案例中第一行包括1个整数：n(1<=n<=1000)，接下来的一行包括n个整数</p><h2 id="输出描述"><a name="t2"></a>输出描述:</h2><p>可能有多组测试数据，对于每组数据， <br>将n个整数建立升序链表，之后遍历链表并输出。</p><pre><code>#include<stdio.h><br>#include<stdlib.h><br>typedef struct Node<br>{<br>    int data;<br>    struct Node * next;<br>}Node;<br><br>void insert(Node*head,int data)<br>{<br>    Node *p=head,*q=head->next;<br>    Node *temp=NULL;<br>    while(q&&q->data<data) <br>    {<br>        p=q;<br>        q=q->next;<br>    } <br><br>    temp=(Node*)malloc(sizeof(Node));<br>    temp->data=data;<br><br>    temp->next=p->next;<br>    p->next=temp;<br>}<br><br>void prin(Node *head)<br>{<br>    Node *p=head->next;<br>    while(p)<br>    {<br>        if(p==head->next)<br>            printf("%d",p->data);<br>        else<br>            printf(" %d",p->data);<br>        p=p->next;<br>    }<br>}<br><br>int main()<br>{<br>    Node *head;<br>    head=(Node*)malloc(sizeof(Node));<br>    head->next=NULL;<br><br>    int N;<br>    while(scanf("%d",&N)!=EOF)<br>    {<br>        int data;<br>        while(N--)<br>        {<br>            scanf("%d",&data);<br>            insert(head,data);<br>        }<br>        prin(head);<br>    }<br>    return 0;<br>}</code></pre><p><br></p> ",
            "assembleText":"题目描述： 建立一个升序链表并遍历输出 输入描述: 输入的每个案例中第一行包括1个整数：n(1<=n<=1000)，接下来的一行包括n个整数 输出描述: 可能有多组测试数据，对于每组数据，  将n个整数建立升序链表，之后遍历链表并输出。 #include<stdio.h> #include<stdlib.h> typedef struct Node {     int data;     struct Node * next; }Node; void insert(Node*head,int data) {     Node *p=head,*q=head->next;     Node *temp=NULL;     while(q&&q->data<data)     {         p=q;         q=q->next;     }     temp=(Node*)malloc(sizeof(Node));     temp->data=data;     temp->next=p->next;     p->next=temp; } void prin(Node *head) {     Node *p=head->next;     while(p)     {         if(p==head->next)             printf("%d",p->data);         else             printf(" %d",p->data);         p=p->next;     } } int main() {     Node *head;     head=(Node*)malloc(sizeof(Node));     head->next=NULL;     int N;     while(scanf("%d",&N)!=EOF)     {         int data;         while(N--)         {             scanf("%d",&data);             insert(head,data);         }         prin(head);     }     return 0; }",
            "assembleScratchTime":"2019-04-05 14:15:50",
            "facetId":556419,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tihumenjiang/article/details/64125937",
            "type":"text"
        },
        {
            "assembleId":2870264,
            "assembleContent":"<h1><p><span style="font-size: medium;">获得链表第i个数据的算法思路：</span></p><p><span style="font-size: medium;">　　　　a、声明一个结点p指向链表第一个结点，初始化j从1开始。</span></p><p><span style="font-size: medium;">　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。</span></p><p><span style="font-size: medium;">　　　　c、若到链表末尾P为空，则说明第i个元素不存在。</span></p><p><span style="font-size: medium;">　　　　d、否则查找成功，返回结点P的数据。</span></p></h1> ",
            "assembleText":"获得链表第i个数据的算法思路： 　　　　a、声明一个结点p指向链表第一个结点，初始化j从1开始。 　　　　b、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。 　　　　c、若到链表末尾P为空，则说明第i个元素不存在。 　　　　d、否则查找成功，返回结点P的数据。",
            "assembleScratchTime":"2019-04-05 13:35:34",
            "facetId":556420,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/lichuankai/p/8627665.html",
            "type":"text"
        },
        {
            "assembleId":2870314,
            "assembleContent":"<p>查找元素在链表中的位置</p><p>//思路：通过遍历查找，返回所查找到的节点地址<br><br></p> ",
            "assembleText":"查找元素在链表中的位置 //思路：通过遍历查找，返回所查找到的节点地址",
            "assembleScratchTime":"2019-04-05 13:46:56",
            "facetId":556420,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/tongxuexie/article/details/79684125",
            "type":"text"
        },
        {
            "assembleId":2870430,
            "assembleContent":"<dl><dt><h2>当前单链表的遍历方法</h2><pre onclick="hljs.signin(event)"><code><ol><li><div><div></div></div><div><div>//时间复杂度：O(n^2) </div></div></li><li><div><div></div></div><div><div>for(int i=0; i<list.length(); i++)</div></div></li><li><div><div></div></div><div><div>{</div></div></li><li><div><div></div></div><div><div> cout << list.get(i) << endl;</div></div></li><li><div><div></div></div><div><div>}</div></div></li></ol></code></pre><h2></h2><h2></h2><h2></h2><p></p><h2><a name="t4"></a>二、设计思路(游标)</h2><p></p><ul><li>在单链表内部定义一个游标(Node* m_current)</li><li>遍历前将游标指向位置为0的数据元素</li><li>获取游标指向的数据元素</li><li>通过结点中的next指针移动游标</li></ul><p><img src="https://img-blog.csdn.net/20180424112830590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lpaWlpaXd3b29v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p></dt></dl>  ",
            "assembleText":"当前单链表的遍历方法 //时间复杂度：O(n^2) for(int i=0; i<list.length(); i++) { cout << list.get(i) << endl; } 二、设计思路(游标) 在单链表内部定义一个游标(Node* m_current) 遍历前将游标指向位置为0的数据元素 获取游标指向的数据元素 通过结点中的next指针移动游标",
            "assembleScratchTime":"2019-04-05 14:14:06",
            "facetId":556420,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/iiiiiiwwooo/article/details/80061909",
            "type":"text"
        },
        {
            "assembleId":2870259,
            "assembleContent":"<h1><p><span style="font-size: medium;">待删除节点为q，也是先找到前驱节点，修改指针域即可，时间复杂度O(n)。   </span><br></p></h1> ",
            "assembleText":"待删除节点为q，也是先找到前驱节点，修改指针域即可，时间复杂度O(n)。   ",
            "assembleScratchTime":"2019-04-05 13:34:14",
            "facetId":556422,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/wincai/p/5893475.html",
            "type":"text"
        }
    ]
}
