{
    "code":200,
    "msg":"成功",
    "data":[
        {
            "assembleId":2865352,
            "assembleContent":"<h3><span id="Insertion">Insertion</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=14" title="Edit section: Insertion">edit</a>]</h3><p>Nodes can be inserted into binary trees in between two other nodes or added after a <a href="https://en.wikipedia.org/wiki/Leaf_node" title="Leaf node">leaf node</a>. In binary trees, a node that is inserted is specified as to which child it is.</p> ",
            "assembleText":"Insertion[edit] Nodes can be inserted into binary trees in between two other nodes or added after a leaf node. In binary trees, a node that is inserted is specified as to which child it is.",
            "assembleScratchTime":"2019-03-24 21:35:27",
            "facetId":559849,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865355,
            "assembleContent":"<h4><span id="Leaf_nodes">Leaf nodes</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=15" title="Edit section: Leaf nodes">edit</a>]</h4><p>To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.</p><p><br></p> ",
            "assembleText":"Leaf nodes[edit] To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.",
            "assembleScratchTime":"2019-03-24 21:35:38",
            "facetId":559849,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865405,
            "assembleContent":"<h4><span id="Leaf_nodes">Leaf nodes</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=15" title="Edit section: Leaf nodes">edit</a>]</h4><p>To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.</p><p><br></p> ",
            "assembleText":"Leaf nodes[edit] To add a new node after leaf node A, A assigns the new node as one of its children and the new node assigns node A as its parent.",
            "assembleScratchTime":"2019-03-24 21:46:20",
            "facetId":559849,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865518,
            "assembleContent":"<p><strong>思路：将要插入节点的键值与根节点键值比较，如果小于根节点键值，则插入根节点的左子树，如果大于根节点的键值，则插入根节点的右子树，插入子树相当于插入一个更小的树，因此可以用递归方法实现，直到找到没有子树的节点，将新节点插到其下面。注意，新节点插入后，最终只会成为叶节点。</strong>  <br></p> ",
            "assembleText":"思路：将要插入节点的键值与根节点键值比较，如果小于根节点键值，则插入根节点的左子树，如果大于根节点的键值，则插入根节点的右子树，插入子树相当于插入一个更小的树，因此可以用递归方法实现，直到找到没有子树的节点，将新节点插到其下面。注意，新节点插入后，最终只会成为叶节点。  ",
            "assembleScratchTime":"2019-03-24 22:04:19",
            "facetId":559849,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2865520,
            "assembleContent":"<pre><code>void insertNode(TreeNodePtr *treePtr, int value)<br>{<br><br> /* if treePtr is NULL */<br> if (*treePtr == NULL) {<br><br> *treePtr = malloc(sizeof(TreeNode));<br><br> if (*treePtr != NULL) {<br> (*treePtr)->data = value;<br> (*treePtr)->leftPtr = NULL;<br> (*treePtr)->rightPtr = NULL;<br> }<br> else {<br> printf("%d not inserted. No memory available.\n", value);<br> } <br><br> } <br> else { <br><br>    /* insert node in left subtree */<br> if (value < (*treePtr)->data) {<br> insertNode(&((*treePtr)->leftPtr), value);<br> } <br> else {<br><br> /* insert node in right subtree */<br> if (value >(*treePtr)->data) {<br> insertNode(&((*treePtr)->rightPtr), value);<br> } <br> else { <br> printf("dup");<br> }<br> } <br><br> } <br><br>} <br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</code></pre><p><br></p> ",
            "assembleText":"void insertNode(TreeNodePtr *treePtr, int value) {  /* if treePtr is NULL */  if (*treePtr == NULL) {  *treePtr = malloc(sizeof(TreeNode));  if (*treePtr != NULL) {  (*treePtr)->data = value;  (*treePtr)->leftPtr = NULL;  (*treePtr)->rightPtr = NULL;  }  else {  printf("%d not inserted. No memory available.\n", value);  }  }  else {     /* insert node in left subtree */  if (value < (*treePtr)->data) {  insertNode(&((*treePtr)->leftPtr), value);  }  else {  /* insert node in right subtree */  if (value >(*treePtr)->data) {  insertNode(&((*treePtr)->rightPtr), value);  }  else {  printf("dup");  }  }  } } --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:04:33",
            "facetId":559849,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2865438,
            "assembleContent":"<h4><span id="Depth-first_order">Depth-first order</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=21" title="Edit section: Depth-first order">edit</a>]</h4><p>In depth-first order, we always attempt to visit the node farthest from the root node that we can, but with the caveat that it must be a child of a node we have already visited. Unlike a depth-first search on graphs, there is no need to remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See <a href="https://en.wikipedia.org/wiki/Depth-first_search" title="Depth-first search">depth-first search</a> for more information.</p> ",
            "assembleText":"Depth-first order[edit] In depth-first order, we always attempt to visit the node farthest from the root node that we can, but with the caveat that it must be a child of a node we have already visited. Unlike a depth-first search on graphs, there is no need to remember all the nodes we have visited, because a tree cannot contain cycles. Pre-order is a special case of this. See depth-first search for more information.",
            "assembleScratchTime":"2019-03-24 21:51:55",
            "facetId":559851,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865440,
            "assembleContent":"<h4><span id="Breadth-first_order">Breadth-first order</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=22" title="Edit section: Breadth-first order">edit</a>]</h4><p>Contrasting with depth-first order is breadth-first order, which always attempts to visit the node closest to the root that it has not already visited. See <a href="https://en.wikipedia.org/wiki/Breadth-first_search" title="Breadth-first search">breadth-first search</a> for more information. Also called a <i>level-order traversal</i>.</p><p>In a complete binary tree, a node's breadth-index (<i>i</i> − (2<sup><i>d</i></sup> − 1)) can be used as traversal instructions from the root. Reading bitwise from left to right, starting at bit <i>d</i> − 1, where <i>d</i> is the node's distance from the root (<i>d</i> = ⌊log2(<i>i</i>+1)⌋) and the node in question is not the root itself (<i>d</i> > 0). When the breadth-index is masked at bit <i>d</i> − 1, the bit values <tt>0</tt> and <tt>1</tt> mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating a complete binary tree this way versus each node having pointer/s to its sibling/s.</p> ",
            "assembleText":"Breadth-first order[edit] Contrasting with depth-first order is breadth-first order, which always attempts to visit the node closest to the root that it has not already visited. See breadth-first search for more information. Also called a level-order traversal. In a complete binary tree, a node's breadth-index (i − (2d − 1)) can be used as traversal instructions from the root. Reading bitwise from left to right, starting at bit d − 1, where d is the node's distance from the root (d = ⌊log2(i+1)⌋) and the node in question is not the root itself (d > 0). When the breadth-index is masked at bit d − 1, the bit values 0 and 1 mean to step either left or right, respectively. The process continues by successively checking the next bit to the right until there are no more. The rightmost bit indicates the final traversal from the desired node's parent to the node itself. There is a time-space trade-off between iterating a complete binary tree this way versus each node having pointer/s to its sibling/s.",
            "assembleScratchTime":"2019-03-24 21:52:13",
            "facetId":559851,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865428,
            "assembleContent":"<h3><span id="Deletion">Deletion</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=17" title="Edit section: Deletion">edit</a>]</h3><p>Deletion is the process whereby a node is removed from the tree. Only certain nodes in a binary tree can be removed unambiguously.<sup id="cite_ref-rice_27-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-rice-27">[27]</a></sup></p> ",
            "assembleText":"Deletion[edit] Deletion is the process whereby a node is removed from the tree. Only certain nodes in a binary tree can be removed unambiguously.[27]",
            "assembleScratchTime":"2019-03-24 21:50:11",
            "facetId":559850,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865433,
            "assembleContent":"<h4><span id="Node_with_zero_or_one_children">Node with zero or one children</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=18" title="Edit section: Node with zero or one children">edit</a>]</h4><h3><div><div><a href="https://en.wikipedia.org/wiki/File:Deletion_of_internal_binary_tree_node.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Deletion_of_internal_binary_tree_node.svg/360px-Deletion_of_internal_binary_tree_node.svg.png" decoding="async" width="360" height="111" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/3/31/Deletion_of_internal_binary_tree_node.svg/540px-Deletion_of_internal_binary_tree_node.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/3/31/Deletion_of_internal_binary_tree_node.svg/720px-Deletion_of_internal_binary_tree_node.svg.png 2x"></a><div><div><a href="https://en.wikipedia.org/wiki/File:Deletion_of_internal_binary_tree_node.svg" title="Enlarge"></a></div>The process of deleting an internal node in a binary tree</div></div></div><p>Suppose that the node to delete is node A. If A has no children, deletion is accomplished by setting the child of A's parent to <a href="https://en.wikipedia.org/wiki/Null_pointer" title="Null pointer">null</a>. If A has one child, set the parent of A's child to A's parent and set the child of A's parent to A's child.</p></h3> ",
            "assembleText":"Node with zero or one children[edit] The process of deleting an internal node in a binary tree Suppose that the node to delete is node A. If A has no children, deletion is accomplished by setting the child of A's parent to null. If A has one child, set the parent of A's child to A's parent and set the child of A's parent to A's child.",
            "assembleScratchTime":"2019-03-24 21:50:48",
            "facetId":559850,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865434,
            "assembleContent":"<h4><span id="Node_with_two_children">Node with two children</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=19" title="Edit section: Node with two children">edit</a>]</h4><p>In a binary tree, a node with two children cannot be deleted unambiguously.<sup id="cite_ref-rice_27-1"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-rice-27">[27]</a></sup> However, in certain binary trees (including <a href="https://en.wikipedia.org/wiki/Binary_search_tree" title="Binary search tree">binary search trees</a>) these nodes <i>can</i> be deleted, though with a rearrangement of the tree structure.</p> ",
            "assembleText":"Node with two children[edit] In a binary tree, a node with two children cannot be deleted unambiguously.[27] However, in certain binary trees (including binary search trees) these nodes can be deleted, though with a rearrangement of the tree structure.",
            "assembleScratchTime":"2019-03-24 21:51:05",
            "facetId":559850,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865523,
            "assembleContent":"<p>二叉树的删除<br><br>相比于二叉树的插入和查找，删除一个节点要复杂一些，原因是要保证二叉树的排序性质。二叉树删除有如下三种情况：<br>1. 删除节点是叶节点，即没有子节点，或者说左右子节点都是NULL。这种情况下，只需要把删除节点的父节点中对应的指针指向NULL即可。然后释放掉删除节点的空间。<br><br>2. 删除节点有一个子节点（左子节点或右子节点），这种情况下，把删除节点的父节点中对应的指针指向删除节点的子节点即可。然后释放掉删除节点的空间<br><br>3. 删除节点有两个子节点，这种情况下，必须要找到一个替代删除节点的替代节点，并且保证二叉树的排序性。根据二叉树的排序性，可知替代节点的键值必须最接近删除节点键值。比删除节点键值小的所有键值中最大那个，或者是比删除节点键值大的所有键值中最小的那个，是符合要求的。这两个键值所在的节点分别在删除节点的左子树中最右边的节点，删除节点右子树中最左边的节点。以从左子树中找最大键值节点为例，算法如下：<br><br>找到删除节点以及它的父节点<br>在删除节点的左子树中，向下向右遍历，找到替代节点以及它的父节点<br>删除节点的父节点中对应的指针指向替代节点<br>替代节点中的右子节点指针指向删除节点的右子树<br>如果替代节点的父节点不是删除节点，则将替代节点的左子节点指针指向删除节点的左子树，并且替代节点的父节点中对应的指针指向替代节点的左子节点<br>释放删除节点的空间<br>注意：第二步中找到的替代节点，可能会有左子树，但一定没有右子树。第五步要判断替代节点的父节点不是删除节点后，才将替代节点的左子节点指针指向删除节点的左子树，否则会出现替代节点左子节点指针指向自己的情况，从而丢失替代节点的左子树。<br>另外，还有一种实现相同效果的的方法，即将替代节点中的数据赋给删除节点，然后释放替代节点的空间。这种方法其实是删除了替代节点，并没有真正删除想要删除的节点。而且如果节点包括一个键值和很多其他的数据，则赋值语句会很多。<br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"二叉树的删除 相比于二叉树的插入和查找，删除一个节点要复杂一些，原因是要保证二叉树的排序性质。二叉树删除有如下三种情况： 1. 删除节点是叶节点，即没有子节点，或者说左右子节点都是NULL。这种情况下，只需要把删除节点的父节点中对应的指针指向NULL即可。然后释放掉删除节点的空间。 2. 删除节点有一个子节点（左子节点或右子节点），这种情况下，把删除节点的父节点中对应的指针指向删除节点的子节点即可。然后释放掉删除节点的空间 3. 删除节点有两个子节点，这种情况下，必须要找到一个替代删除节点的替代节点，并且保证二叉树的排序性。根据二叉树的排序性，可知替代节点的键值必须最接近删除节点键值。比删除节点键值小的所有键值中最大那个，或者是比删除节点键值大的所有键值中最小的那个，是符合要求的。这两个键值所在的节点分别在删除节点的左子树中最右边的节点，删除节点右子树中最左边的节点。以从左子树中找最大键值节点为例，算法如下： 找到删除节点以及它的父节点 在删除节点的左子树中，向下向右遍历，找到替代节点以及它的父节点 删除节点的父节点中对应的指针指向替代节点 替代节点中的右子节点指针指向删除节点的右子树 如果替代节点的父节点不是删除节点，则将替代节点的左子节点指针指向删除节点的左子树，并且替代节点的父节点中对应的指针指向替代节点的左子节点 释放删除节点的空间 注意：第二步中找到的替代节点，可能会有左子树，但一定没有右子树。第五步要判断替代节点的父节点不是删除节点后，才将替代节点的左子节点指针指向删除节点的左子树，否则会出现替代节点左子节点指针指向自己的情况，从而丢失替代节点的左子树。 另外，还有一种实现相同效果的的方法，即将替代节点中的数据赋给删除节点，然后释放替代节点的空间。这种方法其实是删除了替代节点，并没有真正删除想要删除的节点。而且如果节点包括一个键值和很多其他的数据，则赋值语句会很多。 --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:05:28",
            "facetId":559850,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2865526,
            "assembleContent":"<pre><code>void deleteNode(TreeNode **treePtrP, int value)<br>{<br> TreeNode *deleteNodePtr = *treePtrP;<br> TreeNode *parentNodeOfDeletePtr = NULL;<br> TreeNode *substituteNodePtr;<br> TreeNode *parentNodeOfSubstitutePtr;<br><br> //find deleNode and its parentNode<br> while (deleteNodePtr != NULL && value != deleteNodePtr->data)<br> {<br> parentNodeOfDeletePtr = deleteNodePtr;<br><br> if (deleteNodePtr->data > value)<br> {<br> deleteNodePtr = deleteNodePtr->leftPtr;<br> }<br> else<br> {<br> deleteNodePtr = deleteNodePtr->rightPtr;<br> }<br> }<br><br> //case that can't find such Node<br> if (deleteNodePtr == NULL)<br> {<br> printf("no such Node, delete fail\n\n");<br> return;<br><br> }<br><br> //delete a leafNode<br> if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = NULL;<br> }<br> else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)<br> {<br> parentNodeOfDeletePtr->leftPtr = NULL;<br> }<br> else<br> {<br> parentNodeOfDeletePtr->rightPtr = NULL;<br> }<br><br> }<br> //delete a Node which has a left child Node<br> else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->leftPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr;<br><br> }<br><br> //delete a Node which has a right child Node<br> else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->rightPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr;<br><br> }<br> //delete a Node which has a left and a right child Node<br> else<br> {<br> parentNodeOfSubstitutePtr = deleteNodePtr;<br> substituteNodePtr = deleteNodePtr->leftPtr;<br><br> //search down and right to find substituteNode and its parentNode<br> while (substituteNodePtr->rightPtr != NULL)<br> {<br> parentNodeOfSubstitutePtr = substituteNodePtr;<br> substituteNodePtr = substituteNodePtr->rightPtr;<br><br> }<br><br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = substituteNodePtr;<br> }<br> else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)<br> {<br> parentNodeOfDeletePtr->leftPtr = substituteNodePtr;<br> }<br> else<br> {<br> parentNodeOfDeletePtr->rightPtr = substituteNodePtr;<br> }<br><br> substituteNodePtr->rightPtr = deleteNodePtr->rightPtr;<br><br> if (parentNodeOfSubstitutePtr != deleteNodePtr)<br> {<br> substituteNodePtr->leftPtr = deleteNodePtr->leftPtr;<br><br> if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr)<br> {<br> parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr;<br> }<br> else<br> {<br> parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr;<br> }<br> }<br> <br> }<br><br> free(deleteNodePtr);<br>}<br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</code></pre><p><br></p> ",
            "assembleText":"void deleteNode(TreeNode **treePtrP, int value) {  TreeNode *deleteNodePtr = *treePtrP;  TreeNode *parentNodeOfDeletePtr = NULL;  TreeNode *substituteNodePtr;  TreeNode *parentNodeOfSubstitutePtr;  //find deleNode and its parentNode  while (deleteNodePtr != NULL && value != deleteNodePtr->data)  {  parentNodeOfDeletePtr = deleteNodePtr;  if (deleteNodePtr->data > value)  {  deleteNodePtr = deleteNodePtr->leftPtr;  }  else  {  deleteNodePtr = deleteNodePtr->rightPtr;  }  }  //case that can't find such Node  if (deleteNodePtr == NULL)  {  printf("no such Node, delete fail\n\n");  return;  }  //delete a leafNode  if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL)  {  //delete Node is root  if (parentNodeOfDeletePtr == NULL)  {  *treePtrP = NULL;  }  else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)  {  parentNodeOfDeletePtr->leftPtr = NULL;  }  else  {  parentNodeOfDeletePtr->rightPtr = NULL;  }  }  //delete a Node which has a left child Node  else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL)  {  //delete Node is root  if (parentNodeOfDeletePtr == NULL)  {  *treePtrP = deleteNodePtr->leftPtr;  }  else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)  parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr;  else  parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr;  }  //delete a Node which has a right child Node  else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL)  {  //delete Node is root  if (parentNodeOfDeletePtr == NULL)  {  *treePtrP = deleteNodePtr->rightPtr;  }  else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)  parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr;  else  parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr;  }  //delete a Node which has a left and a right child Node  else  {  parentNodeOfSubstitutePtr = deleteNodePtr;  substituteNodePtr = deleteNodePtr->leftPtr;  //search down and right to find substituteNode and its parentNode  while (substituteNodePtr->rightPtr != NULL)  {  parentNodeOfSubstitutePtr = substituteNodePtr;  substituteNodePtr = substituteNodePtr->rightPtr;  }  //delete Node is root  if (parentNodeOfDeletePtr == NULL)  {  *treePtrP = substituteNodePtr;  }  else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)  {  parentNodeOfDeletePtr->leftPtr = substituteNodePtr;  }  else  {  parentNodeOfDeletePtr->rightPtr = substituteNodePtr;  }  substituteNodePtr->rightPtr = deleteNodePtr->rightPtr;  if (parentNodeOfSubstitutePtr != deleteNodePtr)  {  substituteNodePtr->leftPtr = deleteNodePtr->leftPtr;  if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr)  {  parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr;  }  else  {  parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr;  }  }    }  free(deleteNodePtr); } --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:05:43",
            "facetId":559850,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850619,
            "assembleContent":"<div label-module="para">在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。</div><p>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2<sup>k-1</sup>个叶子节点，至多有2<sup>k</sup>-1个节点。  <br></p> ",
            "assembleText":"在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子节点，至多有2k-1个节点。  ",
            "assembleScratchTime":"2019-02-22 23:40:32",
            "facetId":558181,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2861804,
            "assembleContent":"<div label-module="para"><div label-module="para"><div label-module="para-title"><h2><p>二叉树是一种特殊的树，它的<b>子节点个数不超过两个</b>。二叉树具有一些特殊的计算性质， 使得在它们之上的一些操作异常高效。</p><p>沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节 点。从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示。以某种特定顺序 访问树中所有的节点称为树的遍历。</p><p>树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节 点，子节点的子节点等。我们定义树的<b>层数</b>就是<b>树的深度</b>。最后，每个节点都有一个与之相关的值，该值有时被称为键。</p></h2></div></div></div>    ",
            "assembleText":"二叉树是一种特殊的树，它的子节点个数不超过两个。二叉树具有一些特殊的计算性质， 使得在它们之上的一些操作异常高效。 沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节 点。从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示。以某种特定顺序 访问树中所有的节点称为树的遍历。 树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节 点，子节点的子节点等。我们定义树的层数就是树的深度。最后，每个节点都有一个与之相关的值，该值有时被称为键。",
            "assembleScratchTime":"2019-03-15 20:08:57",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861806,
            "assembleContent":"<p><b>二叉树</b>（英语：<span lang="en">Binary tree</span>）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84" title="树结构">树结构</a>。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。  <br></p>  ",
            "assembleText":"二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。  ",
            "assembleScratchTime":"2019-03-15 20:09:43",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861807,
            "assembleContent":"<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>是一个连通的无环图，并且每一个顶点的度不大于3。有根<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>还要满足根节点的度不大于2。有了根节点之后，每个顶点定义了唯一的父节点，和最多2个子节点。然而，没有足够的信息来区分左节点和右节点。如果不考虑<a href="https://zh.wikipedia.org/wiki/%E9%80%A3%E9%80%9A%E6%80%A7" title="连通性">连通性</a>，允许图中有多个<a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%A3%E9%80%9A%E5%88%86%E9%87%8F&action=edit&redlink=1" title="连通分量（页面不存在）">连通分量</a>，这样的结构叫做<a href="https://zh.wikipedia.org/wiki/%E6%A3%AE%E6%9E%97" title="森林">森林</a>。  <br></p>   ",
            "assembleText":"二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根节点的度不大于2。有了根节点之后，每个顶点定义了唯一的父节点，和最多2个子节点。然而，没有足够的信息来区分左节点和右节点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。  ",
            "assembleScratchTime":"2019-03-15 20:09:54",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861808,
            "assembleContent":"<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>是一个有根<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9_(%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)" title="树 (数据结构)">树</a>，并且每个节点最多有2个子节点。非空的<a>二叉树</a>，若树叶总数为 n0，分支度为2的总数为 n2，则 n0 = n2 + 1。  <br></p>   ",
            "assembleText":"二叉树是一个有根树，并且每个节点最多有2个子节点。非空的二叉树，若树叶总数为 n0，分支度为2的总数为 n2，则 n0 = n2 + 1。  ",
            "assembleScratchTime":"2019-03-15 20:10:08",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861809,
            "assembleContent":"<p>一棵深度为k，且有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&action=edit&redlink=1" title="满二叉树（页面不存在）">满二叉树</a>（Full Binary Tree）。这种树的特点是每一层上的节点数都是最大节点数。而在一棵<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>为<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>（Complete Binary Tree）。具有n个节点的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>的深度为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle log_{2}n+1}"><semantics><annotation encoding="application/x-tex">{</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b70df35ef7bd93a0bd0111f03a49f945b8afeb94" aria-hidden="true" alt="log_2n+1">。深度为k的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>，至少有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d38f350af2beda207bb91fbe737d7ae0d104e590" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k\end{aligned}}}">个节点，至多有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}"><semantics><annotation encoding="application/x-tex">}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点。  <br></p>   ",
            "assembleText":"一棵深度为k，且有个节点的二叉树，称为满二叉树（Full Binary Tree）。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。具有n个节点的完全二叉树的深度为 {。深度为k的完全二叉树，至少有个节点，至多有 }个节点。  ",
            "assembleScratchTime":"2019-03-15 20:10:19",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861810,
            "assembleContent":"<h2><b>二叉树</b></h2><p>现在来探讨一种特殊的树结构-二叉树(binary tree)，它每个节点最多有两个子结点，亦称左孩子和右孩子。</p><blockquote>在计算机科学中，二叉树是一种“树”数据结构，树上的每个节点最多有两个孩子，分别为左孩和右孩。——维基百科</blockquote>  ",
            "assembleText":"二叉树 现在来探讨一种特殊的树结构-二叉树(binary tree)，它每个节点最多有两个子结点，亦称左孩子和右孩子。 在计算机科学中，二叉树是一种“树”数据结构，树上的每个节点最多有两个孩子，分别为左孩和右孩。——维基百科",
            "assembleScratchTime":"2019-03-15 20:10:28",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861814,
            "assembleContent":"<p>二叉树是一种特殊的树，它的<b>子节点个数不超过两个</b>。二叉树具有一些特殊的计算性质， 使得在它们之上的一些操作异常高效。</p><p>沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节 点。从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示。以某种特定顺序 访问树中所有的节点称为树的遍历。</p><p>树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节 点，子节点的子节点等。我们定义树的<b>层数</b>就是<b>树的深度</b>。最后，每个节点都有一个与之相关的值，该值有时被称为键。</p> ",
            "assembleText":"二叉树是一种特殊的树，它的子节点个数不超过两个。二叉树具有一些特殊的计算性质， 使得在它们之上的一些操作异常高效。 沿着一组特定的边，可以从一个节点走到另外一个与它不直接相连的节 点。从一个节点到另一个节点的这一组边称为路径，在图中用虚线表示。以某种特定顺序 访问树中所有的节点称为树的遍历。 树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节 点，子节点的子节点等。我们定义树的层数就是树的深度。最后，每个节点都有一个与之相关的值，该值有时被称为键。",
            "assembleScratchTime":"2019-03-15 20:11:21",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27415750",
            "type":"text"
        },
        {
            "assembleId":2861911,
            "assembleContent":"<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" title="计算机科学">计算机科学</a>中，<b>二叉树</b>（英语：<span lang="en">Binary tree</span>）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%BB%93%E6%9E%84" title="树结构">树结构</a>。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。  <br></p> ",
            "assembleText":"在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。  ",
            "assembleScratchTime":"2019-03-15 20:54:03",
            "facetId":558181,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2861913,
            "assembleContent":"<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>是一个连通的无环图，并且每一个顶点的度不大于3。有根<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>还要满足根节点的度不大于2。有了根节点之后，每个顶点定义了唯一的父节点，和最多2个子节点。然而，没有足够的信息来区分左节点和右节点。如果不考虑<a href="https://zh.wikipedia.org/wiki/%E9%80%A3%E9%80%9A%E6%80%A7" title="连通性">连通性</a>，允许图中有多个<a href="https://zh.wikipedia.org/w/index.php?title=%E9%80%A3%E9%80%9A%E5%88%86%E9%87%8F&action=edit&redlink=1" title="连通分量（页面不存在）">连通分量</a>，这样的结构叫做<a href="https://zh.wikipedia.org/wiki/%E6%A3%AE%E6%9E%97" title="森林">森林</a>。  <br></p> ",
            "assembleText":"二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根节点的度不大于2。有了根节点之后，每个顶点定义了唯一的父节点，和最多2个子节点。然而，没有足够的信息来区分左节点和右节点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。  ",
            "assembleScratchTime":"2019-03-15 20:54:42",
            "facetId":558181,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2861983,
            "assembleContent":"<p>A binary tree is either empty (represented by a null pointer), or is made of a single node, where the left and right pointers (recursive definition ahead) each point to a binary tree.  <br></p> ",
            "assembleText":"A binary tree is either empty (represented by a null pointer), or is made of a single node, where the left and right pointers (recursive definition ahead) each point to a binary tree.  ",
            "assembleScratchTime":"2019-03-16 20:49:27",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861984,
            "assembleContent":"<p>“二叉搜索树（BST）” 或者说是有序二叉树，是二叉树的一种。在 BST 中，一个节点的所有左孩子存储的数据都比节点自身存储的数据小（或者相等），与之对应的，右孩子存储的数据都比节点自身要大。上图其实就是二叉搜索树的示例。在上图中，根节点存储的数据是 5，左孩子存储的 {1,3,4} 都比 5 小，右孩子存储的数据 {6,9} 都比 5 大。该关系可以递归下去，直到树叶。</p><p>要注意二叉树和二叉搜索树的区别，一词之差，所指的东西就完全不一样了。</p> ",
            "assembleText":"“二叉搜索树（BST）” 或者说是有序二叉树，是二叉树的一种。在 BST 中，一个节点的所有左孩子存储的数据都比节点自身存储的数据小（或者相等），与之对应的，右孩子存储的数据都比节点自身要大。上图其实就是二叉搜索树的示例。在上图中，根节点存储的数据是 5，左孩子存储的 {1,3,4} 都比 5 小，右孩子存储的数据 {6,9} 都比 5 大。该关系可以递归下去，直到树叶。 要注意二叉树和二叉搜索树的区别，一词之差，所指的东西就完全不一样了。",
            "assembleScratchTime":"2019-03-16 20:49:43",
            "facetId":558181,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2862109,
            "assembleContent":"<p><br>在计算机科学中，二叉树是每个结点最多有两个子树的<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=501687&ss_c=ssc.citiao.link">树结构</a>。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。  <br></p> ",
            "assembleText":"在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。  ",
            "assembleScratchTime":"2019-03-16 22:07:41",
            "facetId":558181,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862112,
            "assembleContent":"<p>二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=66940455&ss_c=ssc.citiao.link">根结点</a>的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7868996&ss_c=ssc.citiao.link">连通性</a>，允许图中有多个<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=61676872&ss_c=ssc.citiao.link">连通分量</a>，这样的结构叫做森林。<sup><a href="https://baike.sogou.com/v111776.htm#quote1">[1]</a></sup>  <br></p> ",
            "assembleText":"二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。[1]  ",
            "assembleScratchTime":"2019-03-16 22:08:46",
            "facetId":558181,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862118,
            "assembleContent":"<p>二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：</p><p>(1)空二叉树——如图(a)；</p><p><a title="点击查看大图" href="https://baike.sogou.com/PicBooklet.v?relateImageGroupIds=&lemmaId=111776&now=https%3A%2F%2Fpic.baike.soso.com%2Fugc%2Fbaikepic2%2F5240%2F20160718002647-1497798126.jpg%2F0&type=1" target="_blank"><img title="" alt="" width="220" height="66" src="https://pic.baike.soso.com/ugc/baikepic2/5240/20160718002647-1497798126.jpg/300"></a>(2)只有一个根结点的二叉树——如图(b)；</p><p>(3)只有左子树——如图(c)；</p><p>(4)只有右子树——如图(d)；</p><p>(5)<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4838495&ss_c=ssc.citiao.link">完全二叉树</a>——如图(e)。</p><p>注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。<sup><a href="https://baike.sogou.com/v111776.htm#quote1">[1]</a></sup></p> ",
            "assembleText":"二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态： (1)空二叉树——如图(a)； (2)只有一个根结点的二叉树——如图(b)； (3)只有左子树——如图(c)； (4)只有右子树——如图(d)； (5)完全二叉树——如图(e)。 注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。[1]",
            "assembleScratchTime":"2019-03-16 22:20:46",
            "facetId":558181,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865284,
            "assembleContent":"<div><div><a href="https://en.wikipedia.org/wiki/File:Binary_tree.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/192px-Binary_tree.svg.png" decoding="async" width="192" height="160" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/288px-Binary_tree.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/384px-Binary_tree.svg.png 2x"></a><div><div><a href="https://en.wikipedia.org/wiki/File:Binary_tree.svg" title="Enlarge"></a></div>A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted.</div></div></div><p>In <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, a <b>binary tree</b> is a <a href="https://en.wikipedia.org/wiki/Tree_structure" title="Tree structure">tree</a> <a href="https://en.wikipedia.org/wiki/Data_structure" title="Data structure">data structure</a> in which each node has at most two <a href="https://en.wikipedia.org/wiki/Child_node" title="Child node">children</a>, which are referred to as the <i><span id="left_child">left child</span></i> and the <i><span id="right_child">right child</span></i>. A <a href="https://en.wikipedia.org/wiki/Recursive_definition" title="Recursive definition">recursive definition</a> using just <a href="https://en.wikipedia.org/wiki/Set_theory" title="Set theory">set theory</a> notions is that a (non-empty) binary tree is a <a href="https://en.wikipedia.org/wiki/Tuple" title="Tuple">tuple</a> (<i>L</i>, <i>S</i>, <i>R</i>), where <i>L</i> and <i>R</i> are binary trees or the <a href="https://en.wikipedia.org/wiki/Empty_set" title="Empty set">empty set</a> and <i>S</i> is a <a href="https://en.wikipedia.org/wiki/Singleton_set" title="Singleton set">singleton set</a>.<sup id="cite_ref-GarnierTaylor2009_1-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-GarnierTaylor2009-1">[1]</a></sup> Some authors allow the binary tree to be the empty set as well.<sup id="cite_ref-Skiena2009_2-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Skiena2009-2">[2]</a></sup></p> ",
            "assembleText":"A labeled binary tree of size 9 and height 3, with a root node whose value is 2. The above tree is unbalanced and not sorted. In computer science, a binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. A recursive definition using just set theory notions is that a (non-empty) binary tree is a tuple (L, S, R), where L and R are binary trees or the empty set and S is a singleton set.[1] Some authors allow the binary tree to be the empty set as well.[2]",
            "assembleScratchTime":"2019-03-24 21:27:54",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865286,
            "assembleContent":"<p>From a <a href="https://en.wikipedia.org/wiki/Graph_theory" title="Graph theory">graph theory</a> perspective, binary (and K-ary) trees as defined here are actually <a href="https://en.wikipedia.org/wiki/Arborescence_(graph_theory)" title="Arborescence (graph theory)">arborescences</a>.<sup id="cite_ref-Knuth1997_3-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Knuth1997-3">[3]</a></sup> A binary tree may thus be also called a <b>bifurcating arborescence</b><sup id="cite_ref-Knuth1997_3-1"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Knuth1997-3">[3]</a></sup>—a term which appears in some very old programming books,<sup id="cite_ref-Flores1971_4-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Flores1971-4">[4]</a></sup> before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an <a href="https://en.wikipedia.org/wiki/Undirected_graph" title="Undirected graph">undirected</a>, rather than a <a href="https://en.wikipedia.org/wiki/Directed_graph" title="Directed graph">directed graph</a>, in which case a binary tree is an <a href="https://en.wikipedia.org/wiki/Ordered_tree" title="Ordered tree">ordered</a>, <a href="https://en.wikipedia.org/wiki/Rooted_tree" title="Rooted tree">rooted tree</a>.<sup id="cite_ref-5"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-5">[5]</a></sup> Some authors use <b>rooted binary tree</b> instead of <i>binary tree</i> to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted.<sup id="cite_ref-Mazur2010_6-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Mazur2010-6">[6]</a></sup> A binary tree is a special case of an ordered <a href="https://en.wikipedia.org/wiki/K-ary_tree" title="K-ary tree">K-ary tree</a>, where <i>k</i> is 2.  <br></p> ",
            "assembleText":"From a graph theory perspective, binary (and K-ary) trees as defined here are actually arborescences.[3] A binary tree may thus be also called a bifurcating arborescence[3]—a term which appears in some very old programming books,[4] before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an undirected, rather than a directed graph, in which case a binary tree is an ordered, rooted tree.[5] Some authors use rooted binary tree instead of binary tree to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted.[6] A binary tree is a special case of an ordered K-ary tree, where k is 2.  ",
            "assembleScratchTime":"2019-03-24 21:28:14",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865288,
            "assembleContent":"<p>In mathematics, what is termed <i>binary tree</i> can vary significantly from author to author. Some use the definition commonly used in computer science,<sup id="cite_ref-oem_7-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-oem-7">[7]</a></sup> but others define it as every non-leaf having exactly two children and don't necessarily order (as left/right) the children either.<sup id="cite_ref-Foulds1992_8-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Foulds1992-8">[8]</a></sup>  <br></p> ",
            "assembleText":"In mathematics, what is termed binary tree can vary significantly from author to author. Some use the definition commonly used in computer science,[7] but others define it as every non-leaf having exactly two children and don't necessarily order (as left/right) the children either.[8]  ",
            "assembleScratchTime":"2019-03-24 21:28:35",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865289,
            "assembleContent":"<p>In computing, binary trees are used in two very different ways:</p><ul><li>First, as a means of accessing nodes based on some value or label associated with each node.<sup id="cite_ref-Makinson2009b_9-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Makinson2009b-9">[9]</a></sup> Binary trees labelled this way are used to implement <a href="https://en.wikipedia.org/wiki/Binary_search_tree" title="Binary search tree">binary search trees</a> and <a href="https://en.wikipedia.org/wiki/Binary_heap" title="Binary heap">binary heaps</a>, and are used for efficient <a href="https://en.wikipedia.org/wiki/Search_algorithm" title="Search algorithm">searching</a> and <a href="https://en.wikipedia.org/wiki/Sorting_algorithm" title="Sorting algorithm">sorting</a>. The designation of non-root nodes as left or right child even when there is only one child present matters in some of these applications, in particular it is significant in binary search trees.<sup id="cite_ref-Gross2007_10-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Gross2007-10">[10]</a></sup> However, the arrangement of particular nodes into the tree is not part of the conceptual information. For example, in a normal binary search tree the placement of nodes depends almost entirely on the order in which they were added, and can be re-arranged (for example by <a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">balancing</a>) without changing the meaning.</li></ul><ul><li>Second, as a representation of data with a relevant bifurcating structure. In such cases the particular arrangement of nodes under and/or to the left or right of other nodes is part of the information (that is, changing it would change the meaning). Common examples occur with <a href="https://en.wikipedia.org/wiki/Huffman_coding" title="Huffman coding">Huffman coding</a> and <a href="https://en.wikipedia.org/wiki/Cladograms" title="Cladograms">cladograms</a>. The everyday division of documents into chapters, sections, paragraphs, and so on is an analogous example with n-ary rather than binary trees.</li></ul> ",
            "assembleText":"In computing, binary trees are used in two very different ways: First, as a means of accessing nodes based on some value or label associated with each node.[9] Binary trees labelled this way are used to implement binary search trees and binary heaps, and are used for efficient searching and sorting. The designation of non-root nodes as left or right child even when there is only one child present matters in some of these applications, in particular it is significant in binary search trees.[10] However, the arrangement of particular nodes into the tree is not part of the conceptual information. For example, in a normal binary search tree the placement of nodes depends almost entirely on the order in which they were added, and can be re-arranged (for example by balancing) without changing the meaning. Second, as a representation of data with a relevant bifurcating structure. In such cases the particular arrangement of nodes under and/or to the left or right of other nodes is part of the information (that is, changing it would change the meaning). Common examples occur with Huffman coding and cladograms. The everyday division of documents into chapters, sections, paragraphs, and so on is an analogous example with n-ary rather than binary trees.",
            "assembleScratchTime":"2019-03-24 21:28:51",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865291,
            "assembleContent":"<h3><span id="Recursive_definition">Recursive definition</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=2" title="Edit section: Recursive definition">edit</a>]</h3><p>the <a href="https://en.wikipedia.org/wiki/Empty_set" title="Empty set" style="background-color: rgb(255, 255, 255);">empty set</a> is an extended binary treeTo actually define a binary tree in general, we must allow for the possibility that only one of the children may be empty. An artifact, which in some textbooks is called an <i>extended binary tree</i> is needed for that purpose. An extended binary tree is thus recursively defined as:<sup id="cite_ref-Rosen2011_11-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Rosen2011-11">[11]</a></sup></p><ul><li>if T<sub>1</sub> and T<sub>2</sub> are extended binary trees, then denote by T<sub>1</sub> • T<sub>2</sub> the extended binary tree obtained by adding a root <i>r</i> connected to the left to T<sub>1</sub> and to the right to T<sub>2</sub> by adding edges when these sub-trees are non-empty.</li></ul><p>Another way of imagining this construction (and understanding the terminology) is to consider instead of the empty set a different type of node—for instance square nodes if the regular ones are circles.<sup id="cite_ref-HuShing2002_12-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-HuShing2002-12">[12]</a></sup></p> ",
            "assembleText":"Recursive definition[edit] the empty set is an extended binary treeTo actually define a binary tree in general, we must allow for the possibility that only one of the children may be empty. An artifact, which in some textbooks is called an extended binary tree is needed for that purpose. An extended binary tree is thus recursively defined as:[11] if T1 and T2 are extended binary trees, then denote by T1 • T2 the extended binary tree obtained by adding a root r connected to the left to T1 and to the right to T2 by adding edges when these sub-trees are non-empty. Another way of imagining this construction (and understanding the terminology) is to consider instead of the empty set a different type of node—for instance square nodes if the regular ones are circles.[12]",
            "assembleScratchTime":"2019-03-24 21:29:09",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865292,
            "assembleContent":"<h3><span id="Using_graph_theory_concepts">Using graph theory concepts</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=3" title="Edit section: Using graph theory concepts">edit</a>]</h3><h3><p>A binary tree is a <a href="https://en.wikipedia.org/wiki/Rooted_tree" title="Rooted tree">rooted tree</a> that is also an <a href="https://en.wikipedia.org/wiki/Ordered_tree" title="Ordered tree">ordered tree</a> (a.k.a. plane tree) in which every node has at most two children. A rooted tree naturally imparts a notion of levels (distance from the root), thus for every node a notion of children may be defined as the nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child.<sup id="cite_ref-HsuLin2008_13-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-HsuLin2008-13">[13]</a></sup> But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child.</p><p>The necessary distinction can be made by first partitioning the edges, i.e., defining the binary tree as triplet (V, E<sub>1</sub>, E<sub>2</sub>), where (V, E<sub>1</sub> ∪ E<sub>2</sub>) is a rooted tree (equivalently arborescence) and E<sub>1</sub> ∩ E<sub>2</sub>is empty, and also requiring that for all <i>j</i> ∈ { 1, 2 } every node has at most one E<sub><i>j</i></sub> child.<sup id="cite_ref-FlumGrohe2006_14-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-FlumGrohe2006-14">[14]</a></sup> A more informal way of making the distinction is to say, quoting the <a href="https://en.wikipedia.org/wiki/Encyclopedia_of_Mathematics" title="Encyclopedia of Mathematics">Encyclopedia of Mathematics</a>, that "every node has a left child, a right child, neither, or both" and to specify that these "are all different" binary trees.<sup id="cite_ref-oem_7-1"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-oem-7">[7]</a></sup></p></h3> ",
            "assembleText":"Using graph theory concepts[edit] A binary tree is a rooted tree that is also an ordered tree (a.k.a. plane tree) in which every node has at most two children. A rooted tree naturally imparts a notion of levels (distance from the root), thus for every node a notion of children may be defined as the nodes connected to it a level below. Ordering of these children (e.g., by drawing them on a plane) makes possible to distinguish left child from right child.[13] But this still doesn't distinguish between a node with left but not a right child from a one with right but no left child. The necessary distinction can be made by first partitioning the edges, i.e., defining the binary tree as triplet (V, E1, E2), where (V, E1 ∪ E2) is a rooted tree (equivalently arborescence) and E1 ∩ E2is empty, and also requiring that for all j ∈ { 1, 2 } every node has at most one Ej child.[14] A more informal way of making the distinction is to say, quoting the Encyclopedia of Mathematics, that "every node has a left child, a right child, neither, or both" and to specify that these "are all different" binary trees.[7]",
            "assembleScratchTime":"2019-03-24 21:29:19",
            "facetId":558181,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865481,
            "assembleContent":"<p>二叉树通常以结构体的形式定义，如下，结构体内容包括三部分：本节点所存储的值、左孩子节点的指针、右孩子节点的指针。这里需要注意，子节点必须使用指针，就像我们定义结构体链表一样，下一个节点必须使用地址的方式存在在结构体当中。<br><br>struct TreeNode {<br> int val;<br> struct TreeNode *left;<br> struct TreeNode *right;<br>};<br>当然，我们也可以为我们的的树节点结构体重新定义一下名字，使用C语言中的typedef方法就可以了。<br><br>typedef struct TreeNode {<br> int val;<br> struct TreeNode *left;<br> struct TreeNode *right;<br>} BiNode, *BiTree;<br><br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"二叉树通常以结构体的形式定义，如下，结构体内容包括三部分：本节点所存储的值、左孩子节点的指针、右孩子节点的指针。这里需要注意，子节点必须使用指针，就像我们定义结构体链表一样，下一个节点必须使用地址的方式存在在结构体当中。 struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; }; 当然，我们也可以为我们的的树节点结构体重新定义一下名字，使用C语言中的typedef方法就可以了。 typedef struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; } BiNode, *BiTree; --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 21:59:14",
            "facetId":558181,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2861964,
            "assembleContent":"<p>用的最多的应该是平衡二叉树，有种特殊的平衡二叉树红黑树，查找、插入、删除的时间复杂度最坏为O(log n)</p><div><div>Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。<br>还有哈夫曼树编码方面的应用。<br>B-Tree，B+-Tree在文件系统中的应用。<br>如有错误或遗漏还请各位指正补充。</div><br></div> ",
            "assembleText":"用的最多的应该是平衡二叉树，有种特殊的平衡二叉树红黑树，查找、插入、删除的时间复杂度最坏为O(log n) Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 还有哈夫曼树编码方面的应用。 B-Tree，B+-Tree在文件系统中的应用。 如有错误或遗漏还请各位指正补充。",
            "assembleScratchTime":"2019-03-16 20:39:27",
            "facetId":558351,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861965,
            "assembleContent":"<div><blockquote>当HashMap产生hash碰撞的时候, 被存到数组下的链表中,这是jdk1.7hashmap的实现. 1.8以后的改版是当这个链表长度大于8的时候 这个链表就转换成一个<b>二叉树</b>.他是一个特殊的二叉树.叫平衡二叉树.也叫红黑树.</blockquote><p>一般这种低级数据结构不会应用到我们的业务逻辑实现.因为比较抽象.而是用在底层数据如hashMap这样的复杂实现.</p><p>本人经验尚浅不足之处 只能根据理解回答了 敬亲见谅</p></div> ",
            "assembleText":"当HashMap产生hash碰撞的时候, 被存到数组下的链表中,这是jdk1.7hashmap的实现. 1.8以后的改版是当这个链表长度大于8的时候 这个链表就转换成一个二叉树.他是一个特殊的二叉树.叫平衡二叉树.也叫红黑树. 一般这种低级数据结构不会应用到我们的业务逻辑实现.因为比较抽象.而是用在底层数据如hashMap这样的复杂实现. 本人经验尚浅不足之处 只能根据理解回答了 敬亲见谅",
            "assembleScratchTime":"2019-03-16 20:39:45",
            "facetId":558351,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861966,
            "assembleContent":"<p>把先序改造一下，做树形菜单不错。  <br></p> ",
            "assembleText":"把先序改造一下，做树形菜单不错。  ",
            "assembleScratchTime":"2019-03-16 20:40:02",
            "facetId":558351,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861967,
            "assembleContent":"<p>二叉树中的二叉查找树，可以使用 ”中序遍历“ 来排序。  <br></p> ",
            "assembleText":"二叉树中的二叉查找树，可以使用 ”中序遍历“ 来排序。  ",
            "assembleScratchTime":"2019-03-16 20:40:11",
            "facetId":558351,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2862005,
            "assembleContent":"<p>平衡二叉树都有哪些应用场景</p><p>二叉树支持动态的插入和查找，保证操作在O(height)时间，这就是完成了哈希表不便完成的工作，动态性。但是二叉树有可能出现worst-case，如果输入序列已经排序，则时间复杂度为O(N)<br><br>平衡二叉树/红黑树就是为了将查找的时间复杂度保证在O(logN)范围内。<br>所以如果输入结合确定，所需要的就是查询，则可以考虑使用哈希表，如果输入集合不确定，则考虑使用平衡二叉树/红黑树，保证达到最大效率</p><p>平衡二叉树主要优点集中在快速查找。<br></p><p>如果你知道SGI/STL的set/map底层都是用红黑树（平衡二叉树的一种）实现的，相信你会对这些树大有兴趣。</p><p><br></p><p>红黑树（linux中ext3文件系统管理），avl树“<a href="https://www.baidu.com/s?wd=windows&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank">windows</a>对进程地址空间的管理”。<br></p><p><br></p> ",
            "assembleText":"平衡二叉树都有哪些应用场景 二叉树支持动态的插入和查找，保证操作在O(height)时间，这就是完成了哈希表不便完成的工作，动态性。但是二叉树有可能出现worst-case，如果输入序列已经排序，则时间复杂度为O(N) 平衡二叉树/红黑树就是为了将查找的时间复杂度保证在O(logN)范围内。 所以如果输入结合确定，所需要的就是查询，则可以考虑使用哈希表，如果输入集合不确定，则考虑使用平衡二叉树/红黑树，保证达到最大效率 平衡二叉树主要优点集中在快速查找。 如果你知道SGI/STL的set/map底层都是用红黑树（平衡二叉树的一种）实现的，相信你会对这些树大有兴趣。 红黑树（linux中ext3文件系统管理），avl树“windows对进程地址空间的管理”。",
            "assembleScratchTime":"2019-03-16 21:07:44",
            "facetId":558351,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2862006,
            "assembleContent":"<p>计算节点个数<br>      计算二叉树的节点的格式可以利用二叉树的遍历，常用的是后遍历，先遍历根结点的左子树和右子树，分别计算出左右子树的结点个数，然后加上根结点个数就是整个二叉树节点个数。<br><br>template<class T><br>int BinaryTree<T>::size(BinaryTreeNode <T> *current)<br>{<br> if (current == NULL){ return 0; }<br> else{ return 1 + size(current->Lchild) + size(current->Rchild); }<br>}<br><br></p> ",
            "assembleText":"计算节点个数       计算二叉树的节点的格式可以利用二叉树的遍历，常用的是后遍历，先遍历根结点的左子树和右子树，分别计算出左右子树的结点个数，然后加上根结点个数就是整个二叉树节点个数。 template<class T> int BinaryTree<T>::size(BinaryTreeNode <T> *current) { if (current == NULL){ return 0; } else{ return 1 + size(current->Lchild) + size(current->Rchild); } }",
            "assembleScratchTime":"2019-03-16 21:08:45",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862007,
            "assembleContent":"<p>红黑树和B树应用场景有何不同？</p><p>2者都是有序数据结构，可用作数据容器。<br>红黑树多用在内部排序，即全放在内存中的，<a href="https://www.baidu.com/s?wd=%E5%BE%AE%E8%BD%AF&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank">微软</a>STL的map和set的内部实现就是红黑树。<br>B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。<br></p><p>在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。<br>反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。<br></p><p><br></p> ",
            "assembleText":"红黑树和B树应用场景有何不同？ 2者都是有序数据结构，可用作数据容器。 红黑树多用在内部排序，即全放在内存中的，微软STL的map和set的内部实现就是红黑树。 B树多用在内存里放不下，大部分数据存储在外存上时。因为B树层数少，因此可以确保每次操作，读取磁盘的次数尽可能的少。 在数据较小，可以完全放到内存中时，红黑树的时间复杂度比B树低。 反之，数据量较大，外存中占主要部分时，B树因其读磁盘次数少，而具有更快的速度。",
            "assembleScratchTime":"2019-03-16 21:09:12",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862008,
            "assembleContent":"<p>红黑树rbtree 二叉排序树<br>map 就是采用红黑树存储的，红黑树(RB Tree)是平衡二叉树，其优点就是树到叶子节点深度一致，查找的效率也就一样，为logN.在实行查找，插入，删除的效率都一致，而当是全部静态数据时，没有太多优势，可能采用hash表各合适。<br>hash_map是一个hash table占用内存更多，查找效率高一些，但是hash的时间比较费时。<br>总 体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小， hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且 hash_map的构造速度较慢。<br>现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。<br>trie树Double Array 字典查找树<br>Trie树既可用于一般的字典搜索，也可用于索引查找。<br>每个节点相当于DFA的一个状态，终止状态为查找结束。有序查找的过程相当于状态的不断转换<br>对于给定的一个字符串a1,a2,a3,...,an.则<br>采用TRIE树搜索经过n次搜索即可完成一次查找。不过好像还是没有B树的搜索效率高，B树搜索算法复杂度为logt(n+1/2).当t趋向大，搜索效率变得高效。怪不得DB2的访问内存设置为虚拟内存的一个PAGE大小，而且帧切换频率降低，无需经常的PAGE切换。<br></p> ",
            "assembleText":"红黑树rbtree 二叉排序树 map 就是采用红黑树存储的，红黑树(RB Tree)是平衡二叉树，其优点就是树到叶子节点深度一致，查找的效率也就一样，为logN.在实行查找，插入，删除的效率都一致，而当是全部静态数据时，没有太多优势，可能采用hash表各合适。 hash_map是一个hash table占用内存更多，查找效率高一些，但是hash的时间比较费时。 总 体来说，hash_map 查找速度会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小， hash还有hash函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且 hash_map的构造速度较慢。 现在知道如何选择了吗？权衡三个因素: 查找速度, 数据量, 内存使用。 trie树Double Array 字典查找树 Trie树既可用于一般的字典搜索，也可用于索引查找。 每个节点相当于DFA的一个状态，终止状态为查找结束。有序查找的过程相当于状态的不断转换 对于给定的一个字符串a1,a2,a3,...,an.则 采用TRIE树搜索经过n次搜索即可完成一次查找。不过好像还是没有B树的搜索效率高，B树搜索算法复杂度为logt(n+1/2).当t趋向大，搜索效率变得高效。怪不得DB2的访问内存设置为虚拟内存的一个PAGE大小，而且帧切换频率降低，无需经常的PAGE切换。",
            "assembleScratchTime":"2019-03-16 21:09:23",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862009,
            "assembleContent":"<p>B树<br>       即二叉搜索树：<br>       1.所有非叶子结点至多拥有两个儿子（Left和Right）；<br>       2.所有结点存储一个关键字；<br>       3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；<br>       如：<br>       B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；<br>       如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；<br>       如：<br>    但B树在经过多次插入与删除后，有可能导致不同的结构：<br>   右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      <br>       实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；  <br></p> ",
            "assembleText":"B树        即二叉搜索树：        1.所有非叶子结点至多拥有两个儿子（Left和Right）；        2.所有结点存储一个关键字；        3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；        如：        B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；        如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；        如：     但B树在经过多次插入与删除后，有可能导致不同的结构：    右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；              实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；  ",
            "assembleScratchTime":"2019-03-16 21:09:40",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862010,
            "assembleContent":"<p>B-树<br>       是一种多路搜索树（并不是二叉的）：<br>       1.定义任意非叶子结点最多只有M个儿子；且M>2；<br>       2.根结点的儿子数为[2, M]；<br>       3.除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>       4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>       5.非叶子结点的关键字个数=指向儿子的指针个数-1；<br>       6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；<br>       7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>       8.所有叶子结点位于同一层；<br>       如：（M=3）<br>       B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；<br>B-树的特性：<br>       1.关键字集合分布在整颗树中；<br>       2.任何一个关键字出现且只出现在一个结点中；<br>       3.搜索有可能在非叶子结点结束；<br>       4.其搜索性能等价于在关键字全集内做一次二分查找；<br>       5.自动层次控制；<br>       由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：<br>       其中，M为设定的非叶子结点最多子树个数，N为关键字总数；<br>       所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；<br>       由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并；<br>B+树<br>       B+树是B-树的变体，也是一种多路搜索树：<br>       1.其定义基本与B-树同，除了：<br>       2.非叶子结点的子树指针与关键字个数相同；<br>       3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；<br>       5.为所有叶子结点增加一个链指针；<br>       6.所有关键字都在叶子结点出现；<br>       如：（M=3）<br>   B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；<br>       B+的特性：<br>       1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；<br>       2.不可能在非叶子结点命中；<br>       3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；<br>       4.更适合文件索引系统；  <br></p> ",
            "assembleText":"B-树        是一种多路搜索树（并不是二叉的）：        1.定义任意非叶子结点最多只有M个儿子；且M>2；        2.根结点的儿子数为[2, M]；        3.除根结点以外的非叶子结点的儿子数为[M/2, M]；        4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）        5.非叶子结点的关键字个数=指向儿子的指针个数-1；        6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；        7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；        8.所有叶子结点位于同一层；        如：（M=3）        B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点； B-树的特性：        1.关键字集合分布在整颗树中；        2.任何一个关键字出现且只出现在一个结点中；        3.搜索有可能在非叶子结点结束；        4.其搜索性能等价于在关键字全集内做一次二分查找；        5.自动层次控制；        由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：        其中，M为设定的非叶子结点最多子树个数，N为关键字总数；        所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；        由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并； B+树        B+树是B-树的变体，也是一种多路搜索树：        1.其定义基本与B-树同，除了：        2.非叶子结点的子树指针与关键字个数相同；        3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；        5.为所有叶子结点增加一个链指针；        6.所有关键字都在叶子结点出现；        如：（M=3）    B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；        B+的特性：        1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；        2.不可能在非叶子结点命中；        3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；        4.更适合文件索引系统；  ",
            "assembleScratchTime":"2019-03-16 21:10:01",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862011,
            "assembleContent":"<p>B*树<br>       是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；<br>   B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；<br>       B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；<br>       B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>       所以，B*树分配新结点的概率比B+树要低，空间使用率更高；<br>小结<br>       B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；<br>       B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；<br>       所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<br>       B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；<br>       B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；<br></p><p><br></p> ",
            "assembleText":"B*树        是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；    B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；        B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；        B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；        所以，B*树分配新结点的概率比B+树要低，空间使用率更高； 小结        B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；        B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；        所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；        B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；        B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；",
            "assembleScratchTime":"2019-03-16 21:10:13",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862012,
            "assembleContent":"<p>B树是为了提高磁盘或外部存储设备查找效率而产生的一种多路平衡查找树。</p><p>B+树为B树的变形结构，用于大多数数据库或文件系统的存储而设计。</p><p><br></p><p>B树相对于红黑树的区别</p><p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><p><br></p><p>B树和B+树的区别</p><p>B树所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息。<br></p><p>B+树所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p><p>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</p><p></p><p>1) B<sup>+</sup>的磁盘读写代价更低</p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p>2) B<sup>+</sup>-tree的查询效率更加稳定</p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><p>数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树<a href="https://www.baidu.com/s?wd=%E5%BA%94%E8%BF%90%E8%80%8C%E7%94%9F&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd" target="_blank">应运而生</a>。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）</p> ",
            "assembleText":"B树是为了提高磁盘或外部存储设备查找效率而产生的一种多路平衡查找树。 B+树为B树的变形结构，用于大多数数据库或文件系统的存储而设计。 B树相对于红黑树的区别 在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。 B树和B+树的区别 B树所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息。 B+树所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息) 为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？ 1) B+的磁盘读写代价更低 B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 2) B+-tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）",
            "assembleScratchTime":"2019-03-16 21:10:30",
            "facetId":558351,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862110,
            "assembleContent":"<p>二叉树常被用于实现<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=5592449&ss_c=ssc.citiao.link">二叉查找树</a>和<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=9565860&ss_c=ssc.citiao.link">二叉堆</a>。  <br></p> ",
            "assembleText":"二叉树常被用于实现二叉查找树和二叉堆。  ",
            "assembleScratchTime":"2019-03-16 22:07:54",
            "facetId":558351,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862002,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1552741383213/512196052.png" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-16 21:03:04",
            "facetId":558389,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2861985,
            "assembleContent":"<ol><li>满二叉树：任意一个节点只有零或两个子节点的树叫做满二叉树，示例如下：</li></ol><div><pre><code>             18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40

             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50

           18
        /     \  
      40       30  
               /  \
             100   40</code></pre></div> ",
            "assembleText":"满二叉树：任意一个节点只有零或两个子节点的树叫做满二叉树，示例如下：              18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40

             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50

           18
        /     \  
      40       30  
               /  \
             100   40",
            "assembleScratchTime":"2019-03-16 20:50:13",
            "facetId":558454,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861986,
            "assembleContent":"<ol><li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 （1~h-1） 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li></ol><div><pre><code>             18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 </code></pre></div> ",
            "assembleText":"完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 （1~h-1） 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。              18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9",
            "assembleScratchTime":"2019-03-16 20:50:28",
            "facetId":558454,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861987,
            "assembleContent":"<div><ol><li>完美二叉树：满足完全二叉树性质，树的叶子节点均在最后一层的二叉树。示例如下：</li></ol><div><pre><code>             18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  </code></pre></div></div> ",
            "assembleText":"完美二叉树：满足完全二叉树性质，树的叶子节点均在最后一层的二叉树。示例如下：              18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30",
            "assembleScratchTime":"2019-03-16 20:50:38",
            "facetId":558454,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2865464,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435843999/2144940265.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:57:24",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865465,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435853114/938667439.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:57:33",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865468,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435860734/1630655963.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:57:41",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865469,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435866735/919726859.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:57:47",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865470,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435873076/1480768299.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:57:53",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865472,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435880419/1223814665.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:58:01",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865473,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435886376/1014171802.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:58:06",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865475,
            "assembleContent":"<p><img src="http://yotta.xjtushilei.com:8090/1553435892064/1503626525.jpg" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-24 21:58:13",
            "facetId":558454,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2850586,
            "assembleContent":"<p>二叉树的第<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" aria-hidden="true" alt="i">层至多拥有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/de838b503259acc792dd682654445984ea6e4c6d" aria-hidden="true" alt="2^{i-1}">个节点  <br></p>  ",
            "assembleText":"二叉树的第层至多拥有个节点  ",
            "assembleScratchTime":"2019-02-22 23:23:38",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850587,
            "assembleContent":"<p>深度为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">的二叉树至多总共有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bdd6d54432c7cf2d3244be2048309e59e878eaa8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}(k+1)\end{aligned}}-1}">个节点（定义根节点所在深度<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/93e97ea5847aa5aa81c2ecaca22b04c612a72c05" aria-hidden="true" alt="{\displaystyle k_{0}=0}">）  <br></p>  ",
            "assembleText":"深度为的二叉树至多总共有个节点（定义根节点所在深度）  ",
            "assembleScratchTime":"2019-02-22 23:23:56",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850588,
            "assembleContent":"<p>深度为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">有<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n">个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">的满二叉树，序号为1到<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n">的节点一对一对应时，称为<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="">完全二叉树</a>。  <br></p>  ",
            "assembleText":"深度为有个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度的满二叉树，序号为1到的节点一对一对应时，称为完全二叉树。  ",
            "assembleScratchTime":"2019-02-22 23:24:31",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850589,
            "assembleContent":"<p>对任何一棵非空的二叉树<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0" aria-hidden="true" alt="T">，如果其叶片（终端节点）数为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/63584d203ecb012a7bcb90f422408bbfe4018956" aria-hidden="true" alt="n_0">，分支度为2的节点数为<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/840e456e3058bc0be28e5cf653b170cdbfcc3be4" aria-hidden="true" alt="n_{2}">，则<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aa746d23c7cab9729c356a8e12e734e03de9fa64" aria-hidden="true" alt="{\displaystyle n_{0}=n_{2}+1}">。  <br></p>  ",
            "assembleText":"对任何一棵非空的二叉树，如果其叶片（终端节点）数为，分支度为2的节点数为，则。  ",
            "assembleScratchTime":"2019-02-22 23:25:00",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850590,
            "assembleContent":"<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。  <br></p>  ",
            "assembleText":"与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。  ",
            "assembleScratchTime":"2019-02-22 23:25:19",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850591,
            "assembleContent":"<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" title="二叉搜索树">二叉搜索树</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D" title="二叉堆">二叉堆</a>，并应用于高效率的搜索和排序。  <br></p>  ",
            "assembleText":"二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。  ",
            "assembleScratchTime":"2019-02-22 23:25:34",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2862128,
            "assembleContent":"<p>在非空二叉树中，第i层的结点总数不超过<a href="javascript:"><img title="" alt="" width="26" mark="bd_formula" ishandle="1" src="https://pic.baike.soso.com/ugc/baikepic2/51945/20160718002648-446143174.jpg/0"></a>, i>=1；  <br></p> ",
            "assembleText":"在非空二叉树中，第i层的结点总数不超过, i>=1；  ",
            "assembleScratchTime":"2019-03-16 22:23:11",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2850621,
            "assembleContent":"<div label-module="para"><div label-module="para"><div label-module="para">(1) 在<a target="_blank" href="https://baike.baidu.com/item/%E9%9D%9E%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91">非空二叉树</a>中，第i层的结点总数不超过<div> <img align="absmiddle" alt="" title="" height="16" width="26" src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D26/sign=b80019d95b82b2b7a39f3ec230addb66/fd039245d688d43f9ed0102f7f1ed21b0ff43bf5.jpg"> </div>, i>=1；</div><div label-module="para">(2) 深度为h的二叉树最多有<div> <img align="absmiddle" alt="" title="" height="17" width="38" src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D38/sign=8cafdaa318d5ad6eaef962e280cb7442/279759ee3d6d55fbec4f97416e224f4a21a4ddc8.jpg"> </div>个结点(h>=1)，最少有h个结点；</div><div label-module="para">(3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；</div><div label-module="para">(4) 具有n个结点的<a target="_blank" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>的深度为<div> <img align="absmiddle" alt="" title="" height="18" width="76" src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D76/sign=89ade8274690f60300b09e413912a50a/3b87e950352ac65c13170265f7f2b21193138a91.jpg"> </div>（注：[ ]表示向下取整）</div><div label-module="para">(5)有N个结点的<a target="_blank" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>各结点如果用顺序方式存储，则结点之间有如下关系：</div><div label-module="para">若I为结点编号则 如果I>1，则其父结点的编号为I/2；</div><div label-module="para">如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子；</div><div label-module="para">如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。</div><div label-module="para">(6)给定N个节点，能构成h(N)种不同的二叉树。</div><div label-module="para">h(N)为<a target="_blank" href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0">卡特兰数</a>的第N项。h(n)=C(2*n，n)/(n+1)。</div><div label-module="para">(7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i<sup> [2]</sup><a name="ref_[2]_88806"> </a></div></div></div> ",
            "assembleText":"(1) 在非空二叉树中，第i层的结点总数不超过   , i>=1； (2) 深度为h的二叉树最多有   个结点(h>=1)，最少有h个结点； (3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1； (4) 具有n个结点的完全二叉树的深度为   （注：[ ]表示向下取整） (5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2； 如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子； 如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。 (6)给定N个节点，能构成h(N)种不同的二叉树。 h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。 (7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i [2] ",
            "assembleScratchTime":"2019-02-22 23:44:18",
            "facetId":558478,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin#3",
            "type":"text"
        },
        {
            "assembleId":2861912,
            "assembleContent":"<p>二叉树的第<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle i}"><semantics><annotation encoding="application/x-tex">{\displaystyle i}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/add78d8608ad86e54951b8c8bd6c8d8416533d20" aria-hidden="true" alt="i">层至多拥有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{i-1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{i-1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/de838b503259acc792dd682654445984ea6e4c6d" aria-hidden="true" alt="2^{i-1}">个节点；深度为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle k}"><semantics><annotation encoding="application/x-tex">{\displaystyle k}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">的二叉树至多总共有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{\begin{aligned}(k+1)\end{aligned}}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{\begin{aligned}(k+1)\end{aligned}}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bdd6d54432c7cf2d3244be2048309e59e878eaa8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}(k+1)\end{aligned}}-1}">个节点（定义根节点所在深度 <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle k_{0}=0}"><semantics><annotation encoding="application/x-tex">{\displaystyle k_{0}=0}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/93e97ea5847aa5aa81c2ecaca22b04c612a72c05" aria-hidden="true" alt="{\displaystyle k_{0}=0}">），而总计拥有节点数匹配的，称为“满二叉树”；深度为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle k}"><semantics><annotation encoding="application/x-tex">{\displaystyle k}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n}"><semantics><annotation encoding="application/x-tex">{\displaystyle n}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n">个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle k}"><semantics><annotation encoding="application/x-tex">{\displaystyle k}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">的满二叉树，序号为1到<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n}"><semantics><annotation encoding="application/x-tex">{\displaystyle n}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n">的节点一对一对应时，称为<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>。对任何一棵非空的二叉树<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle T}"><semantics><annotation encoding="application/x-tex">{\displaystyle T}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0" aria-hidden="true" alt="T">，如果其叶片（终端节点）数为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n_{0}}"><semantics><annotation encoding="application/x-tex">{\displaystyle n_{0}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/63584d203ecb012a7bcb90f422408bbfe4018956" aria-hidden="true" alt="n_0">，分支度为2的节点数为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n_{2}}"><semantics><annotation encoding="application/x-tex">{\displaystyle n_{2}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/840e456e3058bc0be28e5cf653b170cdbfcc3be4" aria-hidden="true" alt="n_{2}">，则<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n_{0}=n_{2}+1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n_{0}=n_{2}+1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aa746d23c7cab9729c356a8e12e734e03de9fa64" aria-hidden="true" alt="{\displaystyle n_{0}=n_{2}+1}">。</p><p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p><p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" title="二叉搜索树">二叉搜索树</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%A0%86%E7%A9%8D" title="二叉堆">二叉堆</a>，并应用于高效率的搜索和排序。</p> ",
            "assembleText":"二叉树的第 {\displaystyle i}层至多拥有 {\displaystyle 2^{i-1}}个节点；深度为 {\displaystyle k}的二叉树至多总共有 {\displaystyle 2^{\begin{aligned}(k+1)\end{aligned}}-1}个节点（定义根节点所在深度  {\displaystyle k_{0}=0}），而总计拥有节点数匹配的，称为“满二叉树”；深度为 {\displaystyle k}有 {\displaystyle n}个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度 {\displaystyle k}的满二叉树，序号为1到 {\displaystyle n}的节点一对一对应时，称为完全二叉树。对任何一棵非空的二叉树 {\displaystyle T}，如果其叶片（终端节点）数为 {\displaystyle n_{0}}，分支度为2的节点数为 {\displaystyle n_{2}}，则 {\displaystyle n_{0}=n_{2}+1}。 与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。 二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。",
            "assembleScratchTime":"2019-03-15 20:54:22",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2861914,
            "assembleContent":"<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>是一个有根<a href="https://zh.wikipedia.org/wiki/%E6%A8%B9_(%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B)" title="树 (数据结构)">树</a>，并且每个节点最多有2个子节点。非空的<a>二叉树</a>，若树叶总数为 n0，分支度为2的总数为 n2，则 n0 = n2 + 1。</p><p><a href="https://zh.wikipedia.org/wiki/File:BinaryTree_leaf.jpg"><img alt="BinaryTree leaf.jpg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/BinaryTree_leaf.jpg/300px-BinaryTree_leaf.jpg" decoding="async" width="300" height="258" srcset="//upload.wikimedia.org/wikipedia/commons/b/b1/BinaryTree_leaf.jpg 1.5x"></a></p><p>一棵深度为k，且有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&action=edit&redlink=1" title="满二叉树（页面不存在）">满二叉树</a>（Full Binary Tree）。这种树的特点是每一层上的节点数都是最大节点数。而在一棵<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%A8%B9" title="二叉树">二叉树</a>为<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>（Complete Binary Tree）。具有n个节点的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>的深度为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle log_{2}n+1}"><semantics><annotation encoding="application/x-tex">{\displaystyle log_{2}n+1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b70df35ef7bd93a0bd0111f03a49f945b8afeb94" aria-hidden="true" alt="log_2n+1">。深度为k的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a>，至少有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{\begin{aligned}k\end{aligned}}}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{\begin{aligned}k\end{aligned}}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d38f350af2beda207bb91fbe737d7ae0d104e590" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k\end{aligned}}}">个节点，至多有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f24729d4eae59094b7ed114e09dcbf142f32cde8" aria-hidden="true" alt="{\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}">个节点。</p><p><a href="https://zh.wikipedia.org/wiki/File:FullBT_CompleteBT.jpg"><img alt="FullBT CompleteBT.jpg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/FullBT_CompleteBT.jpg/400px-FullBT_CompleteBT.jpg" decoding="async" width="400" height="206" srcset="//upload.wikimedia.org/wikipedia/commons/7/7d/FullBT_CompleteBT.jpg 1.5x"></a></p><table border="1"><tbody><tr><th></th><th><a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a></th><th><a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&action=edit&redlink=1" title="满二叉树（页面不存在）">满二叉树</a></th></tr><tr><th>总节点k</th><td><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{h-1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{h-1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9d54cb426257243ebfc579c75d0037d921ec0140" aria-hidden="true" alt="2^{h-1}"><= k <= <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{h}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{h}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62" aria-hidden="true" alt="2^h-1"></td><td>k = <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2^{h}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2^{h}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62" aria-hidden="true" alt="2^h-1"></td></tr><tr><th>树高h</th><td>h = <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle log_{2}k+1}"><semantics><annotation encoding="application/x-tex">{\displaystyle log_{2}k+1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5883a4ab8331795e03ffeefc6c7d3f2ab10e3e4c" aria-hidden="true" alt="log_2k+1"></td><td>h = <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle log_{2}(k+1)}"><semantics><annotation encoding="application/x-tex">{\displaystyle log_{2}(k+1)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4c2c5a0349015bc5c930649e2dfa1ba5704712da" aria-hidden="true" alt="log_2(k+1)"></td></tr></tbody></table><p><br></p> ",
            "assembleText":"二叉树是一个有根树，并且每个节点最多有2个子节点。非空的二叉树，若树叶总数为 n0，分支度为2的总数为 n2，则 n0 = n2 + 1。 一棵深度为k，且有 {\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}个节点的二叉树，称为满二叉树（Full Binary Tree）。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树（Complete Binary Tree）。具有n个节点的完全二叉树的深度为 {\displaystyle log_{2}n+1}。深度为k的完全二叉树，至少有 {\displaystyle 2^{\begin{aligned}k\end{aligned}}}个节点，至多有 {\displaystyle 2^{\begin{aligned}k+1\end{aligned}}-1}个节点。 完全二叉树 满二叉树 总节点k {\displaystyle 2^{h-1}}<= k <=  {\displaystyle 2^{h}-1} k =  {\displaystyle 2^{h}-1} 树高h h =  {\displaystyle log_{2}k+1} h =  {\displaystyle log_{2}(k+1)}",
            "assembleScratchTime":"2019-03-15 20:55:27",
            "facetId":558478,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2862127,
            "assembleContent":"<h3>辨析</h3><div><p>二叉树不是树的一种特殊情形，尽管其与树有许多相似之处，但树和二叉树有两个主要差别：</p><p>1. 树中结点的最大度数没有限制，而二叉树结点的最大度数为2；</p><p>2. 树的结点无左、右之分，而二叉树的结点有左、右之分。</p></div> ",
            "assembleText":"辨析 二叉树不是树的一种特殊情形，尽管其与树有许多相似之处，但树和二叉树有两个主要差别： 1. 树中结点的最大度数没有限制，而二叉树结点的最大度数为2； 2. 树的结点无左、右之分，而二叉树的结点有左、右之分。",
            "assembleScratchTime":"2019-03-16 22:22:24",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862130,
            "assembleContent":"<p>深度为h的二叉树最多有<a href="javascript:"><img title="" alt="" width="38" mark="bd_formula" ishandle="1" src="https://pic.baike.soso.com/ugc/baikepic2/3091/20160718002649-676323286.jpg/0"></a>个结点(h>=1)，最少有h个结点；  <br></p> ",
            "assembleText":"深度为h的二叉树最多有个结点(h>=1)，最少有h个结点；  ",
            "assembleScratchTime":"2019-03-16 22:23:20",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862131,
            "assembleContent":"<p>对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；  <br></p> ",
            "assembleText":"对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；  ",
            "assembleScratchTime":"2019-03-16 22:23:28",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862132,
            "assembleContent":"<p>具有n个结点的<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4838495&ss_c=ssc.citiao.link">完全二叉树</a>的深度为<a href="javascript:"><img title="" alt="" width="76" mark="bd_formula" ishandle="1" src="https://pic.baike.soso.com/ugc/baikepic2/31266/20180414123753-1093989209_png_76_18_443.jpg/0"></a>（注：[ ]表示向下取整）  <br></p> ",
            "assembleText":"具有n个结点的完全二叉树的深度为（注：[ ]表示向下取整）  ",
            "assembleScratchTime":"2019-03-16 22:23:38",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862133,
            "assembleContent":"<p>有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：</p><p>若I为结点编号则 如果I>1，则其父结点的编号为I/2；</p><p><a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=74160810&ss_c=ssc.citiao.link">如果2</a>*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子；</p><p>如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。</p> ",
            "assembleText":"有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I>1，则其父结点的编号为I/2； 如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子； 如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。",
            "assembleScratchTime":"2019-03-16 22:23:53",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862134,
            "assembleContent":"<p>给定N个节点，能构成h(N)种不同的二叉树。</p><p>h(N)为<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=9693847&ss_c=ssc.citiao.link">卡特兰数</a>的第N项。h(n)=C(2*n，n)/(n+1)。</p> ",
            "assembleText":"给定N个节点，能构成h(N)种不同的二叉树。 h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。",
            "assembleScratchTime":"2019-03-16 22:24:05",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862135,
            "assembleContent":"<p>设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i<sup><a href="https://baike.sogou.com/v111776.htm#quote2">[2]</a></sup>  <br></p> ",
            "assembleText":"设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i[2]  ",
            "assembleScratchTime":"2019-03-16 22:24:16",
            "facetId":558478,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865316,
            "assembleContent":"<div><ul><li>The number of nodes <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n}"><semantics><annotation encoding="application/x-tex">{\displaystyle n}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n"> in a full binary tree, is at least <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n=2h+1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n=2h+1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eec2ded95419673d606fd2d443fb1f9a8b68f224" aria-hidden="true" alt="{\displaystyle n=2h+1}"> and at most <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n=2^{h+1}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n=2^{h+1}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3558d5feb47029b11259917bbb81b6c14a5da484" aria-hidden="true" alt="n=2^{h+1}-1">, where <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle h}"><semantics><annotation encoding="application/x-tex">{\displaystyle h}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b26be3e694314bc90c3215047e4a2010c6ee184a" aria-hidden="true" alt="h"> is the <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms#H" title="Glossary of graph theory terms">height</a> of the tree. A tree consisting of only a root node has a height of 0.</li></ul></div> ",
            "assembleText":"The number of nodes  {\displaystyle n} in a full binary tree, is at least  {\displaystyle n=2h+1} and at most  {\displaystyle n=2^{h+1}-1}, where  {\displaystyle h} is the height of the tree. A tree consisting of only a root node has a height of 0.",
            "assembleScratchTime":"2019-03-24 21:31:19",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865318,
            "assembleContent":"<ul><li>The number of leaf nodes <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle l}"><semantics><annotation encoding="application/x-tex">{\displaystyle l}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac" aria-hidden="true" alt="l"> in a perfect binary tree, is <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle l=(n+1)/2}"><semantics><annotation encoding="application/x-tex">{\displaystyle l=(n+1)/2}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/52f9a12bb66ec9a46656d9f008dfce4219375897" aria-hidden="true" alt="l=(n+1)/2"> because the number of non-leaf (a.k.a. internal) nodes <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3c680ab535c09730df31abcac66dfe98f93215b5" aria-hidden="true" alt="n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1">.</li></ul> ",
            "assembleText":"The number of leaf nodes  {\displaystyle l} in a perfect binary tree, is  {\displaystyle l=(n+1)/2} because the number of non-leaf (a.k.a. internal) nodes  {\displaystyle n-l=\sum _{k=0}^{\log _{2}(l)-1}2^{k}=2^{\log _{2}(l)}-1=l-1}.",
            "assembleScratchTime":"2019-03-24 21:31:28",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865320,
            "assembleContent":"<ul><li>This means that a perfect binary tree with <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle l}"><semantics><annotation encoding="application/x-tex">{\displaystyle l}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/829091f745070b9eb97a80244129025440a1cfac" aria-hidden="true" alt="l"> leaves has <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n=2l-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n=2l-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6c6e89428a9bb787bd2d029f3bb0740c75c45da3" aria-hidden="true" alt="n=2l-1"> nodes.</li></ul> ",
            "assembleText":"This means that a perfect binary tree with  {\displaystyle l} leaves has  {\displaystyle n=2l-1} nodes.",
            "assembleScratchTime":"2019-03-24 21:31:41",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865322,
            "assembleContent":"<p>In a <b>balanced</b> full binary tree, <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil }"><semantics><annotation encoding="application/x-tex">{\displaystyle h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil }</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0c2c3b8d442f7a10ba77ef6ddd5dc42f9a85c9ef" aria-hidden="true" alt="h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil "> (see <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions" title="Floor and ceiling functions">ceiling function</a>).  <br></p> ",
            "assembleText":"In a balanced full binary tree,  {\displaystyle h=\lceil \log _{2}(l)\rceil +1=\lceil \log _{2}((n+1)/2)\rceil +1=\lceil \log _{2}(n+1)\rceil } (see ceiling function).  ",
            "assembleScratchTime":"2019-03-24 21:31:53",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865323,
            "assembleContent":"<ul><li>In a <b>perfect</b> full binary tree, <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle l=2^{h}}"><semantics><annotation encoding="application/x-tex">{\displaystyle l=2^{h}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0c75a8ef2ff68abf9711a5952953e0ee7ab98284" aria-hidden="true" alt="l=2^{h}"> thus <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle n=2^{h+1}-1}"><semantics><annotation encoding="application/x-tex">{\displaystyle n=2^{h+1}-1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3558d5feb47029b11259917bbb81b6c14a5da484" aria-hidden="true" alt="n=2^{h+1}-1">.</li></ul> ",
            "assembleText":"In a perfect full binary tree,  {\displaystyle l=2^{h}} thus  {\displaystyle n=2^{h+1}-1}.",
            "assembleScratchTime":"2019-03-24 21:32:02",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865325,
            "assembleContent":"<div><ul><li>The maximum possible number of null links (i.e., absent children of the nodes) in a <b>complete</b> binary tree of <i>n</i> nodes is (<i>n</i>+1), where only 1 node exists in bottom-most level to the far left.</li></ul></div> ",
            "assembleText":"The maximum possible number of null links (i.e., absent children of the nodes) in a complete binary tree of n nodes is (n+1), where only 1 node exists in bottom-most level to the far left.",
            "assembleScratchTime":"2019-03-24 21:32:11",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865326,
            "assembleContent":"<div><ul><li>The number of internal nodes in a <b>complete</b> binary tree of <i>n</i> nodes is <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle \lfloor n/2\rfloor }"><semantics><annotation encoding="application/x-tex">{\displaystyle \lfloor n/2\rfloor }</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c86b5dc915aaa6792f2a7d3ed1c165c555256c7a" aria-hidden="true" alt="\lfloor n/2\rfloor ">.</li></ul></div> ",
            "assembleText":"The number of internal nodes in a complete binary tree of n nodes is  {\displaystyle \lfloor n/2\rfloor }.",
            "assembleScratchTime":"2019-03-24 21:32:19",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865327,
            "assembleContent":"<p>For any non-empty binary tree with <i>n</i><sub>0</sub> leaf nodes and <i>n</i><sub>2</sub> nodes of degree 2, <i>n</i><sub>0</sub> = <i>n</i><sub>2</sub> + 1.  <br></p> ",
            "assembleText":"For any non-empty binary tree with n0 leaf nodes and n2 nodes of degree 2, n0 = n2 + 1.  ",
            "assembleScratchTime":"2019-03-24 21:32:31",
            "facetId":558478,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2850622,
            "assembleContent":"<p><strong>1.二叉树</strong> </p><p>2. <a href="http://baike.baidu.com/view/389459.htm" target="_blank" title="二叉查找树" style="background-color: rgb(255, 255, 255);">二叉查找树</a>   </p><p>3.<a href="http://baike.baidu.com/view/6667519.htm" target="_blank" title="笛卡尔树" style="background-color: rgb(255, 255, 255);">笛卡尔树</a>  </p><p>4.<a href="http://baike.baidu.com/searchword/?word=Top%20tree&pic=1&sug=1&enc=utf8" target="_blank" title="待创建" style="background-color: rgb(255, 255, 255);">Top tree</a> </p><p>5. <a href="http://baike.baidu.com/searchword/?word=T%E6%A0%91&pic=1&sug=1&enc=utf8" target="_blank" title="待创建" style="background-color: rgb(255, 255, 255);">T树</a><br></p> ",
            "assembleText":"1.二叉树  2. 二叉查找树    3.笛卡尔树   4.Top tree  5. T树",
            "assembleScratchTime":"2019-02-22 23:46:03",
            "facetId":558491,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin#3",
            "type":"text"
        },
        {
            "assembleId":2861751,
            "assembleContent":"<p><b><i>满二叉树</i></b></p><p><b>定义</b>：高度为h，并且由 <img src="https://www.zhihu.com/equation?tex=2%5Eh" alt="2^h" eeimg="1"> –1个结点的二叉树，被称为满二叉树，其实不难看出，满二叉树的结点的度要么为0（叶子结点），要么为2（非叶子结点）</p><figure><img src="https://pic4.zhimg.com/80/v2-43b30ac60e21a4a557882dc41cc7c91f_hd.jpg" 1672"="" width="1672" style="max-width:50%;"></figure> ",
            "assembleText":"满二叉树 定义：高度为h，并且由  –1个结点的二叉树，被称为满二叉树，其实不难看出，满二叉树的结点的度要么为0（叶子结点），要么为2（非叶子结点）",
            "assembleScratchTime":"2019-03-15 19:37:17",
            "facetId":558491,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/29867652",
            "type":"text"
        },
        {
            "assembleId":2861752,
            "assembleContent":"<p><b><i>完全二叉树</i></b></p><p><b>定义</b>：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。</p><p><b>特点</b>：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。</p><figure><img src="https://pic2.zhimg.com/80/v2-fb577e5b43561bf7f144750811aa7065_hd.jpg" 1608"="" width="1608" style="max-width:50%;"></figure> ",
            "assembleText":"完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。",
            "assembleScratchTime":"2019-03-15 19:37:44",
            "facetId":558491,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/29867652",
            "type":"text"
        },
        {
            "assembleId":2861988,
            "assembleContent":"<p>平衡二叉树：具有 N 个节点且高度为 O(log N) 的二叉树。例如 AVL 树，红黑树。  <br></p> ",
            "assembleText":"平衡二叉树：具有 N 个节点且高度为 O(log N) 的二叉树。例如 AVL 树，红黑树。  ",
            "assembleScratchTime":"2019-03-16 20:51:06",
            "facetId":558491,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861989,
            "assembleContent":"<p>退化的树，只有一边孩子的树。和链表类似。  <br></p> ",
            "assembleText":"退化的树，只有一边孩子的树。和链表类似。  ",
            "assembleScratchTime":"2019-03-16 20:51:15",
            "facetId":558491,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2862111,
            "assembleContent":"<p>一棵深度为k，且有2^k-1个节点的二叉树，称为<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8045596&ss_c=ssc.citiao.link">满二叉树</a>。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4838495&ss_c=ssc.citiao.link">完全二叉树</a>。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2<sup>k-1</sup>个叶子节点，至多有2<sup>k</sup>-1个节点  <br></p> ",
            "assembleText":"一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子节点，至多有2k-1个节点  ",
            "assembleScratchTime":"2019-03-16 22:08:20",
            "facetId":558491,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862121,
            "assembleContent":"<p>完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=168021632&ss_c=ssc.citiao.link">叶子结点</a>，并且叶子结点都是从左到右依次排布，这就是完全二叉树。  <br></p> ",
            "assembleText":"完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。  ",
            "assembleScratchTime":"2019-03-16 22:21:13",
            "facetId":558491,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862124,
            "assembleContent":"<p><a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8045596&ss_c=ssc.citiao.link">满二叉树</a>——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。  <br></p> ",
            "assembleText":"满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。  ",
            "assembleScratchTime":"2019-03-16 22:21:27",
            "facetId":558491,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2862126,
            "assembleContent":"<p><a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7498523&ss_c=ssc.citiao.link">平衡二叉树</a>——平衡二叉树又被称为<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71134459&ss_c=ssc.citiao.link">AVL树</a>（区别于AVL算法），它是一棵<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=5592449&ss_c=ssc.citiao.link">二叉排序树</a>，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=844985&ss_c=ssc.citiao.link">绝对值</a>不超过1，并且左右两个子树都是一棵平衡二叉树  <br></p> ",
            "assembleText":"平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树  ",
            "assembleScratchTime":"2019-03-16 22:21:54",
            "facetId":558491,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865298,
            "assembleContent":"<ul><li>A <b><span id="rooted">rooted</span></b> binary <a href="https://en.wikipedia.org/wiki/Tree_data_structure" title="Tree data structure">tree</a> has a <a href="https://en.wikipedia.org/wiki/Root_node" title="Root node">root node</a> and every node has at most two children.</li></ul><div><br>An <a href="https://en.wikipedia.org/wiki/Ancestry_chart" title="Ancestry chart" style="background-color: rgb(255, 255, 255);">ancestry chart</a> which maps to a perfect depth-4 binary tree.<br></div><div><div><a href="https://en.wikipedia.org/wiki/File:Waldburg_Ahnentafel.jpg" title="Enlarge"></a></div></div><ul><li>A <b><span id="full">full</span></b> binary tree (sometimes referred to as a <b>proper</b><sup id="cite_ref-15"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-15">[15]</a></sup> or <b>plane</b> binary tree)<sup id="cite_ref-16"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-16">[16]</a></sup><sup id="cite_ref-17"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-17">[17]</a></sup> is a tree in which every node has either 0 or 2 children. Another way of defining a full binary tree is a <a href="https://en.wikipedia.org/wiki/Recursive_definition" title="Recursive definition">recursive definition</a>. A full binary tree is either:<sup id="cite_ref-Rosen2011_11-1"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Rosen2011-11">[11]</a></sup><ul><li>A single vertex.</li><li>A tree whose root note has two subtrees, both of which are full binary trees..</li></ul></li></ul> ",
            "assembleText":"A rooted binary tree has a root node and every node has at most two children. An ancestry chart which maps to a perfect depth-4 binary tree. A full binary tree (sometimes referred to as a proper[15] or plane binary tree)[16][17] is a tree in which every node has either 0 or 2 children. Another way of defining a full binary tree is a recursive definition. A full binary tree is either:[11] A single vertex. A tree whose root note has two subtrees, both of which are full binary trees..",
            "assembleScratchTime":"2019-03-24 21:30:08",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865300,
            "assembleContent":"<ul><li>In a <b><span id="complete">complete</span></b> binary tree every level, <i>except possibly the last</i>, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup><i>h</i></sup> nodes at the last level <i>h</i>.<sup id="cite_ref-complete_binary_tree_18-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-complete_binary_tree-18">[18]</a></sup> An alternative definition is a perfect tree whose rightmost leaves (perhaps all) have been removed. Some authors use the term <b>complete</b> to refer instead to a perfect binary tree as defined above, in which case they call this type of tree an <b>almost complete</b>binary tree or <b>nearly complete</b> binary tree.<sup id="cite_ref-almost_complete_binary_tree_19-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-almost_complete_binary_tree-19">[19]</a></sup><sup id="cite_ref-nearly_complete_binary_tree_20-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-nearly_complete_binary_tree-20">[20]</a></sup> A complete binary tree can be efficiently represented using an array.<sup id="cite_ref-complete_binary_tree_18-1"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-complete_binary_tree-18">[18]</a></sup></li></ul> ",
            "assembleText":"In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes at the last level h.[18] An alternative definition is a perfect tree whose rightmost leaves (perhaps all) have been removed. Some authors use the term complete to refer instead to a perfect binary tree as defined above, in which case they call this type of tree an almost completebinary tree or nearly complete binary tree.[19][20] A complete binary tree can be efficiently represented using an array.[18]",
            "assembleScratchTime":"2019-03-24 21:30:21",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865303,
            "assembleContent":"<ul><li>A <b><span id="perfect">perfect</span></b> binary tree is a binary tree in which all interior nodes have two children <i>and</i> all leaves have the same <i>depth</i> or same <i>level</i>.<sup id="cite_ref-21"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-21">[21]</a></sup> An example of a perfect binary tree is the (non-incestuous) <a href="https://en.wikipedia.org/wiki/Ancestry_chart" title="Ancestry chart">ancestry chart</a> of a person to a given depth, as each person has exactly two biological parents (one mother and one father).</li></ul> ",
            "assembleText":"A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level.[21] An example of a perfect binary tree is the (non-incestuous) ancestry chart of a person to a given depth, as each person has exactly two biological parents (one mother and one father).",
            "assembleScratchTime":"2019-03-24 21:30:30",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865306,
            "assembleContent":"<ul><li>In the <b>infinite complete</b> binary tree, every node has two children (and so the set of levels is <a href="https://en.wikipedia.org/wiki/Countably_infinite" title="Countably infinite">countably infinite</a>). The set of all nodes is countably infinite, but the set of all infinite paths from the root is uncountable, having the <a href="https://en.wikipedia.org/wiki/Cardinality_of_the_continuum" title="Cardinality of the continuum">cardinality of the continuum</a>. These paths correspond by an order-preserving <a href="https://en.wikipedia.org/wiki/Bijection" title="Bijection">bijection</a> to the points of the <a href="https://en.wikipedia.org/wiki/Cantor_set" title="Cantor set">Cantor set</a>, or (using the example of a <a href="https://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree" title="Stern–Brocot tree">Stern–Brocot tree</a>) to the set of positive <a href="https://en.wikipedia.org/wiki/Irrational_number" title="Irrational number">irrational numbers</a>.</li></ul> ",
            "assembleText":"In the infinite complete binary tree, every node has two children (and so the set of levels is countably infinite). The set of all nodes is countably infinite, but the set of all infinite paths from the root is uncountable, having the cardinality of the continuum. These paths correspond by an order-preserving bijection to the points of the Cantor set, or (using the example of a Stern–Brocot tree) to the set of positive irrational numbers.",
            "assembleScratchTime":"2019-03-24 21:30:42",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865309,
            "assembleContent":"<div><ul><li>A <b>balanced</b> binary tree is a binary tree structure in which the left and right subtrees of every node differ in height by no more than 1.<sup id="cite_ref-22"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-22">[22]</a></sup> One may also consider binary trees where no leaf is much farther away from the root than any other leaf. (Different balancing schemes allow different definitions of "much farther".<sup id="cite_ref-23"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-23">[23]</a></sup>)</li></ul></div> ",
            "assembleText":"A balanced binary tree is a binary tree structure in which the left and right subtrees of every node differ in height by no more than 1.[22] One may also consider binary trees where no leaf is much farther away from the root than any other leaf. (Different balancing schemes allow different definitions of "much farther".[23])",
            "assembleScratchTime":"2019-03-24 21:30:50",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865312,
            "assembleContent":"<ul><li>A <b>degenerate</b> (or <b>pathological</b>) tree is where each parent node has only one associated child node.<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed"><span title="This claim needs references to reliable sources. (March 2015)">citation needed</span></a></i>]</sup> This means that performance-wise<sup>[<i><a href="https://en.wikipedia.org/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify"><span title="The text near this tag may need clarification or removal of jargon. (March 2015)">clarification needed</span></a></i>]</sup>, the tree will behave like a <a href="https://en.wikipedia.org/wiki/Linked_list" title="Linked list">linked list</a> data structure.</li></ul> ",
            "assembleText":"A degenerate (or pathological) tree is where each parent node has only one associated child node.[citation needed] This means that performance-wise[clarification needed], the tree will behave like a linked list data structure.",
            "assembleScratchTime":"2019-03-24 21:31:02",
            "facetId":558491,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2850595,
            "assembleContent":"<h3><span id="順序存儲表示">顺序存储表示</span></h3><div><div><a href="https://zh.wikipedia.org/wiki/File:Binary_tree_in_array.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/220px-Binary_tree_in_array.svg.png" decoding="async" width="220" height="55" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/330px-Binary_tree_in_array.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/440px-Binary_tree_in_array.svg.png 2x"></a><div><div><a href="https://zh.wikipedia.org/wiki/File:Binary_tree_in_array.svg" title="放大"></a></div>一个存储在数组中的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树">完全二叉树</a></div></div></div><p>二叉树可以用<a href="https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97" title="数组">数组</a>或<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" title="链表">链接串列</a>来存储，若是<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&action=edit&redlink=1" title="满二叉树（页面不存在）">满二叉树</a>就能紧凑排列而不浪费空间。如果某个节点的索引为<var>i</var>，（假设根节点的索引为0）则在它左子节点的索引会是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" aria-hidden="true" alt="{\displaystyle 2i+1}">，以及右子节点会是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a756deaef520ee23fe2b1232c90957f55ec9d92b" aria-hidden="true" alt="{\displaystyle 2i+2}">；而它的父节点（如果有）索引则为<i><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35dc2d601bbd9aff8f1ed1c4b2323122f2403317" aria-hidden="true" alt="{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }"></i>。这种方法更有利于紧凑存储和更好的<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%AA%E5%95%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7&action=edit&redlink=1" title="访问的局部性（页面不存在）">访问的局部性</a>，特别是在<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" title="树的遍历">前序遍历</a>中。然而，它需要连续的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%98%E5%84%B2%E7%A9%BA%E9%96%93&action=edit&redlink=1" title="存储空间（页面不存在）">存储空间</a>，这样在存储高度为<i>h</i>的<i>n</i>个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62" aria-hidden="true" alt="2^h-1">的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。</p>  ",
            "assembleText":"顺序存储表示 一个存储在数组中的完全二叉树 二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为i，（假设根节点的索引为0）则在它左子节点的索引会是，以及右子节点会是；而它的父节点（如果有）索引则为。这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为h的n个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。",
            "assembleScratchTime":"2019-02-22 23:27:36",
            "facetId":558492,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850596,
            "assembleContent":"<h3><pre> /* 二元樹的順序存儲表示 */
 #define MAX_TREE_SIZE 100 /* 二元樹的最大節點數 */
 typedef TElemType SqBiTree[MAX_TREE_SIZE]; /* 0号单元存储根节点 */

 typedef struct
 {
   int level,order; /* 節點的層，本層序號(按[[滿二元樹]]計算) */
 }position;</pre></h3>  ",
            "assembleText":"/* 二元樹的順序存儲表示 */
 #define MAX_TREE_SIZE 100 /* 二元樹的最大節點數 */
 typedef TElemType SqBiTree[MAX_TREE_SIZE]; /* 0号单元存储根节点 */

 typedef struct
 {
   int level,order; /* 節點的層，本層序號(按[[滿二元樹]]計算) */
 }position;",
            "assembleScratchTime":"2019-02-22 23:28:02",
            "facetId":558492,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850615,
            "assembleContent":"<h3><span id="三叉鏈表存儲表示">三叉链表存储表示</span></h3><div><div><a href="https://zh.wikipedia.org/wiki/File:3clb.jpg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/3clb.jpg/220px-3clb.jpg" decoding="async" width="220" height="106" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/6/60/3clb.jpg/330px-3clb.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/6/60/3clb.jpg/440px-3clb.jpg 2x"></a><div><div><a href="https://zh.wikipedia.org/wiki/File:3clb.jpg" title="放大"></a></div>基于三叉链表的二叉树的逻辑结构</div></div></div><p>改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。</p> ",
            "assembleText":"三叉链表存储表示 基于三叉链表的二叉树的逻辑结构 改进于二叉链表，增加父节点的指引，能更好地实现节点间的访问，不过算法相对复杂。 当二叉树用三叉链表表示时，有N个结点，就会有N+2个空指针。",
            "assembleScratchTime":"2019-02-22 23:34:43",
            "facetId":558492,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2865331,
            "assembleContent":"<h3><span id="Nodes_and_references">Nodes and references</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=8" title="Edit section: Nodes and references">edit</a>]</h3><p>In a language with <a href="https://en.wikipedia.org/wiki/Record_(computer_science)" title="Record (computer science)">records</a> and <a href="https://en.wikipedia.org/wiki/Reference_(computer_science)" title="Reference (computer science)">references</a>, binary trees are typically constructed by having a tree node structure which contains some data and references to its left child and its right child. Sometimes it also contains a reference to its unique parent. If a node has fewer than two children, some of the child pointers may be set to a special null value, or to a special <a href="https://en.wikipedia.org/wiki/Sentinel_node" title="Sentinel node">sentinel node</a>.</p><p>This method of storing binary trees wastes a fair bit of memory, as the pointers will be null (or point to the sentinel) more than half the time; a more conservative representation alternative is <a href="https://en.wikipedia.org/wiki/Threaded_binary_tree" title="Threaded binary tree">threaded binary tree</a>.<sup id="cite_ref-Samanta2004_25-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Samanta2004-25">[25]</a></sup></p><p>In languages with <a href="https://en.wikipedia.org/wiki/Tagged_union" title="Tagged union">tagged unions</a> such as <a href="https://en.wikipedia.org/wiki/ML_(programming_language)" title="ML (programming language)">ML</a>, a tree node is often a tagged union of two types of nodes, one of which is a 3-tuple of data, left child, and right child, and the other of which is a "leaf" node, which contains no data and functions much like the null value in a language with pointers. For example, the following line of code in <a href="https://en.wikipedia.org/wiki/OCaml" title="OCaml">OCaml</a> (an ML dialect) defines a binary tree that stores a character in each node.<sup id="cite_ref-Scott2009_26-0"><a href="https://en.wikipedia.org/wiki/Binary_tree#cite_note-Scott2009-26">[26]</a></sup></p><div dir="ltr"><pre>type chr_tree = Empty | Node of char * chr_tree * chr_tree</pre></div> ",
            "assembleText":"Nodes and references[edit] In a language with records and references, binary trees are typically constructed by having a tree node structure which contains some data and references to its left child and its right child. Sometimes it also contains a reference to its unique parent. If a node has fewer than two children, some of the child pointers may be set to a special null value, or to a special sentinel node. This method of storing binary trees wastes a fair bit of memory, as the pointers will be null (or point to the sentinel) more than half the time; a more conservative representation alternative is threaded binary tree.[25] In languages with tagged unions such as ML, a tree node is often a tagged union of two types of nodes, one of which is a 3-tuple of data, left child, and right child, and the other of which is a "leaf" node, which contains no data and functions much like the null value in a language with pointers. For example, the following line of code in OCaml (an ML dialect) defines a binary tree that stores a character in each node.[26] type chr_tree = Empty | Node of char * chr_tree * chr_tree",
            "assembleScratchTime":"2019-03-24 21:33:07",
            "facetId":558492,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2865332,
            "assembleContent":"<h3><span id="Arrays">Arrays</span>[<a href="https://en.wikipedia.org/w/index.php?title=Binary_tree&action=edit&section=9" title="Edit section: Arrays">edit</a>]</h3><p>Binary trees can also be stored in breadth-first order as an <a href="https://en.wikipedia.org/wiki/Implicit_data_structure" title="Implicit data structure">implicit data structure</a> in <a href="https://en.wikipedia.org/wiki/Array_data_structure" title="Array data structure">arrays</a>, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index <i>i</i>, its children are found at indices <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2i+1}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2i+1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" aria-hidden="true" alt="2i+1"> (for the left child) and <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle 2i+2}"><semantics><annotation encoding="application/x-tex">{\displaystyle 2i+2}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a756deaef520ee23fe2b1232c90957f55ec9d92b" aria-hidden="true" alt="2i+2"> (for the right), while its parent (if any) is found at index <i><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }"><semantics><annotation encoding="application/x-tex">{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35dc2d601bbd9aff8f1ed1c4b2323122f2403317" aria-hidden="true" alt="\left\lfloor {\frac {i-1}{2}}\right\rfloor "></i> (assuming the root has index zero). This method benefits from more compact storage and better <a href="https://en.wikipedia.org/wiki/Locality_of_reference" title="Locality of reference">locality of reference</a>, particularly during a preorder traversal. However, it is expensive to grow and wastes space proportional to 2<sup><i>h</i></sup> - <i>n</i> for a tree of depth <i>h</i> with <i>n</i> nodes.</p><p>This method of storage is often used for <a href="https://en.wikipedia.org/wiki/Binary_heap" title="Binary heap">binary heaps</a>. No space is wasted because nodes are added in breadth-first order.</p><center><a href="https://en.wikipedia.org/wiki/File:Binary_tree_in_array.svg" title="A small complete binary tree stored in an array"><img alt="A small complete binary tree stored in an array" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/300px-Binary_tree_in_array.svg.png" decoding="async" width="300" height="75" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/450px-Binary_tree_in_array.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/600px-Binary_tree_in_array.svg.png 2x"></a></center> ",
            "assembleText":"Arrays[edit] Binary trees can also be stored in breadth-first order as an implicit data structure in arrays, and if the tree is a complete binary tree, this method wastes no space. In this compact arrangement, if a node has an index i, its children are found at indices  {\displaystyle 2i+1} (for the left child) and  {\displaystyle 2i+2} (for the right), while its parent (if any) is found at index  {\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor } (assuming the root has index zero). This method benefits from more compact storage and better locality of reference, particularly during a preorder traversal. However, it is expensive to grow and wastes space proportional to 2h - n for a tree of depth h with n nodes. This method of storage is often used for binary heaps. No space is wasted because nodes are added in breadth-first order.",
            "assembleScratchTime":"2019-03-24 21:33:17",
            "facetId":558492,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2850617,
            "assembleContent":"<p><strong>二叉树</strong></p><p>二叉树是一种重要的数据结构，与数组、向量、链表都是一种顺序容器，它们提供了按位置访问数据的手段。但是有一个缺点，它们都是按照位置来确定数据，想要通过值来获取数据，只能通过遍历的方式。而二叉树在很大程度上解决了这个缺点，二叉树是按值来保存元素，也按值来访问元素。<br></p><p>二叉树由一个个节点组成，一个节点最多只能有两个子节点，从根节点开始左右扩散，分左子节点和右子节点，向下一直分支。</p><p>许多实际问题抽象出来的数据结构往往是二叉树的形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树是递归定义的。</p> ",
            "assembleText":"二叉树 二叉树是一种重要的数据结构，与数组、向量、链表都是一种顺序容器，它们提供了按位置访问数据的手段。但是有一个缺点，它们都是按照位置来确定数据，想要通过值来获取数据，只能通过遍历的方式。而二叉树在很大程度上解决了这个缺点，二叉树是按值来保存元素，也按值来访问元素。 二叉树由一个个节点组成，一个节点最多只能有两个子节点，从根节点开始左右扩散，分左子节点和右子节点，向下一直分支。 许多实际问题抽象出来的数据结构往往是二叉树的形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树是递归定义的。",
            "assembleScratchTime":"2019-02-22 23:37:57",
            "facetId":558512,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/hjl_heart/article/details/80146640",
            "type":"text"
        },
        {
            "assembleId":2850620,
            "assembleContent":"<div label-module="para"><div label-module="para">树的结点（node）：包含一个数据元素及若干指向子树的分支；</div><div label-module="para">孩子结点（child node）：结点的子树的根称为该结点的孩子；</div><div label-module="para">双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；</div><div label-module="para">兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；</div><div label-module="para">祖先结点: 从根到该结点的所经分支上的所有结点</div><div label-module="para">子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙</div><div label-module="para">结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；</div><div label-module="para">树的深度：树中最大的结点层</div><div label-module="para">结点的度：结点子树的个数</div><div label-module="para">树的度： 树中最大的结点度。</div><div label-module="para">叶子结点：也叫终端结点，是度为 0 的结点；</div><div label-module="para">分枝结点：度不为0的结点；</div><div label-module="para">有序树：子树有序的树，如：家族树；</div><div label-module="para">无序树：不考虑子树的顺序；</div></div> ",
            "assembleText":"树的结点（node）：包含一个数据元素及若干指向子树的分支； 孩子结点（child node）：结点的子树的根称为该结点的孩子； 双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲； 兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点； 祖先结点: 从根到该结点的所经分支上的所有结点 子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙 结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推； 树的深度：树中最大的结点层 结点的度：结点子树的个数 树的度： 树中最大的结点度。 叶子结点：也叫终端结点，是度为 0 的结点； 分枝结点：度不为0的结点； 有序树：子树有序的树，如：家族树； 无序树：不考虑子树的顺序；",
            "assembleScratchTime":"2019-02-22 23:43:33",
            "facetId":558523,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879?fr=aladdin#3",
            "type":"text"
        },
        {
            "assembleId":2865509,
            "assembleContent":"<h1>为什么给定节点个数的二叉树个数为卡特兰数？</h1><div><div><div><blockquote>给定不重复的二叉树先序遍历序列，找出不同二叉树的个数</blockquote><ul><li>首先由二叉树的<b>先序序列</b>和<b>中序序列</b>可以唯一确定一棵二叉树。<i>（中序加后序，中序加层次也可以，这里讨论题目的先序）</i></li><li>找出由该序列可以得到的中序序列个数，即我们需要的二叉树个数。</li></ul><blockquote>假设给出的先序序列为 <img src="https://www.zhihu.com/equation?tex=%5Bx_1%2C...%2Cx_n%5D" alt="[x_1,...,x_n]" eeimg="1"> </blockquote><ul><li>因为 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在先序序列的首位，也就是 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 是该二叉树的根结点。</li><li>由根节点在中序遍历中的位置，我们可以将中序序列分割成两个子序列，分别是左右子树的元素。</li><li>当 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在<b>中序序列</b>的第 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 位时<b>中序序列</b>中的<b>[1]</b>到<b>[k-1]</b>的元素都在其左子树，可以形成 <img src="https://www.zhihu.com/equation?tex=h%28k-1%29" alt="h(k-1)" eeimg="1"> 不同的树，<b>[k+1]</b>到<b>[n]</b>的元素在其右子树，可以形成 <img src="https://www.zhihu.com/equation?tex=h%28n-k%29" alt="h(n-k)" eeimg="1"> 个不同的树，则当前位置可以形成 <img src="https://www.zhihu.com/equation?tex=h%28k-1%29%C2%B7h%28n-k%29" alt="h(k-1)·h(n-k)" eeimg="1"> 棵树。</li><li>当 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 的位置不同的情况下是相互独立的，所以结果因该是 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在不同位置的相互累加。 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 的取值为<b>1~n</b>，所以结果是 </li></ul><p><img src="https://www.zhihu.com/equation?tex=h%28n%29%3Dh%280%29h%28n-1%29%2Bh%281%29h%28n-2%29%2B...%2Bh%28n-1%29h%280%29%28n%5Cge2%29" alt="h(n)=h(0)h(n-1)+h(1)h(n-2)+...+h(n-1)h(0)(n\ge2)" eeimg="1"> </p><p><br></p><p>这是一个<i><b>Catalan递推式</b></i>，通项公式为</p><p><img src="https://www.zhihu.com/equation?tex=Cn%3DC%282n%2Cn%29-C%282n%2Cn-1%29%3DC%282n%2Cn%29%2F%28n%2B1%29" alt="Cn=C(2n,n)-C(2n,n-1)=C(2n,n)/(n+1)" eeimg="1"> </p><p>通项的推导就比较复杂了，找了很久看到一个比较好理解的<a href="https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_6917f47301010cno.html" target="_blank" rel="nofollow noreferrer">折现法——Catalan通项的推导</a></p><p><br></p><p>主要是一个<b>分治思想</b></p><p>问题规模为n，先固定一个元素，然后将剩下n-1个元素拆分成两个问题，根据固定的元素位置不同，得到更小的可以表示为Catalan数的递推式问题。</p></div><br><br>作者：Jett<br>链接：https://www.zhihu.com/question/275456390/answer/494024465<br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></div>  ",
            "assembleText":"为什么给定节点个数的二叉树个数为卡特兰数？ 给定不重复的二叉树先序遍历序列，找出不同二叉树的个数 首先由二叉树的先序序列和中序序列可以唯一确定一棵二叉树。（中序加后序，中序加层次也可以，这里讨论题目的先序） 找出由该序列可以得到的中序序列个数，即我们需要的二叉树个数。 假设给出的先序序列为 因为 出现在先序序列的首位，也就是 是该二叉树的根结点。 由根节点在中序遍历中的位置，我们可以将中序序列分割成两个子序列，分别是左右子树的元素。 当 出现在中序序列的第 位时中序序列中的[1]到[k-1]的元素都在其左子树，可以形成 不同的树，[k+1]到[n]的元素在其右子树，可以形成 个不同的树，则当前位置可以形成 棵树。 当 的位置不同的情况下是相互独立的，所以结果因该是 出现在不同位置的相互累加。 的取值为1~n，所以结果是 这是一个Catalan递推式，通项公式为 通项的推导就比较复杂了，找了很久看到一个比较好理解的折现法——Catalan通项的推导 主要是一个分治思想 问题规模为n，先固定一个元素，然后将剩下n-1个元素拆分成两个问题，根据固定的元素位置不同，得到更小的可以表示为Catalan数的递推式问题。 作者：Jett 链接：https://www.zhihu.com/question/275456390/answer/494024465 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
            "assembleScratchTime":"2019-03-24 22:03:12",
            "facetId":558523,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2861996,
            "assembleContent":"<h1>自然界有没有二叉树？</h1><div><div><span itemprop="text">即，每一枝儿最多出两个叉。</span></div><h1><div>上图，一棵野生的二叉树。<br><figure><noscript><img src="https://pic1.zhimg.com/50/c4447abe8ca841ae96c26335460cc89d_hd.jpg" width="392"/></noscript><img src="https://pic1.zhimg.com/80/c4447abe8ca841ae96c26335460cc89d_hd.jpg" width="392"></figure></div><br></h1></div> ",
            "assembleText":"自然界有没有二叉树？ 即，每一枝儿最多出两个叉。 上图，一棵野生的二叉树。",
            "assembleScratchTime":"2019-03-16 20:57:35",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2861997,
            "assembleContent":"<div><div><p>链表通常可以提供比数组更大的灵活性，但是由于链表是线性结构，所以很难使用它们来组织对象的分层结构。虽然栈和队列反映了某些层次，但它们是一维的。为了避免这种限制，我们来探究一种新的数据结构，称为树，树由节点和弧组成。</p><p>就像这样：</p><figure><img src="https://pic3.zhimg.com/v2-b4970411869f3c6a69bd7b37f101eb1a_b.jpg" width="587" style="max-width:50%;"><figcaption>图1-1</figcaption></figure><p>与自然界的树不同，数据结构中的树是倒过来的：根在顶部，叶子(末端节点)在底部。根是一个没有父节点只有子节点的节点，而叶节点没有子节点或者子节点是空结构。一颗树中非叶子节点我们称之为非终端节点，包括根节点。</p><p>每个节点都可以从根节点经一个唯一的弧序列到达，此弧序列被称之为路径，路径中弧的数量称之为路径的长度。节点的层次是从根节点到该节点的路径的长度加1，也就是该路径上节点的数量。树的高度(深度)是树中节点的最大层次。空结构是空树，所以空树高度为0。只有一个根节点的树的高度是1，而且该树比较特殊，它是“节点既是根也是叶子”的唯一情况。在一棵树中，如果某个节点拥有n个子节点，那么我们称该节点的度为n。树在极端情况下可以退化为链表，这种树的高度为唯一叶节点的层次。</p><p>就像这样：</p><figure><img src="https://pic3.zhimg.com/v2-4ee5b10f0eaa65b8259154e1de483066_b.jpg" width="794" style="max-width:50%;"><figcaption>图1-2</figcaption></figure><p>什么是二叉树呢？上面说的都是树的概念，节点下面可以有多个子节点，而二叉树对此做了限制。二叉树是节点可以包含最多两个子节点的树，每一个子节点都区分左子节点或右子节点。例如<b>图1-1</b>中13和23节点分别是根节点的左右子节点。</p></div></div> ",
            "assembleText":"链表通常可以提供比数组更大的灵活性，但是由于链表是线性结构，所以很难使用它们来组织对象的分层结构。虽然栈和队列反映了某些层次，但它们是一维的。为了避免这种限制，我们来探究一种新的数据结构，称为树，树由节点和弧组成。 就像这样： 图1-1 与自然界的树不同，数据结构中的树是倒过来的：根在顶部，叶子(末端节点)在底部。根是一个没有父节点只有子节点的节点，而叶节点没有子节点或者子节点是空结构。一颗树中非叶子节点我们称之为非终端节点，包括根节点。 每个节点都可以从根节点经一个唯一的弧序列到达，此弧序列被称之为路径，路径中弧的数量称之为路径的长度。节点的层次是从根节点到该节点的路径的长度加1，也就是该路径上节点的数量。树的高度(深度)是树中节点的最大层次。空结构是空树，所以空树高度为0。只有一个根节点的树的高度是1，而且该树比较特殊，它是“节点既是根也是叶子”的唯一情况。在一棵树中，如果某个节点拥有n个子节点，那么我们称该节点的度为n。树在极端情况下可以退化为链表，这种树的高度为唯一叶节点的层次。 就像这样： 图1-2 什么是二叉树呢？上面说的都是树的概念，节点下面可以有多个子节点，而二叉树对此做了限制。二叉树是节点可以包含最多两个子节点的树，每一个子节点都区分左子节点或右子节点。例如图1-1中13和23节点分别是根节点的左右子节点。",
            "assembleScratchTime":"2019-03-16 20:58:53",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2861998,
            "assembleContent":"<div><div><ul><li>完美二叉树</li></ul><p>在一棵二叉树中，如果每个非终端节点都有两个子节点，并且所有叶子节点位于同一层次，那么称之为完美二叉树。</p><p>就像这样：</p><figure><img src="https://pic1.zhimg.com/v2-b1fc3b62546b558c7eb08d9839f69f10_b.jpg" width="534"><figcaption>图1-3</figcaption></figure><p>其中非终端节点包括15/13/23，它们都有两个子节点，并且所有叶子节点都位于第3层。可以看到，完美二叉树左右子树是完美对称的。对于完美二叉树，有以下特性：</p><p>1、第i+1层的节点数为2^i</p><p>2、如果完美二叉树高度为n，那么总的节点数为2^n - 1</p><p>3、如果完美二叉树中叶子节点为m，非终端节点为k，那么m=k+1</p><p>4、如果完美二叉树中某节点下标为n，那么它的左节点下标为2n+1，右节点下标为2n+2</p><p>证明：</p><p>1、性质1可以用数学归纳法来证明，假设完美二叉树中第i层节点数为2^(i-1)，我们只要推导出第i+1层节点数为2^i即可。从定义出发，已知第i层的节点都有两个左右子节点，那么第i+1层的节点数为(2^(i-1))*2，也就是2^i，证明完毕</p><p>2、性质2由性质1衍生出来，对于高度为n的完美二叉树，节点总数为2^0+2^1+......+2^(n-1)，也就是2^n - 1，证明完毕</p><p>3、性质3也是由数学归纳法证明的，假设高度为n的完美二叉树中非终端节点数为k，叶子节点为m，并且m=k+1，只要推导出高度为n+1的完美二叉树也符合这种情况即可。假设该树非终端节点数为k1，叶子节点数为m1，可以计算出k1=k+m，m1=2*m，那么m1-k1=2*m-(k+m)=m-k=1，即m1=k1+1，证明完毕</p><p>4、性质4的证明比较麻烦，假设完美二叉树第n层存在一个节点下标为i，那么第n层剩余节点个数(包括i节点)为(2^n-1)-i,即2^n-i-1，我们记为k，假设i节点<b>左节点</b>下标为j，那么在第n+1层中j节点之前(不包括j节点)节点数为2^(n+1-1)-2*k=2^n-2*k，我们记为m，那么j-i=m+k=2^n-2*k+k=2^n-k=2^n-(2^n-i-1)=i+1，即j-i=i+1，那么j=2i+1，证明完毕</p></div></div> ",
            "assembleText":"完美二叉树 在一棵二叉树中，如果每个非终端节点都有两个子节点，并且所有叶子节点位于同一层次，那么称之为完美二叉树。 就像这样： 图1-3 其中非终端节点包括15/13/23，它们都有两个子节点，并且所有叶子节点都位于第3层。可以看到，完美二叉树左右子树是完美对称的。对于完美二叉树，有以下特性： 1、第i+1层的节点数为2^i 2、如果完美二叉树高度为n，那么总的节点数为2^n - 1 3、如果完美二叉树中叶子节点为m，非终端节点为k，那么m=k+1 4、如果完美二叉树中某节点下标为n，那么它的左节点下标为2n+1，右节点下标为2n+2 证明： 1、性质1可以用数学归纳法来证明，假设完美二叉树中第i层节点数为2^(i-1)，我们只要推导出第i+1层节点数为2^i即可。从定义出发，已知第i层的节点都有两个左右子节点，那么第i+1层的节点数为(2^(i-1))*2，也就是2^i，证明完毕 2、性质2由性质1衍生出来，对于高度为n的完美二叉树，节点总数为2^0+2^1+......+2^(n-1)，也就是2^n - 1，证明完毕 3、性质3也是由数学归纳法证明的，假设高度为n的完美二叉树中非终端节点数为k，叶子节点为m，并且m=k+1，只要推导出高度为n+1的完美二叉树也符合这种情况即可。假设该树非终端节点数为k1，叶子节点数为m1，可以计算出k1=k+m，m1=2*m，那么m1-k1=2*m-(k+m)=m-k=1，即m1=k1+1，证明完毕 4、性质4的证明比较麻烦，假设完美二叉树第n层存在一个节点下标为i，那么第n层剩余节点个数(包括i节点)为(2^n-1)-i,即2^n-i-1，我们记为k，假设i节点左节点下标为j，那么在第n+1层中j节点之前(不包括j节点)节点数为2^(n+1-1)-2*k=2^n-2*k，我们记为m，那么j-i=m+k=2^n-2*k+k=2^n-k=2^n-(2^n-i-1)=i+1，即j-i=i+1，那么j=2i+1，证明完毕",
            "assembleScratchTime":"2019-03-16 20:59:14",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2861999,
            "assembleContent":"<div><br><div><ul><li>完全二叉树</li></ul><p>对于高度为K的，有n个结点的二叉树，当且仅当其每一个结点都与高度为K的完美二叉树中编号从0至n-1的结点一一对应时称之为完全二叉树.</p><ul><li>完满二叉树</li></ul><p>在一棵二叉树中，只存在度为0或者2的节点，称该树为完满二叉树</p><p>我们知道，在二叉树中只存在度为0或1或2的节点，记为n0,n1,n2，那么二叉树中节点总数n可以记为n=n0+n1+n2。在所有二叉树中存在一个重要的性质：n0=n2+1。该性质可以用数学归纳法证明，假设在一棵二叉树p中，度为2的节点个数为n2，那么n0=n2+1，我们只要证明在度为2的节点个数为n2+1的二叉树q中，该性质不变即可。想象在二叉树p中，我们为某个叶子节点添加左右节点，那么该二叉树变为q，并且度为2的节点个数增加了1，而叶子节点也增加了1，n0依然比n2大1。想象在二叉树p中，为某个度为1的节点添加一个子节点，那么该二叉树变为q，并且度为2的节点个数增加了1，而叶子节点也增加了1，n0依然比n2大1。证明完毕</p><p>到目前为止，我们已经了解完美二叉树、完全二叉树、完满二叉树，对于完美二叉树有4个性质，而完全二叉树、完满二叉树有1个。也许有同学会觉得二叉树还有其他性质，事实上，其他性质完全可以用以上性质直接或间接推导出来，性质记得越少越不容易忘记。</p><p>二叉树不是停留在学术上的数据结构，我们是要在程序中实现二叉树，并且运用它的性质来满足软件开发需求。第一步，我们首先要遍历二叉树，能够遍历才能对节点进行操作。遍历二叉树的方法在下一篇进行探讨。</p><p><a href="https://zhuanlan.zhihu.com/p/53552816">数据结构与算法-二叉树遍历</a></p></div></div> ",
            "assembleText":"完全二叉树 对于高度为K的，有n个结点的二叉树，当且仅当其每一个结点都与高度为K的完美二叉树中编号从0至n-1的结点一一对应时称之为完全二叉树. 完满二叉树 在一棵二叉树中，只存在度为0或者2的节点，称该树为完满二叉树 我们知道，在二叉树中只存在度为0或1或2的节点，记为n0,n1,n2，那么二叉树中节点总数n可以记为n=n0+n1+n2。在所有二叉树中存在一个重要的性质：n0=n2+1。该性质可以用数学归纳法证明，假设在一棵二叉树p中，度为2的节点个数为n2，那么n0=n2+1，我们只要证明在度为2的节点个数为n2+1的二叉树q中，该性质不变即可。想象在二叉树p中，我们为某个叶子节点添加左右节点，那么该二叉树变为q，并且度为2的节点个数增加了1，而叶子节点也增加了1，n0依然比n2大1。想象在二叉树p中，为某个度为1的节点添加一个子节点，那么该二叉树变为q，并且度为2的节点个数增加了1，而叶子节点也增加了1，n0依然比n2大1。证明完毕 到目前为止，我们已经了解完美二叉树、完全二叉树、完满二叉树，对于完美二叉树有4个性质，而完全二叉树、完满二叉树有1个。也许有同学会觉得二叉树还有其他性质，事实上，其他性质完全可以用以上性质直接或间接推导出来，性质记得越少越不容易忘记。 二叉树不是停留在学术上的数据结构，我们是要在程序中实现二叉树，并且运用它的性质来满足软件开发需求。第一步，我们首先要遍历二叉树，能够遍历才能对节点进行操作。遍历二叉树的方法在下一篇进行探讨。 数据结构与算法-二叉树遍历",
            "assembleScratchTime":"2019-03-16 20:59:42",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2862000,
            "assembleContent":"<h1>如何按DRY原则实现二叉树？</h1><div><div><p>我们这些全都表示成一个元素序列，用二叉树每个节点维护一个 monoid，叫做这段元素的<br>度量(measure)，要可以合并的那种。然后我们支持两个操作：<br>1. 把两段拼起来<br>2. 按照度量二分把序列劈成两半<br>这样就能实现常见的二叉树功能了。<br>可以参见 finger tree。</p><p>（补充：<br>常数时空间的 iterator 可以<br>1.理论上，immutable 用前位置两边的序列分开，存成 finger tree，支持往两边的常数复杂度挪动。<br>2. mutable 的话我说的那些和 parent sibling 指针不矛盾……不过好像确实不能用 monoid 实现 parent/sibling）</p></div></div> ",
            "assembleText":"如何按DRY原则实现二叉树？ 我们这些全都表示成一个元素序列，用二叉树每个节点维护一个 monoid，叫做这段元素的 度量(measure)，要可以合并的那种。然后我们支持两个操作： 1. 把两段拼起来 2. 按照度量二分把序列劈成两半 这样就能实现常见的二叉树功能了。 可以参见 finger tree。 （补充： 常数时空间的 iterator 可以 1.理论上，immutable 用前位置两边的序列分开，存成 finger tree，支持往两边的常数复杂度挪动。 2. mutable 的话我说的那些和 parent sibling 指针不矛盾……不过好像确实不能用 monoid 实现 parent/sibling）",
            "assembleScratchTime":"2019-03-16 21:01:26",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2862001,
            "assembleContent":"<h1>如何按DRY原则实现二叉树？</h1><div><p>balanced-Ternary 光通信 &四色定理  <br></p></div> ",
            "assembleText":"如何按DRY原则实现二叉树？ balanced-Ternary 光通信 &四色定理  ",
            "assembleScratchTime":"2019-03-16 21:01:54",
            "facetId":558523,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2865329,
            "assembleContent":"<p>In <a href="https://en.wikipedia.org/wiki/Combinatorics" title="Combinatorics">combinatorics</a> one considers the problem of counting the number of full binary trees of a given size. Here the trees have no values attached to their nodes (this would just multiply the number of possible trees by an easily determined factor), and trees are distinguished only by their structure; however the left and right child of any node are distinguished (if they are different trees, then interchanging them will produce a tree distinct from the original one). The size of the tree is taken to be the number <i>n</i> of internal nodes (those with two children); the other nodes are leaf nodes and there are <i>n</i> + 1 of them. The number of such binary trees of size <i>n</i> is equal to the number of ways of fully parenthesizing a string of <i>n</i> + 1 symbols (representing leaves) separated by <i>n</i> binary operators (representing internal nodes), so as to determine the argument subexpressions of each operator. For instance for <i>n</i> = 3 one has to parenthesize a string like <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle X*X*X*X}"><semantics><annotation encoding="application/x-tex">{\displaystyle X*X*X*X}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/566156aef575e6ff5ca67b2611ab3fcd127a0c0e" aria-hidden="true" alt="X*X*X*X">, which is possible in five ways:</p><dl><dd><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle ((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).}"><semantics><annotation encoding="application/x-tex">{\displaystyle ((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d1b88609c3c6537a0d6a7fabfecfd42aad4ab145" aria-hidden="true" alt="((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X))."></dd></dl><p>The correspondence to binary trees should be obvious, and the addition of redundant parentheses (around an already parenthesized expression or around the full expression) is disallowed (or at least not counted as producing a new possibility).</p><p>There is a unique binary tree of size 0 (consisting of a single leaf), and any other binary tree is characterized by the pair of its left and right children; if these have sizes <i>i</i> and <i>j</i> respectively, the full tree has size <i>i</i> + <i>j</i> + 1. Therefore, the number <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle C_{n}}"><semantics><annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" aria-hidden="true" alt="C_{n}"> of binary trees of size <i>n</i> has the following recursive description <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle C_{0}=1}"><semantics><annotation encoding="application/x-tex">{\displaystyle C_{0}=1}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f16d74f9b1af01a229f5b576167e4f1d7969c83" aria-hidden="true" alt="C_{0}=1">, and <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle \textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}}"><semantics><annotation encoding="application/x-tex">{\displaystyle \textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/08ba36c0b93072eb89e77290c4f4188741f8f60b" aria-hidden="true" alt="\textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}"> for any positive integer <i>n</i>. It follows that <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle C_{n}}"><semantics><annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" aria-hidden="true" alt="C_{n}"> is the <a href="https://en.wikipedia.org/wiki/Catalan_number" title="Catalan number">Catalan number</a> of index <i>n</i>.</p><p>The above parenthesized strings should not be confused with the set of words of length 2<i>n</i> in the <a href="https://en.wikipedia.org/wiki/Dyck_language" title="Dyck language">Dyck language</a>, which consist only of parentheses in such a way that they are properly balanced. The number of such strings satisfies the same recursive description (each Dyck word of length 2<i>n</i> is determined by the Dyck subword enclosed by the initial '(' and its matching ')' together with the Dyck subword remaining after that closing parenthesis, whose lengths 2<i>i</i> and 2<i>j</i> satisfy <i>i</i> + <i>j</i> + 1 = <i>n</i>); this number is therefore also the Catalan number <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle C_{n}}"><semantics><annotation encoding="application/x-tex">{\displaystyle C_{n}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0301812adb392070d834ca2df4ed97f1cf132f33" aria-hidden="true" alt="C_{n}">. So there are also five Dyck words of length 6:</p><dl><dd><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle ()()(),\qquad ()(()),\qquad (())(),\qquad (()()),\qquad ((()))}"><semantics><annotation encoding="application/x-tex">{\displaystyle ()()(),\qquad ()(()),\qquad (())(),\qquad (()()),\qquad ((()))}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ebb247fce181cde69defd9c45839194f5546072b" aria-hidden="true" alt="()()(),\qquad ()(()),\qquad (())(),\qquad (()()),\qquad ((()))">.</dd></dl><p>These Dyck words do not correspond to binary trees in the same way. Instead, they are related by the following recursively defined bijection: the Dyck word equal to the empty string corresponds to the binary tree of size 0 with only one leaf. Any other Dyck word can be written as (<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" aria-hidden="true" alt="w_{1}">)<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{2}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" aria-hidden="true" alt="w_{2}">, where <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" aria-hidden="true" alt="w_{1}">,<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{2}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" aria-hidden="true" alt="w_{2}"> are themselves (possibly empty) Dyck words and where the two written parentheses are matched. The bijection is then defined by letting the words <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2f6728d2b30f42f88b52281be5ae0584fdc9df64" aria-hidden="true" alt="w_{1}"> and <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle w_{2}}"><semantics><annotation encoding="application/x-tex">{\displaystyle w_{2}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8998e0957bb573a19e7d9d934ced62ee68ab8fb8" aria-hidden="true" alt="w_{2}"> correspond to the binary trees that are the left and right children of the root.</p><p>A bijective correspondence can also be defined as follows: enclose the Dyck word in an extra pair of parentheses, so that the result can be interpreted as a <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a> list expression (with the empty list () as only occurring atom); then the <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)#S-expressions_represent_lists" title="Lisp (programming language)">dotted-pair</a> expression for that proper list is a fully parenthesized expression (with NIL as symbol and '.' as operator) describing the corresponding binary tree (which is in fact the internal representation of the proper list).</p><p>The ability to represent binary trees as strings of symbols and parentheses implies that binary trees can represent the elements of a <a href="https://en.wikipedia.org/wiki/Free_magma" title="Free magma">free magma</a> on a singleton set.</p> ",
            "assembleText":"In combinatorics one considers the problem of counting the number of full binary trees of a given size. Here the trees have no values attached to their nodes (this would just multiply the number of possible trees by an easily determined factor), and trees are distinguished only by their structure; however the left and right child of any node are distinguished (if they are different trees, then interchanging them will produce a tree distinct from the original one). The size of the tree is taken to be the number n of internal nodes (those with two children); the other nodes are leaf nodes and there are n + 1 of them. The number of such binary trees of size n is equal to the number of ways of fully parenthesizing a string of n + 1 symbols (representing leaves) separated by n binary operators (representing internal nodes), so as to determine the argument subexpressions of each operator. For instance for n = 3 one has to parenthesize a string like  {\displaystyle X*X*X*X}, which is possible in five ways: {\displaystyle ((X*X)*X)*X,\qquad (X*(X*X))*X,\qquad (X*X)*(X*X),\qquad X*((X*X)*X),\qquad X*(X*(X*X)).} The correspondence to binary trees should be obvious, and the addition of redundant parentheses (around an already parenthesized expression or around the full expression) is disallowed (or at least not counted as producing a new possibility). There is a unique binary tree of size 0 (consisting of a single leaf), and any other binary tree is characterized by the pair of its left and right children; if these have sizes i and j respectively, the full tree has size i + j + 1. Therefore, the number  {\displaystyle C_{n}} of binary trees of size n has the following recursive description  {\displaystyle C_{0}=1}, and  {\displaystyle \textstyle C_{n}=\sum _{i=0}^{n-1}C_{i}C_{n-1-i}} for any positive integer n. It follows that  {\displaystyle C_{n}} is the Catalan number of index n. The above parenthesized strings should not be confused with the set of words of length 2n in the Dyck language, which consist only of parentheses in such a way that they are properly balanced. The number of such strings satisfies the same recursive description (each Dyck word of length 2n is determined by the Dyck subword enclosed by the initial '(' and its matching ')' together with the Dyck subword remaining after that closing parenthesis, whose lengths 2i and 2j satisfy i + j + 1 = n); this number is therefore also the Catalan number  {\displaystyle C_{n}}. So there are also five Dyck words of length 6: {\displaystyle ()()(),\qquad ()(()),\qquad (())(),\qquad (()()),\qquad ((()))}. These Dyck words do not correspond to binary trees in the same way. Instead, they are related by the following recursively defined bijection: the Dyck word equal to the empty string corresponds to the binary tree of size 0 with only one leaf. Any other Dyck word can be written as ( {\displaystyle w_{1}}) {\displaystyle w_{2}}, where  {\displaystyle w_{1}}, {\displaystyle w_{2}} are themselves (possibly empty) Dyck words and where the two written parentheses are matched. The bijection is then defined by letting the words  {\displaystyle w_{1}} and  {\displaystyle w_{2}} correspond to the binary trees that are the left and right children of the root. A bijective correspondence can also be defined as follows: enclose the Dyck word in an extra pair of parentheses, so that the result can be interpreted as a Lisp list expression (with the empty list () as only occurring atom); then the dotted-pair expression for that proper list is a fully parenthesized expression (with NIL as symbol and '.' as operator) describing the corresponding binary tree (which is in fact the internal representation of the proper list). The ability to represent binary trees as strings of symbols and parentheses implies that binary trees can represent the elements of a free magma on a singleton set.",
            "assembleScratchTime":"2019-03-24 21:32:48",
            "facetId":558523,
            "sourceId":6,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Binary_tree",
            "type":"text"
        },
        {
            "assembleId":2861915,
            "assembleContent":"<p>一个存储在数组中的<a href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91" title="完全二叉树" style="background-color: rgb(255, 255, 255);">完全二叉树</a><br></p><div><div><a href="https://zh.wikipedia.org/wiki/File:Binary_tree_in_array.svg" title="放大"></a></div></div><p>二叉树可以用<a href="https://zh.wikipedia.org/wiki/%E9%99%A3%E5%88%97" title="数组">数组</a>或<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8" title="链表">链接串列</a>来存储，若是<a href="https://zh.wikipedia.org/w/index.php?title=%E6%BB%BF%E4%BA%8C%E5%85%83%E6%A8%B9&action=edit&redlink=1" title="满二叉树（页面不存在）">满二叉树</a>就能紧凑排列而不浪费空间。如果某个节点的索引为<var>i</var>，（假设根节点的索引为0）则在它左子节点的索引会是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f077f73c2ecdf3c6e29a120f948a7255c0a65da1" aria-hidden="true" alt="{\displaystyle 2i+1}">，以及右子节点会是<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a756deaef520ee23fe2b1232c90957f55ec9d92b" aria-hidden="true" alt="{\displaystyle 2i+2}">；而它的父节点（如果有）索引则为<i><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }"><semantics><annotation encoding="application/x-tex">{</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/35dc2d601bbd9aff8f1ed1c4b2323122f2403317" aria-hidden="true" alt="{\displaystyle \left\lfloor {\frac {i-1}{2}}\right\rfloor }"></i>。这种方法更有利于紧凑存储和更好的<a href="https://zh.wikipedia.org/w/index.php?title=%E8%A8%AA%E5%95%8F%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7&action=edit&redlink=1" title="访问的局部性（页面不存在）">访问的局部性</a>，特别是在<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86" title="树的遍历">前序遍历</a>中。然而，它需要连续的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%98%E5%84%B2%E7%A9%BA%E9%96%93&action=edit&redlink=1" title="存储空间（页面不存在）">存储空间</a>，这样在存储高度为<i>h</i>的<i>n</i>个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62" aria-hidden="true" alt="2^h-1">的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。</p> ",
            "assembleText":"一个存储在数组中的完全二叉树 二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。如果某个节点的索引为i，（假设根节点的索引为0）则在它左子节点的索引会是，以及右子节点会是；而它的父节点（如果有）索引则为 {。这种方法更有利于紧凑存储和更好的访问的局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为h的n个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为h的二叉树其每个节点都只有右孩子，则该存储结构需要占用的空间，实际上却有h个节点，浪费了不少空间，是顺序存储结构的一大缺点。",
            "assembleScratchTime":"2019-03-15 20:57:36",
            "facetId":558950,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2862004,
            "assembleContent":"<p>二叉排序树是一种比较有用的折衷方案。  </p><p>  数组的搜索比较方便，可以直接用下标，但删除或者插入某些元素就比较麻烦。  <br>  链表与之相反，删除和插入元素很快，但查找很慢。  <br>  二叉排序树就既有链表的好处，也有数组的好处。  <br>  在处理大批量的动态的数据是比较有用。</p><p> </p><div>文件系统和数据库系统一般都采用树（特别是B树）的数据结构数据，主要为排序和检索的效率。二叉树是一种最基本最典型的排序树，用于教学和研究树的特性，本身很少在实际中进行应用，因为缺点太明显了（看看教科书怎么说的）。就像冒泡排序一样，虽然因为效率问题并不实用，单不失一种教学例子的好手段。</div> ",
            "assembleText":"二叉排序树是一种比较有用的折衷方案。     数组的搜索比较方便，可以直接用下标，但删除或者插入某些元素就比较麻烦。     链表与之相反，删除和插入元素很快，但查找很慢。     二叉排序树就既有链表的好处，也有数组的好处。     在处理大批量的动态的数据是比较有用。   文件系统和数据库系统一般都采用树（特别是B树）的数据结构数据，主要为排序和检索的效率。二叉树是一种最基本最典型的排序树，用于教学和研究树的特性，本身很少在实际中进行应用，因为缺点太明显了（看看教科书怎么说的）。就像冒泡排序一样，虽然因为效率问题并不实用，单不失一种教学例子的好手段。",
            "assembleScratchTime":"2019-03-16 21:05:56",
            "facetId":558951,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2850597,
            "assembleContent":"<pre>/* [[二元樹]]的順序存儲的基本操作(23個)*/
 #define ClearBiTree InitBiTree /* 在順序存儲結構中，兩函數完全一樣 */\arccos{}
 #define DestroyBiTree InitBiTree /* 在順序存儲結構中，兩函數完全一樣 */
 void InitBiTree(SqBiTree T) －－－（SqBiTree & T）
 { /* 構造[[空二元樹]]T。因為T是陣列名稱，故不需要& */
   int i;
   for(i=0;i<MAX_TREE_SIZE;i++)
     T[i]=Nil; /* 初值為空(Nil在主程中定義) */
 }</pre> ",
            "assembleText":"/* [[二元樹]]的順序存儲的基本操作(23個)*/
 #define ClearBiTree InitBiTree /* 在順序存儲結構中，兩函數完全一樣 */\arccos{}
 #define DestroyBiTree InitBiTree /* 在順序存儲結構中，兩函數完全一樣 */
 void InitBiTree(SqBiTree T) －－－（SqBiTree & T）
 { /* 構造[[空二元樹]]T。因為T是陣列名稱，故不需要& */
   int i;
   for(i=0;i<MAX_TREE_SIZE;i++)
     T[i]=Nil; /* 初值為空(Nil在主程中定義) */
 }",
            "assembleScratchTime":"2019-02-22 23:28:53",
            "facetId":558952,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850598,
            "assembleContent":"<pre>void CreateBiTree(SqBiTree T)
 { /* 按層序次序輸入二叉樹中結點的值(字元型或整型), 構造順序存儲的二叉樹T */
   int i=0;
 #if CHAR /* 結點類型為字元 */
   int l;
   char s[MAX_TREE_SIZE];
   InitBiTree(T); /* 構造[空二元樹]T */
   printf("請按層序輸入結點的值(字元)，空格表示空結點，節點數≦%d:\n",MAX_TREE_SIZE);
   gets(s); /* 輸入字串 */
   l=strlen(s); /* 求字串的長度 */
   for(;i<l;i++) /* 將字串賦值給T */
     T[i]=s[i];
 #else  /* 節點類型為整型 */
   InitBiTree(T); /* 構造[空二元樹]T */
   printf("請按層序輸入節點的值(整型)，0表示空節點，輸999結束。節點數≦%d:\n",MAX_TREE_SIZE);
   while(1)
   {
     scanf("%d",&T[i]);
     if(T[i]==999)
     {
       T[i]=Nil;
       break;
     }
     i++;
   }
 #endif
   for(i=1;i<MAX_TREE_SIZE;i++)
     if(T[(i+1)/2-1]==Nil&&T[i]!=Nil) /* 此非根節點(不空)無雙親 */
     {
       printf("出現無雙親的非根節點"form"\n",T[i]);
       exit(ERROR);
     }
 }</pre> ",
            "assembleText":"void CreateBiTree(SqBiTree T)
 { /* 按層序次序輸入二叉樹中結點的值(字元型或整型), 構造順序存儲的二叉樹T */
   int i=0;
 #if CHAR /* 結點類型為字元 */
   int l;
   char s[MAX_TREE_SIZE];
   InitBiTree(T); /* 構造[空二元樹]T */
   printf("請按層序輸入結點的值(字元)，空格表示空結點，節點數≦%d:\n",MAX_TREE_SIZE);
   gets(s); /* 輸入字串 */
   l=strlen(s); /* 求字串的長度 */
   for(;i<l;i++) /* 將字串賦值給T */
     T[i]=s[i];
 #else  /* 節點類型為整型 */
   InitBiTree(T); /* 構造[空二元樹]T */
   printf("請按層序輸入節點的值(整型)，0表示空節點，輸999結束。節點數≦%d:\n",MAX_TREE_SIZE);
   while(1)
   {
     scanf("%d",&T[i]);
     if(T[i]==999)
     {
       T[i]=Nil;
       break;
     }
     i++;
   }
 #endif
   for(i=1;i<MAX_TREE_SIZE;i++)
     if(T[(i+1)/2-1]==Nil&&T[i]!=Nil) /* 此非根節點(不空)無雙親 */
     {
       printf("出現無雙親的非根節點"form"\n",T[i]);
       exit(ERROR);
     }
 }",
            "assembleScratchTime":"2019-02-22 23:29:10",
            "facetId":558952,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861717,
            "assembleContent":"<h2><p><b>动手写二叉树</b></p><p>首先明确我们要实现的对象是一个结点集合，每个结点有三个属性：值(value), 左孩子(left_child)和右孩子(right_child)。</p><p>写出来会是这个样子：</p><div><pre><code>class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None
</code></pre></div><p>我们写了一个BinaryTree类，在初始化实际对象的时候传入对应值，并在此时还没有子结点的情况下将左右孩子设为空。</p><p>为什么要这么做呢？</p><p>因为当我们创建节点的时候，它还没有孩子，我们只有节点数据。</p><p><br></p><p>让我们测试一下：</p><div><pre><code>tree = BinaryTree('a')
print(tree.value) # a
print(tree.left_child) # None
print(tree.right_child) # None
</code></pre></div><p>下面到了插入结点的操作：在树还没有对应子结点时新建结点，并赋值给现有结点对应变量。否则，新建结点连接并替换掉现有位置子结点。</p><p>画出来是这个样子：</p><figure><img src="https://pic2.zhimg.com/80/v2-6c1c307bce3c455606933d1bff96a319_hd.jpg" normal"="" width="1600"></figure><p>相应代码（左右相同）：</p><div><pre><code>def insert_left(self, value):
    if self.left_child == None:
        self.left_child = BinaryTree(value)
    else:
        new_node = BinaryTree(value)
        new_node.left_child = self.left_child
        self.left_child = new_node
</code></pre></div><p>为了进一步测试，让我们构建一个更复杂一些的树：</p><figure><img src="https://pic4.zhimg.com/80/v2-4115e982b342bef0ad5c1cd83444440f_hd.jpg" normal"="" width="1600"></figure><p>这棵树共有六个结点，其中结点b没有左孩子。对应初始化并插入结点的代码如下：</p><div><pre><code>a_node = BinaryTree('a')
a_node.insert_left('b')
a_node.insert_right('c')

b_node = a_node.left_child
b_node.insert_right('d')

c_node = a_node.right_child
c_node.insert_left('e')
c_node.insert_right('f')

d_node = b_node.right_child
e_node = c_node.left_child
f_node = c_node.right_child

print(a_node.value) # a
print(b_node.value) # b
print(c_node.value) # c
print(d_node.value) # d
print(e_node.value) # e
</code></pre></div><p><br></p></h2> ",
            "assembleText":"动手写二叉树 首先明确我们要实现的对象是一个结点集合，每个结点有三个属性：值(value), 左孩子(left_child)和右孩子(right_child)。 写出来会是这个样子： class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None
 我们写了一个BinaryTree类，在初始化实际对象的时候传入对应值，并在此时还没有子结点的情况下将左右孩子设为空。 为什么要这么做呢？ 因为当我们创建节点的时候，它还没有孩子，我们只有节点数据。 让我们测试一下： tree = BinaryTree('a')
print(tree.value) # a
print(tree.left_child) # None
print(tree.right_child) # None
 下面到了插入结点的操作：在树还没有对应子结点时新建结点，并赋值给现有结点对应变量。否则，新建结点连接并替换掉现有位置子结点。 画出来是这个样子： 相应代码（左右相同）： def insert_left(self, value):
    if self.left_child == None:
        self.left_child = BinaryTree(value)
    else:
        new_node = BinaryTree(value)
        new_node.left_child = self.left_child
        self.left_child = new_node
 为了进一步测试，让我们构建一个更复杂一些的树： 这棵树共有六个结点，其中结点b没有左孩子。对应初始化并插入结点的代码如下： a_node = BinaryTree('a')
a_node.insert_left('b')
a_node.insert_right('c')

b_node = a_node.left_child
b_node.insert_right('d')

c_node = a_node.right_child
c_node.insert_left('e')
c_node.insert_right('f')

d_node = b_node.right_child
e_node = c_node.left_child
f_node = c_node.right_child

print(a_node.value) # a
print(b_node.value) # b
print(c_node.value) # c
print(d_node.value) # d
print(e_node.value) # e",
            "assembleScratchTime":"2019-03-15 19:21:33",
            "facetId":558952,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/30918614",
            "type":"text"
        },
        {
            "assembleId":2861763,
            "assembleContent":"<blockquote>二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。<br></blockquote><p>先上代码，二叉树的结点定义：</p><div><pre><code>class Node {
    public Object data;
    public Node left;
    public Node right;
}
</code></pre></div><p>可以看到，我们除了定义了一个结点的左孩子和右孩子，还定义一个data变量用于存储数据。我们写一段代码，来实际地创建一棵二叉树：<br></p><div><pre><code>public class Main {
    public static void main(String args[]) {
        Node a = new Node(Integer.valueOf(1));
        Node b = new Node(Integer.valueOf(2));
        Node c = new Node(Integer.valueOf(3));
        a.left = b;
        a.right = c;
    }
}

class Node {
    public Object data;
    public Node left;
    public Node right;

    public Node(Object d) {
        this.data = d;
    }
}
</code></pre></div><p>我们通过这种方式，手动地创建了一个二叉树，这个二叉树，如果使用图画出来，就是以下的样子：</p><figure><img src="https://pic3.zhimg.com/80/v2-cc67304ec39051926b76c42e069ac3e6_hd.png" width="986" style="max-width:30%;"></figure><p>我们称 1 是父节点，2 是左孩子结点，3 是右孩子结点。如果一个节点没有子结点，例如图中的 2 和 3 ，那这个节点也是叶子节点。如果一个结点有子结点，也可以称其为内部结点，或者是非叶子结点。</p> ",
            "assembleText":"二叉树是一种树型结构，它的特点是每个结点至多只有两棵子树，并且，二叉树的子树有左右之分，其次序不能任意颠倒。 先上代码，二叉树的结点定义： class Node {
    public Object data;
    public Node left;
    public Node right;
}
 可以看到，我们除了定义了一个结点的左孩子和右孩子，还定义一个data变量用于存储数据。我们写一段代码，来实际地创建一棵二叉树： public class Main {
    public static void main(String args[]) {
        Node a = new Node(Integer.valueOf(1));
        Node b = new Node(Integer.valueOf(2));
        Node c = new Node(Integer.valueOf(3));
        a.left = b;
        a.right = c;
    }
}

class Node {
    public Object data;
    public Node left;
    public Node right;

    public Node(Object d) {
        this.data = d;
    }
}
 我们通过这种方式，手动地创建了一个二叉树，这个二叉树，如果使用图画出来，就是以下的样子： 我们称 1 是父节点，2 是左孩子结点，3 是右孩子结点。如果一个节点没有子结点，例如图中的 2 和 3 ，那这个节点也是叶子节点。如果一个结点有子结点，也可以称其为内部结点，或者是非叶子结点。",
            "assembleScratchTime":"2019-03-15 19:43:59",
            "facetId":558952,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/24800009",
            "type":"text"
        },
        {
            "assembleId":2862003,
            "assembleContent":"<pre><code>//库函数头文件包含<br>#include <stdio.h><br>#include <stdlib.h><br>#include <malloc.h><br>#include <queue><br> <br>using namespace std;<br> <br>//函数状态码的定义<br>#define TRUE        1<br>#define FALSE       0<br>#define OK          1<br>#define ERROR       0<br>#define OVERFLOW   -2<br> <br>typedef int Status;<br>typedef int TElemType;<br> <br>//--------二叉树二叉链表存储表示---------------<br>typedef struct BiTNode{<br>    TElemType data;                     //数据域<br>    struct BiTNode *lchild;             //左孩子指针域<br>    struct BiTNode *rchild;             //右孩子指针域<br>}BiTNode, *BiTree;<br> <br> <br>//---------基本操作函数的简单实现---------------<br> <br>//构造空的二叉树T<br>Status InitBiTree(BiTree &T){<br>    T = NULL;                       //直接将根结点赋值为NULL即表示为空树<br>    return OK;<br>}<br> <br>//销毁二叉树T<br>Status DestroyBiTree(BiTree &T){<br>    /*如果树为空，则直接返回OK， 否则，先递归释放左子树，再递归释放右子树，最后释放根结点*/<br>    if(!T)<br>        return OK;<br>    else{<br>        DestroyBiTree(T->lchild);<br>        DestroyBiTree(T->rchild);<br>        free(T);<br>        T = NULL;<br>        return OK;<br>    }<br>}<br> <br>//先序构造二叉树T<br>Status CreateBiTree(BiTree &T){<br>    /*若输入为0，则创建一个空树，否则创建根结点，递归创建左子树，递归创建右子树。*/<br>    TElemType e;<br>    scanf("%d", &e);<br>    if(e == 0)<br>        T = NULL;<br>    else{<br>        T = (BiTNode *)malloc(sizeof(BiTNode));<br>        if(!T)<br>            exit(OVERFLOW);<br>        T->data = e;<br>        CreateBiTree(T->lchild);<br>        CreateBiTree(T->rchild);<br>    }<br>    return OK;<br>}<br> <br>//判断树是否为空<br>bool BiTreeEmpty(BiTree T){<br>    if(T == NULL)           //根结点为空时表示树为空，返回true，否则返回false<br>        return true;<br>    return false;<br>}<br> <br>//返回树的深度<br>int BiTreeDepth(BiTree T){<br>    int depth = 0;<br>    int depthl, depthr;<br>    if(!T)<br>        depth = 0;<br>    else{<br>        depthl = BiTreeDepth(T->lchild);<br>        depthr = BiTreeDepth(T->rchild);<br>        if(depthl > depthr)<br>            depth = depthl + 1;<br>        else<br>            depth = depthr + 1;<br>    }<br>    return depth;<br>}<br> <br>//求二叉树叶子结点的个数<br>int LeafCount(BiTree T){<br>    if(!T)<br>        return 0;<br>    else if(!T->lchild && !T->rchild)<br>        return 1;<br>    else<br>        return LeafCount(T->lchild) + LeafCount(T->rchild);<br>}<br> <br>//统计所有结点数<br>int NodeCount(BiTree T){<br>    if(!T)<br>        return 0;<br>    else<br>        return 1 + NodeCount(T->lchild) + NodeCount(T->rchild);<br>}<br> <br>//visit()函数<br>Status Print(TElemType e){<br>    printf(" %d", e);<br>}<br> <br>//中遍历二叉树<br>Status InorderTraversal(BiTree T, Status (*visit)(TElemType)){<br>    /*若树空则误操作，若树不空，则先递归地中序遍历左子树，后访问根结点，再递归地中序遍历右子树*/<br>    if(!T)<br>        return OK;<br>    else{<br>        InorderTraversal(T->lchild, visit);<br>        visit(T->data);<br>        InorderTraversal(T->rchild, visit);<br>    }<br>}<br> <br>//先序遍历二叉树<br>Status PreorderTraversal(BiTree T, Status (*visit)(TElemType)){<br>    /*树空无操作，若树不空，则先访问根结点，后递归地先序遍历左子树，再递归地先序遍历右子树 */<br>    if(!T)<br>        return OK;<br>    else{<br>        visit(T->data);<br>        PreorderTraversal(T->lchild, visit);<br>        PreorderTraversal(T->rchild, visit);<br>    }<br>}<br> <br>//后序遍历二叉树<br>Status PostorderTraversal(BiTree T, Status (*visit)(TElemType)){<br>    /*若树空无操作，若树不空，则先递归地后序遍历左子树，后递归地后序遍历，再访问根结点*/<br>    if(!T)<br>        return OK;<br>    else{<br>        PostorderTraversal(T->lchild, visit);<br>        PostorderTraversal(T->rchild, visit);<br>        visit(T->data);<br>    }<br>}<br> <br>//层序遍历二叉树<br>Status LevelorderTraversal(BiTree T, Status (*visit)(TElemType)){<br>    /*如果树空，则不做任何操作，否则，利用队列，将每个结点的左右孩子入队，由于队列的性质，可按层序遍历二叉树*/<br>    if(!T){<br>        printf(" This binary tree is empty!");<br>        return OK;<br>    }<br>    queue<BiTNode*> TreeQueue;<br> <br>    BiTree p = T;<br>    TreeQueue.push(p);<br> <br>    while(!TreeQueue.empty()){<br>        p = TreeQueue.front();<br>        visit(p->data);<br>        if(p->lchild)<br>            TreeQueue.push(p->lchild);<br>        if(p->rchild)<br>            TreeQueue.push(p->rchild);<br>        TreeQueue.pop();<br>    }<br>    return OK;<br>}<br> <br>//主函数<br>int main(){<br>    BiTree T;<br>    InitBiTree(T);<br>    CreateBiTree(T);<br>    printf("The number of nodes in this binary tree is: %d\n", NodeCount(T));<br>    printf("The inorder traversal sequence of the binary tree is:");<br>    InorderTraversal(T, Print);<br>    printf("\nThe preorder traversal sequence of the binary tree is:");<br>    PreorderTraversal(T, Print);<br>    printf("\nThe postorder traversal sequence of the binary tree is:");<br>    PostorderTraversal(T, Print);<br>    printf("\nThe levelorder traversal sequence of the binary tree is:");<br>    LevelorderTraversal(T, Print);<br>    printf("\nThe number of leaves in this binary tree is: %d", LeafCount(T));<br>    printf("\nThe depth of this binary tree is: %d", BiTreeDepth(T));<br>    printf("\nIs the binary empty? ");<br>    if(BiTreeEmpty(T))<br>        printf("YES\n");<br>    else<br>        printf("NO\n");<br>    DestroyBiTree(T);<br>    return 0;<br>}</code></pre><p><br></p> ",
            "assembleText":"//库函数头文件包含 #include <stdio.h> #include <stdlib.h> #include <malloc.h> #include <queue>  using namespace std;  //函数状态码的定义 #define TRUE        1 #define FALSE       0 #define OK          1 #define ERROR       0 #define OVERFLOW   -2  typedef int Status; typedef int TElemType;  //--------二叉树二叉链表存储表示--------------- typedef struct BiTNode{     TElemType data;                     //数据域     struct BiTNode *lchild;             //左孩子指针域     struct BiTNode *rchild;             //右孩子指针域 }BiTNode, *BiTree;   //---------基本操作函数的简单实现---------------  //构造空的二叉树T Status InitBiTree(BiTree &T){     T = NULL;                       //直接将根结点赋值为NULL即表示为空树     return OK; }  //销毁二叉树T Status DestroyBiTree(BiTree &T){     /*如果树为空，则直接返回OK， 否则，先递归释放左子树，再递归释放右子树，最后释放根结点*/     if(!T)         return OK;     else{         DestroyBiTree(T->lchild);         DestroyBiTree(T->rchild);         free(T);         T = NULL;         return OK;     } }  //先序构造二叉树T Status CreateBiTree(BiTree &T){     /*若输入为0，则创建一个空树，否则创建根结点，递归创建左子树，递归创建右子树。*/     TElemType e;     scanf("%d", &e);     if(e == 0)         T = NULL;     else{         T = (BiTNode *)malloc(sizeof(BiTNode));         if(!T)             exit(OVERFLOW);         T->data = e;         CreateBiTree(T->lchild);         CreateBiTree(T->rchild);     }     return OK; }  //判断树是否为空 bool BiTreeEmpty(BiTree T){     if(T == NULL)           //根结点为空时表示树为空，返回true，否则返回false         return true;     return false; }  //返回树的深度 int BiTreeDepth(BiTree T){     int depth = 0;     int depthl, depthr;     if(!T)         depth = 0;     else{         depthl = BiTreeDepth(T->lchild);         depthr = BiTreeDepth(T->rchild);         if(depthl > depthr)             depth = depthl + 1;         else             depth = depthr + 1;     }     return depth; }  //求二叉树叶子结点的个数 int LeafCount(BiTree T){     if(!T)         return 0;     else if(!T->lchild && !T->rchild)         return 1;     else         return LeafCount(T->lchild) + LeafCount(T->rchild); }  //统计所有结点数 int NodeCount(BiTree T){     if(!T)         return 0;     else         return 1 + NodeCount(T->lchild) + NodeCount(T->rchild); }  //visit()函数 Status Print(TElemType e){     printf(" %d", e); }  //中遍历二叉树 Status InorderTraversal(BiTree T, Status (*visit)(TElemType)){     /*若树空则误操作，若树不空，则先递归地中序遍历左子树，后访问根结点，再递归地中序遍历右子树*/     if(!T)         return OK;     else{         InorderTraversal(T->lchild, visit);         visit(T->data);         InorderTraversal(T->rchild, visit);     } }  //先序遍历二叉树 Status PreorderTraversal(BiTree T, Status (*visit)(TElemType)){     /*树空无操作，若树不空，则先访问根结点，后递归地先序遍历左子树，再递归地先序遍历右子树 */     if(!T)         return OK;     else{         visit(T->data);         PreorderTraversal(T->lchild, visit);         PreorderTraversal(T->rchild, visit);     } }  //后序遍历二叉树 Status PostorderTraversal(BiTree T, Status (*visit)(TElemType)){     /*若树空无操作，若树不空，则先递归地后序遍历左子树，后递归地后序遍历，再访问根结点*/     if(!T)         return OK;     else{         PostorderTraversal(T->lchild, visit);         PostorderTraversal(T->rchild, visit);         visit(T->data);     } }  //层序遍历二叉树 Status LevelorderTraversal(BiTree T, Status (*visit)(TElemType)){     /*如果树空，则不做任何操作，否则，利用队列，将每个结点的左右孩子入队，由于队列的性质，可按层序遍历二叉树*/     if(!T){         printf(" This binary tree is empty!");         return OK;     }     queue<BiTNode*> TreeQueue;      BiTree p = T;     TreeQueue.push(p);      while(!TreeQueue.empty()){         p = TreeQueue.front();         visit(p->data);         if(p->lchild)             TreeQueue.push(p->lchild);         if(p->rchild)             TreeQueue.push(p->rchild);         TreeQueue.pop();     }     return OK; }  //主函数 int main(){     BiTree T;     InitBiTree(T);     CreateBiTree(T);     printf("The number of nodes in this binary tree is: %d\n", NodeCount(T));     printf("The inorder traversal sequence of the binary tree is:");     InorderTraversal(T, Print);     printf("\nThe preorder traversal sequence of the binary tree is:");     PreorderTraversal(T, Print);     printf("\nThe postorder traversal sequence of the binary tree is:");     PostorderTraversal(T, Print);     printf("\nThe levelorder traversal sequence of the binary tree is:");     LevelorderTraversal(T, Print);     printf("\nThe number of leaves in this binary tree is: %d", LeafCount(T));     printf("\nThe depth of this binary tree is: %d", BiTreeDepth(T));     printf("\nIs the binary empty? ");     if(BiTreeEmpty(T))         printf("YES\n");     else         printf("NO\n");     DestroyBiTree(T);     return 0; }",
            "assembleScratchTime":"2019-03-16 21:04:58",
            "facetId":558952,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/35161407/answer/426244204",
            "type":"text"
        },
        {
            "assembleId":2865486,
            "assembleContent":"<p>二叉树的操作通常使用递归方法，如果递归不太明白，建议去对此进行一下学习和练习。二叉树的操作可以分为两类，一类是需要改变二叉树的结构的，比如二叉树的创建、节点删除等等，这类操作，传入的二叉树的节点参数为二叉树指针的地址，这种参入传入，便于更改二叉树结构体的指针（即地址）。这里稍微有一点点绕，可能需要多思考一下。<br><br>如下是二叉数创建的函数，这里我们规定，节点值必须为大于0的数值，如果不是大于0的数，则表示结束继续往下创建子节点的操作。然后我们使用递归的方法以此创建左子树和右子树<br><br>int CreateTree(struct TreeNode** root) {<br> <br> int val;<br> scanf_s("%d", &val);<br> if (val <= 0) {<br> *root = NULL;<br> return 0;<br> }<br> <br> *root = (struct TreeNode*)malloc(sizeof(struct TreeNode));<br> if (!root) {<br> printf("创建失败\n");<br> }<br> <br> if (val > 0) {<br> (*root)->val = val;<br> CreateTree(&((*root)->left));<br> CreateTree(&((*root)->right));<br> }<br> return 0;<br>}<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"二叉树的操作通常使用递归方法，如果递归不太明白，建议去对此进行一下学习和练习。二叉树的操作可以分为两类，一类是需要改变二叉树的结构的，比如二叉树的创建、节点删除等等，这类操作，传入的二叉树的节点参数为二叉树指针的地址，这种参入传入，便于更改二叉树结构体的指针（即地址）。这里稍微有一点点绕，可能需要多思考一下。 如下是二叉数创建的函数，这里我们规定，节点值必须为大于0的数值，如果不是大于0的数，则表示结束继续往下创建子节点的操作。然后我们使用递归的方法以此创建左子树和右子树 int CreateTree(struct TreeNode** root) { int val; scanf_s("%d", &val); if (val <= 0) { *root = NULL; return 0; } *root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); if (!root) { printf("创建失败\n"); } if (val > 0) { (*root)->val = val; CreateTree(&((*root)->left)); CreateTree(&((*root)->right)); } return 0; } --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 21:59:43",
            "facetId":558952,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850616,
            "assembleContent":"<h3><p>我们经常希望访问树中的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。</p></h3><h3><span id=".E5.89.8D.28.E5.85.88.29.E5.BA.8F.E3.80.81.E4.B8.AD.E5.BA.8F.E3.80.81.E5.BE.8C.E5.BA.8F.E9.81.8D.E6.AD.B7"></span><span id="前(先)序、中序、後序遍歷">前(先)序、中序、后序遍历</span></h3><h3><p>遍历二叉树：L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD。还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数。</p><p>如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。任何一棵二叉树的叶结点在先序、中序和后序遍历中的相对次序不发改变。设n,m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是n在m的左方。前序序列和中序序列相同的二叉树为空树或任一结点均无左孩子的非空二叉树；中序序列和后序序列相同的二叉树为空树或任一结点均无右孩子的非空二叉树；前序序列和后序序列相同的二叉树为空树或仅有一个结点的二叉树。</p><p>假设我们有一个包含值的<code>value</code>和指向两个子结点的<code>left</code>和<code>right</code>的树结点结构。我们可以写出这样的过程：</p><pre>visit(node)
    print node.value
    if node.left  != null then visit(node.left)
    if node.right != null then visit(node.right)
</pre><p>这样会用前序打印出树中的值。在前序，每个结点在访问它的子结点之前访问。类似地，如果打印语句在最后，每个结点在访问他的子节点之后访问，树中的值会用后序来打印。在这两种情况中，左子树中的值比右子树中得值先打印。</p><pre>visit(node)
    if node.left  != null then visit(node.left)
    print node.value
    if node.right != null then visit(node.right)
</pre><p>最后，上面的中序遍历，每个结点在访问左子树和右子树之间访问。这在遍历<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%90%9C%E5%B0%8B%E6%A8%B9" title="二叉搜索树">二叉搜索树</a>时很常用，因为它能用递增的顺序来遍历所有的值。</p><p>为什么呢？如果<i>n</i>是二叉搜索树的结点，那么<i>n</i>的左子树的所有结点的值都比n的值要小，而且<i>n</i>的右子树的所有节点的值都比n的值要大。因此，如果我们顺序遍历左子树，然后访问<i>n</i>，然后顺序遍历右子树。我们就已经循序访问了整个树。</p><p>后序遍历伪代码如下：</p><pre>visit(node)
    if node.left  != null then visit(node.left)
    if node.right != null then visit(node.right)
    print node.value
</pre><table><tbody><tr><td><div><div><a href="https://zh.wikipedia.org/wiki/File:BinaryTree.png"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/BinaryTree.png/220px-BinaryTree.png" decoding="async" width="220" height="93" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/c4/BinaryTree.png/330px-BinaryTree.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/c4/BinaryTree.png/440px-BinaryTree.png 2x"></a><div><div><a href="https://zh.wikipedia.org/wiki/File:BinaryTree.png" title="放大"></a></div>BinaryTree</div></div></div></td><td>在这个二叉树中，<ul><li>前序遍历的结果：M，G，D，B，A，C，F，E，J，H，I，K，L，S，P，O，N，Q，R，W，U，T，V，X，Z，Y</li><li>后序遍历的结果：A，C，B，E，F，D，I，H，L，K，J，G，N，O，R，Q，P，T，V，U，Y，Z，X，W，S，M</li><li>中序遍历的结果：A，B，C，D，E，F，G，H，I，J，K，L，M，N，O，P，Q，R，S，T，U，V，W，X，Y，Z</li></ul></td></tr></tbody></table><br></h3> ",
            "assembleText":"我们经常希望访问树中的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。 前(先)序、中序、后序遍历 遍历二叉树：L、D、R分别表示遍历左子树、访问根结点和遍历右子树，则先(根)序遍历二叉树的顺序是DLR，中(根)序遍历二叉树的顺序是LDR，后(根)序遍历二叉树的顺序是LRD。还有按层遍历二叉树。这些方法的时间复杂度都是O(n)，n为结点个数。 如果T2是由有序树T转换而来的二叉树，那么T中结点的前序就是T2中结点的前序，T中结点的后序就是T2中结点的中序。任何一棵二叉树的叶结点在先序、中序和后序遍历中的相对次序不发改变。设n,m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是n在m的左方。前序序列和中序序列相同的二叉树为空树或任一结点均无左孩子的非空二叉树；中序序列和后序序列相同的二叉树为空树或任一结点均无右孩子的非空二叉树；前序序列和后序序列相同的二叉树为空树或仅有一个结点的二叉树。 假设我们有一个包含值的value和指向两个子结点的left和right的树结点结构。我们可以写出这样的过程： visit(node)
    print node.value
    if node.left  != null then visit(node.left)
    if node.right != null then visit(node.right)
 这样会用前序打印出树中的值。在前序，每个结点在访问它的子结点之前访问。类似地，如果打印语句在最后，每个结点在访问他的子节点之后访问，树中的值会用后序来打印。在这两种情况中，左子树中的值比右子树中得值先打印。 visit(node)
    if node.left  != null then visit(node.left)
    print node.value
    if node.right != null then visit(node.right)
 最后，上面的中序遍历，每个结点在访问左子树和右子树之间访问。这在遍历二叉搜索树时很常用，因为它能用递增的顺序来遍历所有的值。 为什么呢？如果n是二叉搜索树的结点，那么n的左子树的所有结点的值都比n的值要小，而且n的右子树的所有节点的值都比n的值要大。因此，如果我们顺序遍历左子树，然后访问n，然后顺序遍历右子树。我们就已经循序访问了整个树。 后序遍历伪代码如下： visit(node)
    if node.left  != null then visit(node.left)
    if node.right != null then visit(node.right)
    print node.value
 BinaryTree 在这个二叉树中， 前序遍历的结果：M，G，D，B，A，C，F，E，J，H，I，K，L，S，P，O，N，Q，R，W，U，T，V，X，Z，Y 后序遍历的结果：A，C，B，E，F，D，I，H，L，K，J，G，N，O，R，Q，P，T，V，U，Y，Z，X，W，S，M 中序遍历的结果：A，B，C，D，E，F，G，H，I，J，K，L，M，N，O，P，Q，R，S，T，U，V，W，X，Y，Z",
            "assembleScratchTime":"2019-02-22 23:35:43",
            "facetId":558953,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861719,
            "assembleContent":"<p><b>DFS</b> 会沿特定路径遍历到叶子结点再回溯 (<b>backtracking)</b> 进入临近路径继续遍历。以下面的树结构为例：</p><figure><img src="https://pic3.zhimg.com/80/v2-0fa1c9c6902c39f05c8b4ca63048e426_hd.jpg" width="1600"><figcaption>遍历顺序为1–2–3–4–5–6–7</figcaption></figure><p>具体来讲，我们会先访问根结点1再访问其左孩子2，接着是2的左孩子3，到达叶子结点回溯一步，访问2的右孩子4，进一步回溯，继续顺序访问5，6和7。</p><p><br></p><p>在输出遍历结果时，据父结点值相对子结点输出顺序的不同，深度优先遍历又可细分为<b>先序、中序和后序</b>遍历三种情况。</p> ",
            "assembleText":"DFS 会沿特定路径遍历到叶子结点再回溯 (backtracking) 进入临近路径继续遍历。以下面的树结构为例： 遍历顺序为1–2–3–4–5–6–7 具体来讲，我们会先访问根结点1再访问其左孩子2，接着是2的左孩子3，到达叶子结点回溯一步，访问2的右孩子4，进一步回溯，继续顺序访问5，6和7。 在输出遍历结果时，据父结点值相对子结点输出顺序的不同，深度优先遍历又可细分为先序、中序和后序遍历三种情况。",
            "assembleScratchTime":"2019-03-15 19:22:27",
            "facetId":558953,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/30918614",
            "type":"text"
        },
        {
            "assembleId":2861725,
            "assembleContent":"<p>使用遍历法进行个数统计会TLE，需要高效的方法</p><p>使用递归的解法</p><p>从根节点root不断向左走，统计向左走到最深处的深度left_depth，同理向右走到最深处的深度为right_depth</p><p>如果left_depth == right_depth，说明以root为根的树是满的完全二叉树，直接返回节点个数pow(2, left_depth) - 1</p><p>否则递归调用return countNodes( root->left ) + countNodes( root->right ) + 1;</p> ",
            "assembleText":"使用遍历法进行个数统计会TLE，需要高效的方法 使用递归的解法 从根节点root不断向左走，统计向左走到最深处的深度left_depth，同理向右走到最深处的深度为right_depth 如果left_depth == right_depth，说明以root为根的树是满的完全二叉树，直接返回节点个数pow(2, left_depth) - 1 否则递归调用return countNodes( root->left ) + countNodes( root->right ) + 1;",
            "assembleScratchTime":"2019-03-15 19:24:50",
            "facetId":558954,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27433679",
            "type":"text"
        },
        {
            "assembleId":2861726,
            "assembleContent":"<h1>为什么给定节点个数的二叉树个数为卡特兰数？</h1><div><div><p>把二叉树写成后缀表达式，刚好是n个相同的元素和n-1个操作符，表达式第一个字符一定是元素，除此以外的每个操作符出现时，当前出现的元素数量一定至少是操作符数量+1，这显然就是卡特兰数的定义——跟走三角形棋盘的意思是一样的。</p><p>第二种方法是穷举左右子树的节点数列出递推式，可以得到卡特兰数的一种递推形式。</p><p>高度就不懂你是什么意思了，这明显不是一个精确值，2个节点的时候高度就是2而不是根号2。</p></div><br><br>作者：灵剑<br>链接：https://www.zhihu.com/question/275456390/answer/384271673<br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div> ",
            "assembleText":"为什么给定节点个数的二叉树个数为卡特兰数？ 把二叉树写成后缀表达式，刚好是n个相同的元素和n-1个操作符，表达式第一个字符一定是元素，除此以外的每个操作符出现时，当前出现的元素数量一定至少是操作符数量+1，这显然就是卡特兰数的定义——跟走三角形棋盘的意思是一样的。 第二种方法是穷举左右子树的节点数列出递推式，可以得到卡特兰数的一种递推形式。 高度就不懂你是什么意思了，这明显不是一个精确值，2个节点的时候高度就是2而不是根号2。 作者：灵剑 链接：https://www.zhihu.com/question/275456390/answer/384271673 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
            "assembleScratchTime":"2019-03-15 19:25:24",
            "facetId":558954,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27433679",
            "type":"text"
        },
        {
            "assembleId":2861729,
            "assembleContent":"<h1>为什么给定节点个数的二叉树个数为卡特兰数？</h1><div><div><div><blockquote>给定不重复的二叉树先序遍历序列，找出不同二叉树的个数</blockquote><ul><li>首先由二叉树的<b>先序序列</b>和<b>中序序列</b>可以唯一确定一棵二叉树。<i>（中序加后序，中序加层次也可以，这里讨论题目的先序）</i></li><li>找出由该序列可以得到的中序序列个数，即我们需要的二叉树个数。</li></ul><blockquote>假设给出的先序序列为 <img src="https://www.zhihu.com/equation?tex=%5Bx_1%2C...%2Cx_n%5D" alt="[x_1,...,x_n]" eeimg="1"> </blockquote><ul><li>因为 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在先序序列的首位，也就是 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 是该二叉树的根结点。</li><li>由根节点在中序遍历中的位置，我们可以将中序序列分割成两个子序列，分别是左右子树的元素。</li><li>当 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在<b>中序序列</b>的第 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 位时<b>中序序列</b>中的<b>[1]</b>到<b>[k-1]</b>的元素都在其左子树，可以形成 <img src="https://www.zhihu.com/equation?tex=h%28k-1%29" alt="h(k-1)" eeimg="1"> 不同的树，<b>[k+1]</b>到<b>[n]</b>的元素在其右子树，可以形成 <img src="https://www.zhihu.com/equation?tex=h%28n-k%29" alt="h(n-k)" eeimg="1"> 个不同的树，则当前位置可以形成 <img src="https://www.zhihu.com/equation?tex=h%28k-1%29%C2%B7h%28n-k%29" alt="h(k-1)·h(n-k)" eeimg="1"> 棵树。</li><li>当 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 的位置不同的情况下是相互独立的，所以结果因该是 <img src="https://www.zhihu.com/equation?tex=x_1" alt="x_1" eeimg="1"> 出现在不同位置的相互累加。 <img src="https://www.zhihu.com/equation?tex=k" alt="k" eeimg="1"> 的取值为<b>1~n</b>，所以结果是 </li></ul><p><img src="https://www.zhihu.com/equation?tex=h%28n%29%3Dh%280%29h%28n-1%29%2Bh%281%29h%28n-2%29%2B...%2Bh%28n-1%29h%280%29%28n%5Cge2%29" alt="h(n)=h(0)h(n-1)+h(1)h(n-2)+...+h(n-1)h(0)(n\ge2)" eeimg="1"> </p><p><br></p><p>这是一个<i><b>Catalan递推式</b></i>，通项公式为</p><p><img src="https://www.zhihu.com/equation?tex=Cn%3DC%282n%2Cn%29-C%282n%2Cn-1%29%3DC%282n%2Cn%29%2F%28n%2B1%29" alt="Cn=C(2n,n)-C(2n,n-1)=C(2n,n)/(n+1)" eeimg="1"> </p><p>通项的推导就比较复杂了，找了很久看到一个比较好理解的<a href="https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_6917f47301010cno.html" target="_blank" rel="nofollow noreferrer">折现法——Catalan通项的推导</a></p><p><br></p><p>主要是一个<b>分治思想</b></p><p>问题规模为n，先固定一个元素，然后将剩下n-1个元素拆分成两个问题，根据固定的元素位置不同，得到更小的可以表示为Catalan数的递推式问题。</p></div><br><br>作者：Jett<br>链接：https://www.zhihu.com/question/275456390/answer/494024465<br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</div></div> ",
            "assembleText":"为什么给定节点个数的二叉树个数为卡特兰数？ 给定不重复的二叉树先序遍历序列，找出不同二叉树的个数 首先由二叉树的先序序列和中序序列可以唯一确定一棵二叉树。（中序加后序，中序加层次也可以，这里讨论题目的先序） 找出由该序列可以得到的中序序列个数，即我们需要的二叉树个数。 假设给出的先序序列为 因为 出现在先序序列的首位，也就是 是该二叉树的根结点。 由根节点在中序遍历中的位置，我们可以将中序序列分割成两个子序列，分别是左右子树的元素。 当 出现在中序序列的第 位时中序序列中的[1]到[k-1]的元素都在其左子树，可以形成 不同的树，[k+1]到[n]的元素在其右子树，可以形成 个不同的树，则当前位置可以形成 棵树。 当 的位置不同的情况下是相互独立的，所以结果因该是 出现在不同位置的相互累加。 的取值为1~n，所以结果是 这是一个Catalan递推式，通项公式为 通项的推导就比较复杂了，找了很久看到一个比较好理解的折现法——Catalan通项的推导 主要是一个分治思想 问题规模为n，先固定一个元素，然后将剩下n-1个元素拆分成两个问题，根据固定的元素位置不同，得到更小的可以表示为Catalan数的递推式问题。 作者：Jett 链接：https://www.zhihu.com/question/275456390/answer/494024465 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
            "assembleScratchTime":"2019-03-15 19:26:37",
            "facetId":558954,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/27433679",
            "type":"text"
        },
        {
            "assembleId":2861992,
            "assembleContent":"<pre><code>int treeSize(nodeptr_t root) {
    if(root == 0) {
        return 0;
    }
    return 1 + treeSize(root->left) + treesize(root->right)
}</code></pre> ",
            "assembleText":"int treeSize(nodeptr_t root) {
    if(root == 0) {
        return 0;
    }
    return 1 + treeSize(root->left) + treesize(root->right)
}",
            "assembleScratchTime":"2019-03-16 20:52:58",
            "facetId":558954,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2865505,
            "assembleContent":"<p>二叉树叶子节点的数量<br><br>这里我们要提到“度”的定义，简单来说，一个节点的度就是一个节点的分支数，二叉树中的节点按照度来分类的话，分为三类，度分别为0、1、2的节点，我们将其数量表示为n0、n1、n2，且我们将一棵树的总结点数量用N来表示。那么一个数的叶子节点的数量即为n0，且有N=n0+n1+n2。如果我们按照一棵树的子节点数来计算一棵树的总结点数，那么一棵二叉树树的总结点数N=2*n2+n1+1，最后一个1表示树的根节点。我们将关于N的两个等式合并，则有结论：<br><br>n0=n2+1<br><br>上述的结论与我们下面求叶子节点没有什么关系，只是作为一个知识的普及。<br><br>叶子节点计算方法如下：<br><br>int LeafNodeNum(struct TreeNode* root) {<br> if (root == NULL) {<br> return 0;<br> }<br> <br> if (root->left == NULL&&root->right == NULL) {<br> return 1;<br> }<br> else {<br> return LeafNodeNum(root->left) + LeafNodeNum(root->right);<br> }<br>}<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>  ",
            "assembleText":"二叉树叶子节点的数量 这里我们要提到“度”的定义，简单来说，一个节点的度就是一个节点的分支数，二叉树中的节点按照度来分类的话，分为三类，度分别为0、1、2的节点，我们将其数量表示为n0、n1、n2，且我们将一棵树的总结点数量用N来表示。那么一个数的叶子节点的数量即为n0，且有N=n0+n1+n2。如果我们按照一棵树的子节点数来计算一棵树的总结点数，那么一棵二叉树树的总结点数N=2*n2+n1+1，最后一个1表示树的根节点。我们将关于N的两个等式合并，则有结论： n0=n2+1 上述的结论与我们下面求叶子节点没有什么关系，只是作为一个知识的普及。 叶子节点计算方法如下： int LeafNodeNum(struct TreeNode* root) { if (root == NULL) { return 0; } if (root->left == NULL&&root->right == NULL) { return 1; } else { return LeafNodeNum(root->left) + LeafNodeNum(root->right); } } --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:02:43",
            "facetId":558954,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850599,
            "assembleContent":"<pre>int BiTreeDepth(SqBiTree T)
 { /* 初始條件：[二元樹]T存在。操作結果：返回T的深度 */
   int i,j=-1;
   for(i=MAX_TREE_SIZE-1;i>=0;i--) /* 找到最後一個節點 */
     if(T[i]!=Nil)
       break;
   i++; /* 為了便於計算 */
   do
     j++;
   while(i>=pow(2,j));   /*pow是原型為double pow( double x, double y ),計算x的y次方,h = log<sub>2</sub>k + 1來計算[二元樹]的深度*/
   return j;
 }</pre> ",
            "assembleText":"int BiTreeDepth(SqBiTree T)
 { /* 初始條件：[二元樹]T存在。操作結果：返回T的深度 */
   int i,j=-1;
   for(i=MAX_TREE_SIZE-1;i>=0;i--) /* 找到最後一個節點 */
     if(T[i]!=Nil)
       break;
   i++; /* 為了便於計算 */
   do
     j++;
   while(i>=pow(2,j));   /*pow是原型為double pow( double x, double y ),計算x的y次方,h = log<sub>2</sub>k + 1來計算[二元樹]的深度*/
   return j;
 }",
            "assembleScratchTime":"2019-02-22 23:29:36",
            "facetId":558955,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861731,
            "assembleContent":"<p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><b>说明:</b> 叶子节点是指没有子节点的节点。</p><p><b>示例：</b> 给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><div><pre><code>3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回它的最大深度 3 。</p><h2>思路</h2><p>为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口就是节点为空。返回值为0。</p><h2>代码</h2><div><pre><code>class Solution {
    public int maxDepth(TreeNode root) {
         int deep = 0;
    if (root != null) {
      int lchildeep = maxDepth(root.left);
      int rchildeep = maxDepth(root.right);
      deep = lchildeep > rchildeep ? lchildeep + 1 : rchildeep + 1;
    }
    return deep;
    }
}</code></pre></div> ",
            "assembleText":"给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3
   / \
  9  20
    /  \
   15   7
 返回它的最大深度 3 。 思路 为了求树的深度，可以先求其左子树的深度和右子树的深度，可以用递归实现，递归的出口就是节点为空。返回值为0。 代码 class Solution {
    public int maxDepth(TreeNode root) {
         int deep = 0;
    if (root != null) {
      int lchildeep = maxDepth(root.left);
      int rchildeep = maxDepth(root.right);
      deep = lchildeep > rchildeep ? lchildeep + 1 : rchildeep + 1;
    }
    return deep;
    }
}",
            "assembleScratchTime":"2019-03-15 19:27:39",
            "facetId":558955,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/47925712",
            "type":"text"
        },
        {
            "assembleId":2861733,
            "assembleContent":"<p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><b>说明:</b> 叶子节点是指没有子节点的节点。</p><p><b>示例:</b></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><div><pre><code>3
   / \
  9  20
    /  \
   15   7
</code></pre></div><p>返回它的最小深度 2.</p><h2>思路</h2><p>这个题目求其最小深度不同于最大深度那样，这个要考虑该二叉树的左右子树是否存在，有四个方面</p><p>1、该二叉树为空，则返回0；</p><p>2、该二叉树不为空，且左右子树均存在，则和求最大深度一样，利用递归的方法求出最小深度</p><p>3、该二叉树只存在左子树，则返回值为1</p><p>4、该二叉树只存在右子树，则返回值为1</p><p>第二种情况时，分别求出左子树的最小值和右子树的最小值，再比较左右子树的最小值也会出现三种情况</p><p>a、left小于right时，取left+1</p><p>b、left大于right时，取right+1</p><p>c、left等于right时，并且left小于最大值，返回left+1</p><h2>代码</h2><div><pre><code>public class Solution {
    public int minDepth(TreeNode root) {
    if(root!=null){
        int left=Integer.MAX_VALUE;
        int right=Integer.MAX_VALUE;
        if(root.left!=null){
            left=minDepth(root.left);
        }
        if(root.right!=null){
            right=minDepth(root.right);
        }
        if(left<right){
            return left+1;
        }
        else if(left>right){
            return right+1;
        }
        else if(left==right&&left!=Integer.MAX_VALUE){
            return left+1;
        }
        else{
            return 1;
        }
        
    }
     return 0;   
    }
}</code></pre></div> ",
            "assembleText":"给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3
   / \
  9  20
    /  \
   15   7
 返回它的最小深度 2. 思路 这个题目求其最小深度不同于最大深度那样，这个要考虑该二叉树的左右子树是否存在，有四个方面 1、该二叉树为空，则返回0； 2、该二叉树不为空，且左右子树均存在，则和求最大深度一样，利用递归的方法求出最小深度 3、该二叉树只存在左子树，则返回值为1 4、该二叉树只存在右子树，则返回值为1 第二种情况时，分别求出左子树的最小值和右子树的最小值，再比较左右子树的最小值也会出现三种情况 a、left小于right时，取left+1 b、left大于right时，取right+1 c、left等于right时，并且left小于最大值，返回left+1 代码 public class Solution {
    public int minDepth(TreeNode root) {
    if(root!=null){
        int left=Integer.MAX_VALUE;
        int right=Integer.MAX_VALUE;
        if(root.left!=null){
            left=minDepth(root.left);
        }
        if(root.right!=null){
            right=minDepth(root.right);
        }
        if(left<right){
            return left+1;
        }
        else if(left>right){
            return right+1;
        }
        else if(left==right&&left!=Integer.MAX_VALUE){
            return left+1;
        }
        else{
            return 1;
        }
        
    }
     return 0;   
    }
}",
            "assembleScratchTime":"2019-03-15 19:28:05",
            "facetId":558955,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/47925712",
            "type":"text"
        },
        {
            "assembleId":2865497,
            "assembleContent":"<p>int maxDepth(struct TreeNode* root) {<br> if (root == NULL) {<br> return 0;<br> }<br> else {<br> int maxLeft = maxDepth(root->left), maxRight = maxDepth(root->right);<br> if (maxLeft > maxRight) {<br> return 1 + maxLeft;<br> }<br> else {<br> return 1 + maxRight;<br> }<br> }<br>}<br>这也是LeetCode 104 Maximum Depth of Binary Tree题的答案，在做这道题的时候，一开始我并没有定义maxLeft和maxRight这两个变量，直接在判断处调用函数，这导致整个程序的运行时间过长。这道题的思想很简单，一棵树的最大深度，左子树和右子树的最大深度+1即可，使用递归，截止条件判断好了，很容易就能够做出来。<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"int maxDepth(struct TreeNode* root) { if (root == NULL) { return 0; } else { int maxLeft = maxDepth(root->left), maxRight = maxDepth(root->right); if (maxLeft > maxRight) { return 1 + maxLeft; } else { return 1 + maxRight; } } } 这也是LeetCode 104 Maximum Depth of Binary Tree题的答案，在做这道题的时候，一开始我并没有定义maxLeft和maxRight这两个变量，直接在判断处调用函数，这导致整个程序的运行时间过长。这道题的思想很简单，一棵树的最大深度，左子树和右子树的最大深度+1即可，使用递归，截止条件判断好了，很容易就能够做出来。 --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:01:11",
            "facetId":558955,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850600,
            "assembleContent":"<pre> Status Root(SqBiTree T,TElemType *e)
 { /* 初始條件：[二元樹]T存在。操作結果：當T不空，用e返回T的根，返回OK；否則返回ERROR，e無定義 */
   if(BiTreeEmpty(T)) /* T空 */
     return ERROR;
   else
   {
     *e=T[0];
     return OK;
   }
 }</pre> ",
            "assembleText":"Status Root(SqBiTree T,TElemType *e)
 { /* 初始條件：[二元樹]T存在。操作結果：當T不空，用e返回T的根，返回OK；否則返回ERROR，e無定義 */
   if(BiTreeEmpty(T)) /* T空 */
     return ERROR;
   else
   {
     *e=T[0];
     return OK;
   }
 }",
            "assembleScratchTime":"2019-02-22 23:30:16",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850601,
            "assembleContent":"<pre>TElemType Value(SqBiTree T,position e)
 { /* 初始條件：[二元樹]T存在，e是T中某個結點(的位置) */
   /* 操作結果：返回處於位置e(層,本層序號)的結點的值 */
   return T[(int)pow(2,e.level-1)+e.order-2];
 }</pre> ",
            "assembleText":"TElemType Value(SqBiTree T,position e)
 { /* 初始條件：[二元樹]T存在，e是T中某個結點(的位置) */
   /* 操作結果：返回處於位置e(層,本層序號)的結點的值 */
   return T[(int)pow(2,e.level-1)+e.order-2];
 }",
            "assembleScratchTime":"2019-02-22 23:30:59",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850602,
            "assembleContent":"<pre>Status Assign(SqBiTree T,position e,TElemType value)
 { /* 初始條件：二叉樹T存在，e是T中某個結點(的位置) */
   /* 操作結果：給處於位置e(層,本層序號)的結點賦新值value */
   int i=(int)pow(2,e.level-1)+e.order-2; /* 將層、本層序號轉為矩陣的序號 */
   if(value!=Nil&&T[(i+1)/2-1]==Nil) /* 給葉子賦非空值但雙親為空 */
     return ERROR;
   else if(value==Nil&&(T[i*2+1]!=Nil||T[i*2+2]!=Nil)) /*  給雙親賦空值但有葉子(不空) */
     return ERROR;
   T[i]=value;
   return OK;
 }</pre> ",
            "assembleText":"Status Assign(SqBiTree T,position e,TElemType value)
 { /* 初始條件：二叉樹T存在，e是T中某個結點(的位置) */
   /* 操作結果：給處於位置e(層,本層序號)的結點賦新值value */
   int i=(int)pow(2,e.level-1)+e.order-2; /* 將層、本層序號轉為矩陣的序號 */
   if(value!=Nil&&T[(i+1)/2-1]==Nil) /* 給葉子賦非空值但雙親為空 */
     return ERROR;
   else if(value==Nil&&(T[i*2+1]!=Nil||T[i*2+2]!=Nil)) /*  給雙親賦空值但有葉子(不空) */
     return ERROR;
   T[i]=value;
   return OK;
 }",
            "assembleScratchTime":"2019-02-22 23:31:14",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850603,
            "assembleContent":"<pre>TElemType Parent(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：若e是T的非根結點，則返回它的雙親，否則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[(i+1)/2-1];
   return Nil; /* 沒找到e */
 }</pre> ",
            "assembleText":"TElemType Parent(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：若e是T的非根結點，則返回它的雙親，否則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[(i+1)/2-1];
   return Nil; /* 沒找到e */
 }",
            "assembleScratchTime":"2019-02-22 23:31:24",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850604,
            "assembleContent":"<pre> TElemType LeftChild(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點。操作結果：返回e的左孩子。若e無左孩子,則返回"空" */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=0;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[i*2+1];
   return Nil; /* 沒找到e */
 }</pre> ",
            "assembleText":"TElemType LeftChild(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點。操作結果：返回e的左孩子。若e無左孩子,則返回"空" */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=0;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[i*2+1];
   return Nil; /* 沒找到e */
 }",
            "assembleScratchTime":"2019-02-22 23:31:35",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850605,
            "assembleContent":"<pre>TElemType RightChild(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點。操作結果：返回e的右孩子。若e無右孩子,則返回"空" */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=0;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[i*2+2];
   return Nil; /* 沒找到e */
 }</pre> ",
            "assembleText":"TElemType RightChild(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點。操作結果：返回e的右孩子。若e無右孩子,則返回"空" */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=0;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e) /* 找到e */
       return T[i*2+2];
   return Nil; /* 沒找到e */
 }",
            "assembleScratchTime":"2019-02-22 23:31:44",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850606,
            "assembleContent":"<div dir="ltr"><pre>TElemType LeftSibling(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：返回e的左兄弟。若e是T的左孩子或無左兄弟，則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&&i%2==0) /* 找到e且其序號為偶數(是右孩子) */
       return T[i-1];
   return Nil; /* 沒找到e */
 }
</pre></div><div dir="ltr"><pre> TElemType RightSibling(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：返回e的右兄弟。若e是T的右孩子或無右兄弟，則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&&i%2) /* 找到e且其序號為奇數(是左孩子) */
       return T[i+1];
   return Nil; /* 沒找到e */
 }</pre></div> ",
            "assembleText":"TElemType LeftSibling(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：返回e的左兄弟。若e是T的左孩子或無左兄弟，則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&&i%2==0) /* 找到e且其序號為偶數(是右孩子) */
       return T[i-1];
   return Nil; /* 沒找到e */
 }
  TElemType RightSibling(SqBiTree T,TElemType e)
 { /* 初始條件：二叉樹T存在，e是T中某個結點 */
   /* 操作結果：返回e的右兄弟。若e是T的右孩子或無右兄弟，則返回＂空＂ */
   int i;
   if(T[0]==Nil) /* 空樹 */
     return Nil;
   for(i=1;i<=MAX_TREE_SIZE-1;i++)
     if(T[i]==e&&i%2) /* 找到e且其序號為奇數(是左孩子) */
       return T[i+1];
   return Nil; /* 沒找到e */
 }",
            "assembleScratchTime":"2019-02-22 23:32:03",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861916,
            "assembleContent":"<h2><span id="將n叉樹轉換為二叉樹">将n叉树转换为二叉树</span></h2><p>一般有序树可映射为二叉树，但反之未必成立。</p><p>n叉树转换为二叉树的方法：二叉树中结点x的左子结点为n叉树中结点x的左子结点；二叉树中结点x的右子结点为n叉树中结点x的第一个右边的同级结点y。</p><p>二叉树当且仅当根节点没有右子结点时可转换为n叉树。</p><p>例如，在左边的树中，A有6个子结点{B,C,D,E,F,G}。它能被转换成右边的二叉树。</p><center><p><a href="https://zh.wikipedia.org/wiki/File:Nary_to_binary_tree_conversion.png" title="将n叉树转换为二叉树的例子"><img alt="将n叉树转换为二叉树的例子" src="https://upload.wikimedia.org/wikipedia/commons/0/02/Nary_to_binary_tree_conversion.png" decoding="async" width="400" height="250"></a></p></center><p><br></p><ul><li>将一棵树转换为二叉树的方法：</li></ul><ol><li>在兄弟之间加一连线；</li><li>对每个结点，除了其左孩子外，去除其与其余孩子之间的联系；</li><li>以树的根结点为轴心，将整树顺时针转45度。</li></ol> ",
            "assembleText":"将n叉树转换为二叉树 一般有序树可映射为二叉树，但反之未必成立。 n叉树转换为二叉树的方法：二叉树中结点x的左子结点为n叉树中结点x的左子结点；二叉树中结点x的右子结点为n叉树中结点x的第一个右边的同级结点y。 二叉树当且仅当根节点没有右子结点时可转换为n叉树。 例如，在左边的树中，A有6个子结点{B,C,D,E,F,G}。它能被转换成右边的二叉树。 将一棵树转换为二叉树的方法： 在兄弟之间加一连线； 对每个结点，除了其左孩子外，去除其与其余孩子之间的联系； 以树的根结点为轴心，将整树顺时针转45度。",
            "assembleScratchTime":"2019-03-15 20:58:34",
            "facetId":559661,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9",
            "type":"text"
        },
        {
            "assembleId":2861993,
            "assembleContent":"<p>如前文所述，二叉树的左右孩子的大小是有限制的。因此我们可以很简便的写出搜索数据的函数。</p><div><pre><code>nodeptr_t treeSearch(nodeptr_t root, int value) {
    if(root == NULL)
        return NULL;
    else if(root->data == value)
        return root;
    else if(root->data > target)
        return treeSearch(root->left);
    else
        return treeSearch(root->right);
}
</code></pre></div><p>为了防止爆栈这种悲剧发生（概率很低），我们还可以写出迭代版本的搜索算法。示例如下：</p><div><pre><code>nodeptr_t treeSearch(nodeptr_t root, int value)
{
    while(root != NULL && root->data != value) {
        if(root->data > value) {
            root = root->left;
        } else {
            root = root->right;
        }
    }

    return root;
}
</code></pre></div><p>为了处理其他类型的数据，我们还可以把比较操作那里使用函数进行替代。比如我们在实现字典的查找时，就可以简单地使用 <code>strcmp</code> 函数进行比较操作。</p> ",
            "assembleText":"如前文所述，二叉树的左右孩子的大小是有限制的。因此我们可以很简便的写出搜索数据的函数。 nodeptr_t treeSearch(nodeptr_t root, int value) {
    if(root == NULL)
        return NULL;
    else if(root->data == value)
        return root;
    else if(root->data > target)
        return treeSearch(root->left);
    else
        return treeSearch(root->right);
}
 为了防止爆栈这种悲剧发生（概率很低），我们还可以写出迭代版本的搜索算法。示例如下： nodeptr_t treeSearch(nodeptr_t root, int value)
{
    while(root != NULL && root->data != value) {
        if(root->data > value) {
            root = root->left;
        } else {
            root = root->right;
        }
    }

    return root;
}
 为了处理其他类型的数据，我们还可以把比较操作那里使用函数进行替代。比如我们在实现字典的查找时，就可以简单地使用 strcmp 函数进行比较操作。",
            "assembleScratchTime":"2019-03-16 20:53:29",
            "facetId":559661,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861994,
            "assembleContent":"<p>插入新节点的最简单方法就是一路搜索下去，直到搜索到一个还没有节点的位置，之后进行插入。实现如下：</p><div><pre><code>void treeInsert(nodeptr_t root, int data)
{
    nodeptr_t newNode;

    newNode = malloc(sizeof(*newNode));
    assert(newNode);

    newNode->data = data;
    newNode->left = 0;
    newNode->right = 0;

    for(;;) {
        if(root->data > data) {
            if(root->left) {
                root = root->left;
            } else {
                root->left = newNode;
                return;
            }
        } else {
            if(root->right) {
                root = root->right;
            } else {
                root->right = newNode;
                return;
            }
        }
    }
}
</code></pre></div><p>这种操作的实现是极其简洁的。但是其缺点也是很明显的：这钟插入操作没有尝试平衡树。也就是说，在最坏的情况下，树可能只向某一个方向生长，使之退化为链表。我们会在后面引入改进的树结构来解决问题。</p> ",
            "assembleText":"插入新节点的最简单方法就是一路搜索下去，直到搜索到一个还没有节点的位置，之后进行插入。实现如下： void treeInsert(nodeptr_t root, int data)
{
    nodeptr_t newNode;

    newNode = malloc(sizeof(*newNode));
    assert(newNode);

    newNode->data = data;
    newNode->left = 0;
    newNode->right = 0;

    for(;;) {
        if(root->data > data) {
            if(root->left) {
                root = root->left;
            } else {
                root->left = newNode;
                return;
            }
        } else {
            if(root->right) {
                root = root->right;
            } else {
                root->right = newNode;
                return;
            }
        }
    }
}
 这种操作的实现是极其简洁的。但是其缺点也是很明显的：这钟插入操作没有尝试平衡树。也就是说，在最坏的情况下，树可能只向某一个方向生长，使之退化为链表。我们会在后面引入改进的树结构来解决问题。",
            "assembleScratchTime":"2019-03-16 20:54:03",
            "facetId":559661,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2861995,
            "assembleContent":"<p>基于树的特性，我们有时可以通过一种不使用 free() 的操作来进行杉树操作，步骤如下：</p><ol><li>在树的结构体内加入一个变量指示词节点是否被删除。</li><li>要删除某一节点，改变指示变量即可。</li></ol><p>操作极其简单，在此不再赘述。</p><p>现在我们来看“真正的删除树的操作”。要删除一个节点，我们需要考虑以下几种情况：</p><ol><li>要删除的节点没有子节点，此时的操作极为简单，只需要 <code>free</code> 掉该节点即可。</li><li>要删除的节点有一个子节点，此时的操作也不算复杂，只需要将其父节点指向其的指针替换为其子节点的指针，之后 <code>free</code> 该节点。</li><li>要删除的节点有两个节点，这种情况就比较复杂了。一般的做法是使用其右子树的最小节点的数据替换掉该节点的数据，然后递归的删除掉右子树的最小节点。</li></ol><p>实现如下：</p><div><pre><code>void treeDelete(nodeptr_t root, int value) {
    nodeptr_t temp;

    if(root == NULL)
        return;
    else if(value < root->data)
        treeDelete(root->left,data);
    else if(value > root->data)
        treeDelete(root->right,data);
    else if(root->left && root->right) {
        temp = __findMin(root->right);
        root->data = temp->data;
        treeDelete(root->right,root->data);
    } else {
        temp = root;
        if(root->left == NULL)
            root = root->right;
        else if(root->right == NULL)
            root = root->left;
        free(temp);
    }
}

nodeptr_t __findMin(nodeptr_t root) {
    if(root == NULL)
        return NULL;
    else if(root->left == NULL)
        return root;
    else
        return __findMin(root->left);
}
</code></pre></div><p>为了实现的易于理解，本代码的性能可能不是很好。对于初学者来说，优化本程序是一个不错的练习。</p> ",
            "assembleText":"基于树的特性，我们有时可以通过一种不使用 free() 的操作来进行杉树操作，步骤如下： 在树的结构体内加入一个变量指示词节点是否被删除。 要删除某一节点，改变指示变量即可。 操作极其简单，在此不再赘述。 现在我们来看“真正的删除树的操作”。要删除一个节点，我们需要考虑以下几种情况： 要删除的节点没有子节点，此时的操作极为简单，只需要 free 掉该节点即可。 要删除的节点有一个子节点，此时的操作也不算复杂，只需要将其父节点指向其的指针替换为其子节点的指针，之后 free 该节点。 要删除的节点有两个节点，这种情况就比较复杂了。一般的做法是使用其右子树的最小节点的数据替换掉该节点的数据，然后递归的删除掉右子树的最小节点。 实现如下： void treeDelete(nodeptr_t root, int value) {
    nodeptr_t temp;

    if(root == NULL)
        return;
    else if(value < root->data)
        treeDelete(root->left,data);
    else if(value > root->data)
        treeDelete(root->right,data);
    else if(root->left && root->right) {
        temp = __findMin(root->right);
        root->data = temp->data;
        treeDelete(root->right,root->data);
    } else {
        temp = root;
        if(root->left == NULL)
            root = root->right;
        else if(root->right == NULL)
            root = root->left;
        free(temp);
    }
}

nodeptr_t __findMin(nodeptr_t root) {
    if(root == NULL)
        return NULL;
    else if(root->left == NULL)
        return root;
    else
        return __findMin(root->left);
}
 为了实现的易于理解，本代码的性能可能不是很好。对于初学者来说，优化本程序是一个不错的练习。",
            "assembleScratchTime":"2019-03-16 20:54:22",
            "facetId":559661,
            "sourceId":2,
            "domainId":413,
            "url":"https://www.zhihu.com/question/29263118/answer/58772633",
            "type":"text"
        },
        {
            "assembleId":2862013,
            "assembleContent":"<p>计算二叉树的高度<br>       与计算二叉树节点高度类似，计算二叉树高度时如果高度为0，返回-1；否则按照后序遍历规则，先递归计算根结点的左子树和右子树的高度，再求两者中的较大者，并加1，最终得到整个二叉树的高度；<br><br>template<class T><br>int BinaryTree<T>::depth(BinaryTreeNode <T> *current)<br>{<br> if (current == NULL){ return -1; }<br> else{ return 1 + Max(depth(current->Lchild), depth(current->Rchild)); }<br>}<br><br></p> ",
            "assembleText":"计算二叉树的高度        与计算二叉树节点高度类似，计算二叉树高度时如果高度为0，返回-1；否则按照后序遍历规则，先递归计算根结点的左子树和右子树的高度，再求两者中的较大者，并加1，最终得到整个二叉树的高度； template<class T> int BinaryTree<T>::depth(BinaryTreeNode <T> *current) { if (current == NULL){ return -1; } else{ return 1 + Max(depth(current->Lchild), depth(current->Rchild)); } }",
            "assembleScratchTime":"2019-03-16 21:11:01",
            "facetId":559661,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2862014,
            "assembleContent":"<p>知道先序（后序）和中序求二叉树后序（先序）<br>     有一些题目喜欢提这样的问题，以知道先序和中序求后序为例，例如已知先序是ABDEHIJKCFG，已知中序是DBHEJIKAFCG，求二叉树的后序排列。（知道先序和后序是无法求出中序的）<br><br>       其实了解二叉树的遍历后，这个题目很简单。由于先序是先遍历根结点，先序排列的第一个点必定根结点，也就是说A是根结点；再看中序遍历，先遍历左子树，左子树遍历玩才会遍历根结点，因此，排在A前方的全是左子树上的点，排在A后方的全是，如果A在中序排列中也是排在第一个，说明它没有左子树。因此有了如下结构；<br><br><br><br>       再看左子树，此时左子树的先序为BDEHIJK，中序为DBHEJIK。同样的道理，B为A的左子树的根结点，中序排列中在B前面的为左子树，排在B后侧的为右子树；如此反复进行就能得出二叉树的结构，再进行后序遍历就能得出后序排列。<br><br><br><br>       当知道后序和中序排列求先序排列时，也是同样的道理，二叉树的根结点是最后被遍历到的点。<br><br>        根据上面的关系，可以的写出重建二叉树的函数；<br><br>template<class T><br>BinaryTreeNode<T>* BinaryTreeNode<T>::reConstructBinaryTree(vector<T> pre, vector<T> in)<br>{<br> BinaryTreeNode<T> *BiTree=NULL;<br> <br> int size = pre.size();<br> if (size != 0)<br> {<br> BiTree->data = pre[0];     //根结点赋值<br> //构建左右子树的序列；<br> vector<T> leftPre;<br> vector<T> leftIn;<br> vector<T> rightPre;<br> vector<T> rightIn;<br> <br> //在中序排列中找到根结点的位置<br> int i = 0;<br> for (; i<size; i++)<br> {<br> if (in[i] == pre[0])<br> {<br> break;<br> }<br> }<br> for (int j = 0; j < size; j++)<br> {<br> if (j<i)        //中序序列：排在根结点之前的放入左子树<br> {<br> if (j != i)<br> {<br> leftIn.push_back(in[j]);<br> }<br> <br> }<br> if (j>i)         //中序序列：排在根结点之后的放入右子树<br> {<br> <br> rightIn.push_back(in[j]);<br> }<br> }<br> for (int j = 1; j < size; j++)<br> {<br> if (j <= i)      //先序序列：排在根结点之前的放入左子树<br> {<br> leftPre.push_back(pre[j]);<br> }<br> if (j>i)         //先序序列：排在根结点之后的放入右子树<br> {<br> rightPre.push_back(pre[j]);<br> }<br> }<br> if (leftIn.size() != 1){ BiTree->Lchild = reConstructBinaryTree(leftPre, leftIn); }<br> if (rightIn.size() != 1){ BiTree->Rchild = reConstructBinaryTree(rightPre, rightIn); }<br> }<br> <br> return BiTree;<br>}<br></p> ",
            "assembleText":"知道先序（后序）和中序求二叉树后序（先序）      有一些题目喜欢提这样的问题，以知道先序和中序求后序为例，例如已知先序是ABDEHIJKCFG，已知中序是DBHEJIKAFCG，求二叉树的后序排列。（知道先序和后序是无法求出中序的）        其实了解二叉树的遍历后，这个题目很简单。由于先序是先遍历根结点，先序排列的第一个点必定根结点，也就是说A是根结点；再看中序遍历，先遍历左子树，左子树遍历玩才会遍历根结点，因此，排在A前方的全是左子树上的点，排在A后方的全是，如果A在中序排列中也是排在第一个，说明它没有左子树。因此有了如下结构；        再看左子树，此时左子树的先序为BDEHIJK，中序为DBHEJIK。同样的道理，B为A的左子树的根结点，中序排列中在B前面的为左子树，排在B后侧的为右子树；如此反复进行就能得出二叉树的结构，再进行后序遍历就能得出后序排列。        当知道后序和中序排列求先序排列时，也是同样的道理，二叉树的根结点是最后被遍历到的点。         根据上面的关系，可以的写出重建二叉树的函数； template<class T> BinaryTreeNode<T>* BinaryTreeNode<T>::reConstructBinaryTree(vector<T> pre, vector<T> in) { BinaryTreeNode<T> *BiTree=NULL; int size = pre.size(); if (size != 0) { BiTree->data = pre[0]; //根结点赋值 //构建左右子树的序列； vector<T> leftPre; vector<T> leftIn; vector<T> rightPre; vector<T> rightIn; //在中序排列中找到根结点的位置 int i = 0; for (; i<size; i++) { if (in[i] == pre[0]) { break; } } for (int j = 0; j < size; j++) { if (j<i) //中序序列：排在根结点之前的放入左子树 { if (j != i) { leftIn.push_back(in[j]); } } if (j>i) //中序序列：排在根结点之后的放入右子树 { rightIn.push_back(in[j]); } } for (int j = 1; j < size; j++) { if (j <= i) //先序序列：排在根结点之前的放入左子树 { leftPre.push_back(pre[j]); } if (j>i) //先序序列：排在根结点之后的放入右子树 { rightPre.push_back(pre[j]); } } if (leftIn.size() != 1){ BiTree->Lchild = reConstructBinaryTree(leftPre, leftIn); } if (rightIn.size() != 1){ BiTree->Rchild = reConstructBinaryTree(rightPre, rightIn); } } return BiTree; }",
            "assembleScratchTime":"2019-03-16 21:11:32",
            "facetId":559661,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/u013921430/article/details/80620334 ",
            "type":"text"
        },
        {
            "assembleId":2865521,
            "assembleContent":"<p>二叉树的查找<br><br>思路：与插入类似，从根节点开始，将查找的键值与根节点键值比较，若相等，则返回指向该节点的指针，若查找的键值比它大，则从根节点的右子树开始查找，若查找的键值比它小，则从根节点的左子树开始查找。可以用递归方法实现，类似于插入。这里我用迭代实现，能用迭代还是用迭代，因为递归开销比较大。<br>函数代码如下：<br><br>TreeNode *binaryTreeSereach(TreeNode * const treePtr, int value)<br>{<br> TreeNode *tempPtr = treePtr;<br> <br> while (tempPtr != NULL && tempPtr->data != value)<br> {<br> if (value > tempPtr->data)<br> tempPtr = tempPtr->rightPtr;<br> else<br> tempPtr = tempPtr->leftPtr;<br> }<br><br> return tempPtr;<br>}<br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"二叉树的查找 思路：与插入类似，从根节点开始，将查找的键值与根节点键值比较，若相等，则返回指向该节点的指针，若查找的键值比它大，则从根节点的右子树开始查找，若查找的键值比它小，则从根节点的左子树开始查找。可以用递归方法实现，类似于插入。这里我用迭代实现，能用迭代还是用迭代，因为递归开销比较大。 函数代码如下： TreeNode *binaryTreeSereach(TreeNode * const treePtr, int value) { TreeNode *tempPtr = treePtr; while (tempPtr != NULL && tempPtr->data != value) { if (value > tempPtr->data) tempPtr = tempPtr->rightPtr; else tempPtr = tempPtr->leftPtr; } return tempPtr; } --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:05:02",
            "facetId":559661,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2865528,
            "assembleContent":"<pre><code><p>二叉树的打印<br><br>从根节点开始，先输出右子树，再输出节点键值，再输出左子树。采用递归法<br>代码如下：<br>void outputTree(TreeNodePtr treePtr, int spaces)<br>{<br> int loop;<br> <br> while (treePtr != NULL) {<br><br> outputTree(treePtr->rightPtr, spaces + 4);<br><br> for (loop = 1; loop <= spaces; loop++) {<br> printf(" ");<br> } <br><br> printf("%d\n", treePtr->data);<br> <br> outputTree(treePtr->leftPtr, spaces + 4);<br> treePtr = NULL;<br> } <br>} <br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></code></pre> ",
            "assembleText":"二叉树的打印 从根节点开始，先输出右子树，再输出节点键值，再输出左子树。采用递归法 代码如下： void outputTree(TreeNodePtr treePtr, int spaces) { int loop; while (treePtr != NULL) { outputTree(treePtr->rightPtr, spaces + 4); for (loop = 1; loop <= spaces; loop++) { printf(" "); } printf("%d\n", treePtr->data); outputTree(treePtr->leftPtr, spaces + 4); treePtr = NULL; } } --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:06:04",
            "facetId":559661,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2865536,
            "assembleContent":"<pre><code><p>#include <stdio.h><br>#include <stdlib.h><br>#include <time.h><br><br>struct TreeNode {<br> struct TreeNode *leftPtr;  /* pointer to left subtree */<br> int data;                  /* node data */<br> struct TreeNode *rightPtr; /* pointer to right subtree */<br>};<br><br>typedef struct TreeNode TreeNode;<br><br>void insertNode(TreeNode **treePtr, int value);<br>TreeNode * binaryTreeSereach(TreeNode * const treePtr, int value);<br>void deleteNode(TreeNode **treePtrP, int value);<br>void outputTree(TreeNode *treePtr, int spaces);<br>void deleteNode2(TreeNode **treePtrP, int value);<br><br>int main(void)<br>{<br> int arr[] = { 45, 83, 28, 97, 71, 40, 18, 77, 99, 92, 72, 69, 44, 32, 19, 11 };<br> int i;                      /* loop counter */<br> int item;                   /* value to deal with */<br> int totalSpaces = 0;        /* spaces preceding output */<br> TreeNode *rootPtr = NULL; /* points to the tree root */<br><br> srand(time(NULL)); /* randomize */<br> printf("The numbers being placed in the tree are:\n\n");<br><br> for (i = 0; i < sizeof(arr) / sizeof(int); i++) {<br> item = arr[i];<br> printf("%3d", item);<br> insertNode(&rootPtr, item);<br> }<br><br> printf("\n\n\nnow the tree is:\n\n");<br><br> if (rootPtr == NULL)<br> printf("empty tree\n");<br> else<br> outputTree(rootPtr, totalSpaces);<br><br> //random delete Nodes, then output the tree<br> while (rootPtr != NULL)<br> {<br> item = rand() % 16;<br> printf("\n\nafter delete %d:\n\n", arr[item]);<br> deleteNode2(&rootPtr, arr[item]);<br><br> if (rootPtr == NULL)<br> printf("empty tree\n");<br> else<br> outputTree(rootPtr, totalSpaces);<br><br> }<br> <br> return 0; <br>}<br><br>void insertNode(TreeNode **treePtr, int value)<br>{<br><br> /* if treePtr is NULL */<br> if (*treePtr == NULL) {<br><br> *treePtr = malloc(sizeof(TreeNode));<br><br> if (*treePtr != NULL) {<br> (*treePtr)->data = value;<br> (*treePtr)->leftPtr = NULL;<br> (*treePtr)->rightPtr = NULL;<br> }<br> else {<br> printf("%d not inserted. No memory available.\n", value);<br> }<br><br> }<br> else {<br><br> /* insert node in left subtree */<br> if (value < (*treePtr)->data) {<br> insertNode(&((*treePtr)->leftPtr), value);<br> }<br> else {<br><br> /* insert node in right subtree */<br> if (value >(*treePtr)->data) {<br> insertNode(&((*treePtr)->rightPtr), value);<br> }<br> else {<br> printf("dup");<br> }<br> }<br><br> }<br><br>}<br><br>TreeNode *binaryTreeSereach(TreeNode * const treePtr, int value)<br>{<br> TreeNode *tempPtr = treePtr;<br><br> while (tempPtr != NULL && tempPtr->data != value)<br> {<br> if (value > tempPtr->data)<br> tempPtr = tempPtr->rightPtr;<br> else<br> tempPtr = tempPtr->leftPtr;<br> }<br><br> return tempPtr;<br>}<br><br>void deleteNode(TreeNode **treePtrP, int value)<br>{<br> TreeNode *deleteNodePtr = *treePtrP;<br> TreeNode *parentNodeOfDeletePtr = NULL;<br> TreeNode *substituteNodePtr;<br> TreeNode *parentNodeOfSubstitutePtr;<br><br> //find deleNode and its parentNode<br> while (deleteNodePtr != NULL && value != deleteNodePtr->data)<br> {<br> parentNodeOfDeletePtr = deleteNodePtr;<br><br> if (deleteNodePtr->data > value)<br> {<br> deleteNodePtr = deleteNodePtr->leftPtr;<br> }<br> else<br> {<br> deleteNodePtr = deleteNodePtr->rightPtr;<br> }<br> }<br><br> //case that can't find such Node<br> if (deleteNodePtr == NULL)<br> {<br> printf("no such Node, delete fail\n\n");<br> return;<br><br> }<br><br> //delete a leafNode<br> if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = NULL;<br> }<br> else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)<br> {<br> parentNodeOfDeletePtr->leftPtr = NULL;<br> }<br> else<br> {<br> parentNodeOfDeletePtr->rightPtr = NULL;<br> }<br><br> }<br> //delete a Node which has a left child Node<br> else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->leftPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr;<br><br> }<br><br> //delete a Node which has a right child Node<br> else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->rightPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr;<br><br> }<br> //delete a Node which has a left and a right child Node<br> else<br> {<br> parentNodeOfSubstitutePtr = deleteNodePtr;<br> substituteNodePtr = deleteNodePtr->leftPtr;<br><br> //search down and right to find substituteNode and its parentNode<br> while (substituteNodePtr->rightPtr != NULL)<br> {<br> parentNodeOfSubstitutePtr = substituteNodePtr;<br> substituteNodePtr = substituteNodePtr->rightPtr;<br><br> }<br><br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = substituteNodePtr;<br> }<br> else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)<br> {<br> parentNodeOfDeletePtr->leftPtr = substituteNodePtr;<br> }<br> else<br> {<br> parentNodeOfDeletePtr->rightPtr = substituteNodePtr;<br> }<br><br> substituteNodePtr->rightPtr = deleteNodePtr->rightPtr;<br><br> if (parentNodeOfSubstitutePtr != deleteNodePtr)<br> {<br> substituteNodePtr->leftPtr = deleteNodePtr->leftPtr;<br><br> if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr)<br> {<br> parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr;<br> }<br> else<br> {<br> parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr;<br> }<br> }<br> <br> }<br><br> free(deleteNodePtr);<br>}<br><br>void outputTree(TreeNode *treePtr, int spaces)<br>{<br> int loop;<br><br> while (treePtr != NULL) {<br><br> outputTree(treePtr->rightPtr, spaces + 4);<br><br> for (loop = 1; loop <= spaces; loop++) {<br> printf(" ");<br> }<br><br> printf("%d\n", treePtr->data);<br><br> outputTree(treePtr->leftPtr, spaces + 4);<br> treePtr = NULL;<br> }<br>}<br><br>void deleteNode2(TreeNode **treePtrP, int value)<br>{<br> TreeNode *deleteNodePtr = *treePtrP;<br> TreeNode *parentNodeOfDeletePtr = NULL;<br> TreeNode *substituteNodePtr;<br> TreeNode *parentNodeOfSubstitutePtr;<br><br> //find deleNode and its parentNode<br> while (deleteNodePtr != NULL && value != deleteNodePtr->data)<br> {<br> parentNodeOfDeletePtr = deleteNodePtr;<br><br> if (deleteNodePtr->data > value)<br> {<br> deleteNodePtr = deleteNodePtr->leftPtr;<br> }<br> else<br> {<br> deleteNodePtr = deleteNodePtr->rightPtr;<br> }<br> }<br><br> //case that can't find such Node<br> if (deleteNodePtr == NULL)<br> {<br> printf("no such Node, delete fail\n\n");<br> return;<br><br> }<br> <br> // delete a leafNode<br> if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = NULL;<br> }<br> else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr)<br> {<br> parentNodeOfDeletePtr->leftPtr = NULL;<br> }<br> else<br> {<br> parentNodeOfDeletePtr->rightPtr = NULL;<br> }<br><br> }<br> //delete a Node which has a left child Node<br> else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->leftPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr;<br> }<br><br> //delete a Node which has a right child Node<br> else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL)<br> {<br> //delete Node is root<br> if (parentNodeOfDeletePtr == NULL)<br> {<br> *treePtrP = deleteNodePtr->rightPtr;<br> }<br> else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr)<br> parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr;<br> else<br> parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr;<br> }<br> //delete a Node which has a left and a right child Node<br> else<br> {<br> //find substituteNode and its parentNode<br> parentNodeOfSubstitutePtr = deleteNodePtr;<br> substituteNodePtr = deleteNodePtr->leftPtr;<br><br> //search down and right<br> while (substituteNodePtr->rightPtr != NULL)<br> {<br> parentNodeOfSubstitutePtr = substituteNodePtr;<br> substituteNodePtr = substituteNodePtr->rightPtr;<br><br> }<br><br> if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr)<br> {<br> parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr;<br> }<br> else<br> {<br> parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr;<br> }<br><br> deleteNodePtr->data = substituteNodePtr->data;<br> deleteNodePtr = substituteNodePtr;<br> }<br><br> free(deleteNodePtr);<br>}<br>--------------------- <br>作者：biglamp <br>来源：CSDN <br>原文：https://blog.csdn.net/biglamp/article/details/77045193 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p></code></pre> ",
            "assembleText":"#include <stdio.h> #include <stdlib.h> #include <time.h> struct TreeNode { struct TreeNode *leftPtr; /* pointer to left subtree */ int data; /* node data */ struct TreeNode *rightPtr; /* pointer to right subtree */ }; typedef struct TreeNode TreeNode; void insertNode(TreeNode **treePtr, int value); TreeNode * binaryTreeSereach(TreeNode * const treePtr, int value); void deleteNode(TreeNode **treePtrP, int value); void outputTree(TreeNode *treePtr, int spaces); void deleteNode2(TreeNode **treePtrP, int value); int main(void) { int arr[] = { 45, 83, 28, 97, 71, 40, 18, 77, 99, 92, 72, 69, 44, 32, 19, 11 }; int i; /* loop counter */ int item; /* value to deal with */ int totalSpaces = 0; /* spaces preceding output */ TreeNode *rootPtr = NULL; /* points to the tree root */ srand(time(NULL)); /* randomize */ printf("The numbers being placed in the tree are:\n\n"); for (i = 0; i < sizeof(arr) / sizeof(int); i++) { item = arr[i]; printf("%3d", item); insertNode(&rootPtr, item); } printf("\n\n\nnow the tree is:\n\n"); if (rootPtr == NULL) printf("empty tree\n"); else outputTree(rootPtr, totalSpaces); //random delete Nodes, then output the tree while (rootPtr != NULL) { item = rand() % 16; printf("\n\nafter delete %d:\n\n", arr[item]); deleteNode2(&rootPtr, arr[item]); if (rootPtr == NULL) printf("empty tree\n"); else outputTree(rootPtr, totalSpaces); } return 0; } void insertNode(TreeNode **treePtr, int value) { /* if treePtr is NULL */ if (*treePtr == NULL) { *treePtr = malloc(sizeof(TreeNode)); if (*treePtr != NULL) { (*treePtr)->data = value; (*treePtr)->leftPtr = NULL; (*treePtr)->rightPtr = NULL; } else { printf("%d not inserted. No memory available.\n", value); } } else { /* insert node in left subtree */ if (value < (*treePtr)->data) { insertNode(&((*treePtr)->leftPtr), value); } else { /* insert node in right subtree */ if (value >(*treePtr)->data) { insertNode(&((*treePtr)->rightPtr), value); } else { printf("dup"); } } } } TreeNode *binaryTreeSereach(TreeNode * const treePtr, int value) { TreeNode *tempPtr = treePtr; while (tempPtr != NULL && tempPtr->data != value) { if (value > tempPtr->data) tempPtr = tempPtr->rightPtr; else tempPtr = tempPtr->leftPtr; } return tempPtr; } void deleteNode(TreeNode **treePtrP, int value) { TreeNode *deleteNodePtr = *treePtrP; TreeNode *parentNodeOfDeletePtr = NULL; TreeNode *substituteNodePtr; TreeNode *parentNodeOfSubstitutePtr; //find deleNode and its parentNode while (deleteNodePtr != NULL && value != deleteNodePtr->data) { parentNodeOfDeletePtr = deleteNodePtr; if (deleteNodePtr->data > value) { deleteNodePtr = deleteNodePtr->leftPtr; } else { deleteNodePtr = deleteNodePtr->rightPtr; } } //case that can't find such Node if (deleteNodePtr == NULL) { printf("no such Node, delete fail\n\n"); return; } //delete a leafNode if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = NULL; } else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr) { parentNodeOfDeletePtr->leftPtr = NULL; } else { parentNodeOfDeletePtr->rightPtr = NULL; } } //delete a Node which has a left child Node else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = deleteNodePtr->leftPtr; } else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr) parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr; else parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr; } //delete a Node which has a right child Node else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = deleteNodePtr->rightPtr; } else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr) parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr; else parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr; } //delete a Node which has a left and a right child Node else { parentNodeOfSubstitutePtr = deleteNodePtr; substituteNodePtr = deleteNodePtr->leftPtr; //search down and right to find substituteNode and its parentNode while (substituteNodePtr->rightPtr != NULL) { parentNodeOfSubstitutePtr = substituteNodePtr; substituteNodePtr = substituteNodePtr->rightPtr; } //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = substituteNodePtr; } else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr) { parentNodeOfDeletePtr->leftPtr = substituteNodePtr; } else { parentNodeOfDeletePtr->rightPtr = substituteNodePtr; } substituteNodePtr->rightPtr = deleteNodePtr->rightPtr; if (parentNodeOfSubstitutePtr != deleteNodePtr) { substituteNodePtr->leftPtr = deleteNodePtr->leftPtr; if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr) { parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr; } else { parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr; } } } free(deleteNodePtr); } void outputTree(TreeNode *treePtr, int spaces) { int loop; while (treePtr != NULL) { outputTree(treePtr->rightPtr, spaces + 4); for (loop = 1; loop <= spaces; loop++) { printf(" "); } printf("%d\n", treePtr->data); outputTree(treePtr->leftPtr, spaces + 4); treePtr = NULL; } } void deleteNode2(TreeNode **treePtrP, int value) { TreeNode *deleteNodePtr = *treePtrP; TreeNode *parentNodeOfDeletePtr = NULL; TreeNode *substituteNodePtr; TreeNode *parentNodeOfSubstitutePtr; //find deleNode and its parentNode while (deleteNodePtr != NULL && value != deleteNodePtr->data) { parentNodeOfDeletePtr = deleteNodePtr; if (deleteNodePtr->data > value) { deleteNodePtr = deleteNodePtr->leftPtr; } else { deleteNodePtr = deleteNodePtr->rightPtr; } } //case that can't find such Node if (deleteNodePtr == NULL) { printf("no such Node, delete fail\n\n"); return; } // delete a leafNode if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr == NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = NULL; } else if (parentNodeOfDeletePtr->leftPtr == deleteNodePtr) { parentNodeOfDeletePtr->leftPtr = NULL; } else { parentNodeOfDeletePtr->rightPtr = NULL; } } //delete a Node which has a left child Node else if (deleteNodePtr->leftPtr != NULL && deleteNodePtr->rightPtr == NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = deleteNodePtr->leftPtr; } else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr) parentNodeOfDeletePtr->rightPtr = deleteNodePtr->leftPtr; else parentNodeOfDeletePtr->leftPtr = deleteNodePtr->leftPtr; } //delete a Node which has a right child Node else if (deleteNodePtr->leftPtr == NULL && deleteNodePtr->rightPtr != NULL) { //delete Node is root if (parentNodeOfDeletePtr == NULL) { *treePtrP = deleteNodePtr->rightPtr; } else if (parentNodeOfDeletePtr->rightPtr == deleteNodePtr) parentNodeOfDeletePtr->rightPtr = deleteNodePtr->rightPtr; else parentNodeOfDeletePtr->leftPtr = deleteNodePtr->rightPtr; } //delete a Node which has a left and a right child Node else { //find substituteNode and its parentNode parentNodeOfSubstitutePtr = deleteNodePtr; substituteNodePtr = deleteNodePtr->leftPtr; //search down and right while (substituteNodePtr->rightPtr != NULL) { parentNodeOfSubstitutePtr = substituteNodePtr; substituteNodePtr = substituteNodePtr->rightPtr; } if (parentNodeOfSubstitutePtr->leftPtr == substituteNodePtr) { parentNodeOfSubstitutePtr->leftPtr = substituteNodePtr->leftPtr; } else { parentNodeOfSubstitutePtr->rightPtr = substituteNodePtr->leftPtr; } deleteNodePtr->data = substituteNodePtr->data; deleteNodePtr = substituteNodePtr; } free(deleteNodePtr); } --------------------- 作者：biglamp 来源：CSDN 原文：https://blog.csdn.net/biglamp/article/details/77045193 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:07:05",
            "facetId":559661,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850607,
            "assembleContent":"<pre> void(*VisitFunc)(TElemType); /* 函數變數 */
 void PreTraverse(SqBiTree T,int e)
 { /* PreOrderTraverse()調用 */
   VisitFunc(T[e]);
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     PreTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     PreTraverse(T,2*e+2);
 }</pre> ",
            "assembleText":"void(*VisitFunc)(TElemType); /* 函數變數 */
 void PreTraverse(SqBiTree T,int e)
 { /* PreOrderTraverse()調用 */
   VisitFunc(T[e]);
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     PreTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     PreTraverse(T,2*e+2);
 }",
            "assembleScratchTime":"2019-02-22 23:32:35",
            "facetId":558957,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850608,
            "assembleContent":"<pre> void PreOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹存在，Visit是對結點操作的應用函數 */
   /* 操作結果：先序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     PreTraverse(T,0);
   printf("\n");
 }</pre> ",
            "assembleText":"void PreOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹存在，Visit是對結點操作的應用函數 */
   /* 操作結果：先序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     PreTraverse(T,0);
   printf("\n");
 }",
            "assembleScratchTime":"2019-02-22 23:32:45",
            "facetId":558957,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861720,
            "assembleContent":"<p><b>先序遍历</b></p><p>即直接按照我们对结点的访问顺序输出遍历结果即实现，父结点值被最先输出。代码：</p><div><pre><code>def pre_order(self):
    print(self.value)

    if self.left_child:
        self.left_child.pre_order()

    if self.right_child:
        self.right_child.pre_order()</code></pre></div> ",
            "assembleText":"先序遍历 即直接按照我们对结点的访问顺序输出遍历结果即实现，父结点值被最先输出。代码： def pre_order(self):
    print(self.value)

    if self.left_child:
        self.left_child.pre_order()

    if self.right_child:
        self.right_child.pre_order()",
            "assembleScratchTime":"2019-03-15 19:22:45",
            "facetId":558957,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/30918614",
            "type":"text"
        },
        {
            "assembleId":2862137,
            "assembleContent":"<h3>先序遍历</h3><div><p>首先访问根，再<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=71558141&ss_c=ssc.citiao.link">先序遍历</a>左（右）子树，最后先序遍历右（左）子树</p></div> ",
            "assembleText":"先序遍历 首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树",
            "assembleScratchTime":"2019-03-16 22:24:54",
            "facetId":558957,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865489,
            "assembleContent":"<pre><code>void PreOrderTree(struct TreeNode* root) {<br> if (root == NULL) {<br> return;<br> }<br> printf("%d ", root->val);<br> PreOrderTree(root->left);<br> PreOrderTree(root->right);<br>}<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</code></pre><p><br></p> ",
            "assembleText":"void PreOrderTree(struct TreeNode* root) {  if (root == NULL) {  return;  }  printf("%d ", root->val);  PreOrderTree(root->left);  PreOrderTree(root->right); } --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:00:11",
            "facetId":558957,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850609,
            "assembleContent":"<pre> void InTraverse(SqBiTree T,int e)
 { /* InOrderTraverse()調用 */
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     InTraverse(T,2*e+1);
   VisitFunc(T[e]);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     InTraverse(T,2*e+2);
 }</pre> ",
            "assembleText":"void InTraverse(SqBiTree T,int e)
 { /* InOrderTraverse()調用 */
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     InTraverse(T,2*e+1);
   VisitFunc(T[e]);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     InTraverse(T,2*e+2);
 }",
            "assembleScratchTime":"2019-02-22 23:32:56",
            "facetId":558958,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850610,
            "assembleContent":"<pre>void InOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹存在，Visit是對結點操作的應用函數 */
   /* 操作結果：中序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     InTraverse(T,0);
   printf("\n");
 }</pre> ",
            "assembleText":"void InOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹存在，Visit是對結點操作的應用函數 */
   /* 操作結果：中序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     InTraverse(T,0);
   printf("\n");
 }",
            "assembleScratchTime":"2019-02-22 23:33:04",
            "facetId":558958,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861722,
            "assembleContent":"<p><b>中序遍历</b></p><figure><img src="https://pic3.zhimg.com/80/v2-0fa1c9c6902c39f05c8b4ca63048e426_hd.jpg" normal"="" width="1600" style="max-width:30%;"></figure><p>中序遍历输出结果为：3–2–4–1–6–5–7。</p><p>左孩子值最先输出，然后是父结点，最后是右孩子。对应代码如下：</p><div><pre><code>def in_order(self):
    if self.left_child:
        self.left_child.in_order()

    print(self.value)

    if self.right_child:
        self.right_child.in_order()</code></pre></div> ",
            "assembleText":"中序遍历 中序遍历输出结果为：3–2–4–1–6–5–7。 左孩子值最先输出，然后是父结点，最后是右孩子。对应代码如下： def in_order(self):
    if self.left_child:
        self.left_child.in_order()

    print(self.value)

    if self.right_child:
        self.right_child.in_order()",
            "assembleScratchTime":"2019-03-15 19:23:25",
            "facetId":558958,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/30918614",
            "type":"text"
        },
        {
            "assembleId":2862138,
            "assembleContent":"<h3>中序遍历</h3><div><p>首先<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=53330697&ss_c=ssc.citiao.link">中序遍历</a>左（右）子树，再访问根，最后中序遍历右（左）子树</p></div> ",
            "assembleText":"中序遍历 首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树",
            "assembleScratchTime":"2019-03-16 22:25:08",
            "facetId":558958,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865492,
            "assembleContent":"<p>void InOrderTree(struct TreeNode* root) {<br> if (root == NULL) {<br> return;<br> }<br> InOrderTree(root->left);<br> printf("%d ", root->val);<br> InOrderTree(root->right);<br>}<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"void InOrderTree(struct TreeNode* root) { if (root == NULL) { return; } InOrderTree(root->left); printf("%d ", root->val); InOrderTree(root->right); } --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:00:28",
            "facetId":558958,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850611,
            "assembleContent":"<pre>void PostTraverse(SqBiTree T,int e)
 { /* PostOrderTraverse()調用 */
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     PostTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     PostTraverse(T,2*e+2);
   VisitFunc(T[e]);
 }</pre> ",
            "assembleText":"void PostTraverse(SqBiTree T,int e)
 { /* PostOrderTraverse()調用 */
   if(T[2*e+1]!=Nil) /* 左子樹不空 */
     PostTraverse(T,2*e+1);
   if(T[2*e+2]!=Nil) /* 右子樹不空 */
     PostTraverse(T,2*e+2);
   VisitFunc(T[e]);
 }",
            "assembleScratchTime":"2019-02-22 23:33:16",
            "facetId":558959,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850612,
            "assembleContent":"<pre> void PostOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹T存在，Visit是對結點操作的應用函數 */
   /* 操作結果：後序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     PostTraverse(T,0);
   printf("\n");
 }</pre> ",
            "assembleText":"void PostOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 初始條件：二叉樹T存在，Visit是對結點操作的應用函數 */
   /* 操作結果：後序遍歷T，對每個結點調用函數Visit一次且僅一次 */
   VisitFunc=Visit;
   if(!BiTreeEmpty(T)) /* 樹不空 */
     PostTraverse(T,0);
   printf("\n");
 }",
            "assembleScratchTime":"2019-02-22 23:33:24",
            "facetId":558959,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861723,
            "assembleContent":"<p><b>后序遍历</b></p><figure><img src="https://pic3.zhimg.com/80/v2-0fa1c9c6902c39f05c8b4ca63048e426_hd.jpg" normal"="" width="1600"></figure><p>后序遍历输出结果为：3–4–2–6–7–5–1.</p><p>左右孩子值依次输出，最后是父结点，对应代码如下：</p><div><pre><code>def post_order(self):
    if self.left_child:
        self.left_child.post_order()

    if self.right_child:
        self.right_child.post_order()

    print(self.value)</code></pre></div> ",
            "assembleText":"后序遍历 后序遍历输出结果为：3–4–2–6–7–5–1. 左右孩子值依次输出，最后是父结点，对应代码如下： def post_order(self):
    if self.left_child:
        self.left_child.post_order()

    if self.right_child:
        self.right_child.post_order()

    print(self.value)",
            "assembleScratchTime":"2019-03-15 19:24:11",
            "facetId":558959,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/30918614",
            "type":"text"
        },
        {
            "assembleId":2862139,
            "assembleContent":"<h3>后序遍历</h3><div><p>首先<a target="_blank" href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7968377&ss_c=ssc.citiao.link">后序遍历</a>左（右）子树，再后序遍历右（左）子树，最后访问根</p></div> ",
            "assembleText":"后序遍历 首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根",
            "assembleScratchTime":"2019-03-16 22:25:23",
            "facetId":558959,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        },
        {
            "assembleId":2865494,
            "assembleContent":"<p><br>void PostOrderTree(struct TreeNode* root) {<br> if (root == NULL) {<br> return;<br> }<br> PostOrderTree(root->left);<br> PostOrderTree(root->right);<br> printf("%d ", root->val);<br>}<br>--------------------- <br>作者：zhanggonglalala <br>来源：CSDN <br>原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 <br>版权声明：本文为博主原创文章，转载请附上博文链接！</p> ",
            "assembleText":"void PostOrderTree(struct TreeNode* root) { if (root == NULL) { return; } PostOrderTree(root->left); PostOrderTree(root->right); printf("%d ", root->val); } --------------------- 作者：zhanggonglalala 来源：CSDN 原文：https://blog.csdn.net/zhanggonglalala/article/details/79738213 版权声明：本文为博主原创文章，转载请附上博文链接！",
            "assembleScratchTime":"2019-03-24 22:00:44",
            "facetId":558959,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/zhanggonglalala/article/details/79738213 ",
            "type":"text"
        },
        {
            "assembleId":2850613,
            "assembleContent":"<pre>void LevelOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 層序遍歷二叉樹 */
   int i=MAX_TREE_SIZE-1,j;
   while(T[i]==Nil)
     i--; /* 找到最後一個非空結點的序號 */
   for(j=0;j<=i;j++) /* 從根結點起，按層序遍歷二叉樹 */
     if(T[j]!=Nil)
       Visit(T[j]); /* 只遍歷非空的結點 */
   printf("\n");
 }</pre> ",
            "assembleText":"void LevelOrderTraverse(SqBiTree T,void(*Visit)(TElemType))
 { /* 層序遍歷二叉樹 */
   int i=MAX_TREE_SIZE-1,j;
   while(T[i]==Nil)
     i--; /* 找到最後一個非空結點的序號 */
   for(j=0;j<=i;j++) /* 從根結點起，按層序遍歷二叉樹 */
     if(T[j]!=Nil)
       Visit(T[j]); /* 只遍歷非空的結點 */
   printf("\n");
 }",
            "assembleScratchTime":"2019-02-22 23:33:39",
            "facetId":558960,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2850614,
            "assembleContent":"<pre> void Print(SqBiTree T)
 { /* 逐層、按本層序號輸出二叉樹 */
   int j,k;
   position p;
   TElemType e;
   for(j=1;j<=BiTreeDepth(T);j++)
   {
     printf("第%d層: ",j);
     for(k=1;k<=pow(2,j-1);k++)
     {
       p.level=j;
       p.order=k;
       e=Value(T,p);
       if(e!=Nil)
 printf("%d:"form" ",k,e);
     }
     printf("\n");
   }
 }</pre> ",
            "assembleText":"void Print(SqBiTree T)
 { /* 逐層、按本層序號輸出二叉樹 */
   int j,k;
   position p;
   TElemType e;
   for(j=1;j<=BiTreeDepth(T);j++)
   {
     printf("第%d層: ",j);
     for(k=1;k<=pow(2,j-1);k++)
     {
       p.level=j;
       p.order=k;
       e=Value(T,p);
       if(e!=Nil)
 printf("%d:"form" ",k,e);
     }
     printf("\n");
   }
 }",
            "assembleScratchTime":"2019-02-22 23:33:50",
            "facetId":558960,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91",
            "type":"text"
        },
        {
            "assembleId":2861734,
            "assembleContent":"<h2><b>广度优先搜索 (BFS)</b></h2><p><b>BFS</b> ：按照结点深度逐层遍历树结构。</p><figure><img src="https://pic2.zhimg.com/80/v2-ab7081b76ce7b3de86cdb725cc612b59_hd.jpg" normal"="" width="1600" style="max-width:30%;"></figure><p>再拿上面的图来实际解释这种方法：</p><figure><img src="https://pic3.zhimg.com/80/v2-0fa1c9c6902c39f05c8b4ca63048e426_hd.jpg" normal"="" width="1600" style="max-width:30%;"></figure><p>逐层每层从左到右进行遍历，对应遍历结果为：1–2–5–3–4–6–7。对应代码如下：</p><div><pre><code>def bfs(self):
    queue = Queue()
    queue.put(self)

    while not queue.empty():
        current_node = queue.get()
        print(current_node.value)

        if current_node.left_child:
            queue.put(current_node.left_child)

        if current_node.right_child:
            queue.put(current_node.right_child)
</code></pre></div><p>你应该已经注意到了，我们要借助先进先出(FIFO)的队列(queue)结构完成操作，具体的出入队列顺序如下图所示：</p><figure><img src="https://pic2.zhimg.com/80/v2-2404d497fdc34d8cb6f56959df51a4c1_hd.jpg" normal"="" width="1600" style="max-width:30%;"></figure> ",
            "assembleText":"广度优先搜索 (BFS) BFS ：按照结点深度逐层遍历树结构。 再拿上面的图来实际解释这种方法： 逐层每层从左到右进行遍历，对应遍历结果为：1–2–5–3–4–6–7。对应代码如下： def bfs(self):
    queue = Queue()
    queue.put(self)

    while not queue.empty():
        current_node = queue.get()
        print(current_node.value)

        if current_node.left_child:
            queue.put(current_node.left_child)

        if current_node.right_child:
            queue.put(current_node.right_child)
 你应该已经注意到了，我们要借助先进先出(FIFO)的队列(queue)结构完成操作，具体的出入队列顺序如下图所示：",
            "assembleScratchTime":"2019-03-15 19:29:19",
            "facetId":558960,
            "sourceId":2,
            "domainId":413,
            "url":"https://zhuanlan.zhihu.com/p/47925712",
            "type":"text"
        },
        {
            "assembleId":2862140,
            "assembleContent":"<h3>层次遍历</h3><div><p>即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同）</p></div> ",
            "assembleText":"层次遍历 即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同）",
            "assembleScratchTime":"2019-03-16 22:25:33",
            "facetId":558960,
            "sourceId":12,
            "domainId":413,
            "url":"https://baike.sogou.com/v111776.htm",
            "type":"text"
        }
    ]
}