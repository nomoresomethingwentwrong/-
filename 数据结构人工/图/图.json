{
    "code":200,
    "msg":"成功",
    "data":[
        {
            "assembleId":2856910,
            "assembleContent":"<div label-module="para-title"><h3><div label-module="para"><dl><dt>中文名</dt><dd>有向图</dd><dt>外文名</dt><dd>oriented graph</dd></dl><dl><dt>类    型</dt><dd>表示物件与物件之间的关系</dd><dt>三元组</dt><dd>V(D)，A(D)，ψD</dd></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"中文名 有向图 外文名 oriented graph 类    型 表示物件与物件之间的关系 三元组 V(D)，A(D)，ψD",
            "assembleScratchTime":"2019-03-03 19:06:30",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856912,
            "assembleContent":"<div label-module="para-title"><h3><div label-module="para"><dl><dt>一个有向图D是指一个有序<a target="_blank" href="https://baike.baidu.com/item/%E4%B8%89%E5%85%83%E7%BB%84/2434943">三元组</a>(V(D)，A(D)，ψD)，其中ψD)为<a target="_blank" href="https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0/8320961">关联函数</a>，它使A(D)中的每一个元素(称为有向边或弧)对应于V(D)中的一个有序元素(称为顶点或点)对．<sup> [1]</sup><a name="ref_[1]_807915"> </a>  <br></dt></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"一个有向图D是指一个有序三元组(V(D)，A(D)，ψD)，其中ψD)为关联函数，它使A(D)中的每一个元素(称为有向边或弧)对应于V(D)中的一个有序元素(称为顶点或点)对． [1]   ",
            "assembleScratchTime":"2019-03-03 19:06:36",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856913,
            "assembleContent":"<div label-module="para-title"><h3><div label-module="para"><dl><dt><div label-module="para"><b>孤立点</b>：V中不与E中任一条边关联的点称为D的孤立点．</div><div label-module="para"><b>简单图</b>：不含平行边的图称为简单图．</div><div label-module="para"><b>完备图</b>：图中任两个顶点U与u之间，恰有两条有向边(u，v)，及(v，u)，则称该有向图D为完备图．</div><div label-module="para"><b>基本图</b>：把有向图D的每条边除去定向就得到一个相应的无向图G，称G为D的基本图．称D为G的定向图．<sup> [2]</sup><a name="ref_[2]_807915"> </a></div></dt></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"孤立点：V中不与E中任一条边关联的点称为D的孤立点． 简单图：不含平行边的图称为简单图． 完备图：图中任两个顶点U与u之间，恰有两条有向边(u，v)，及(v，u)，则称该有向图D为完备图． 基本图：把有向图D的每条边除去定向就得到一个相应的无向图G，称G为D的基本图．称D为G的定向图． [2] ",
            "assembleScratchTime":"2019-03-03 19:06:48",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856914,
            "assembleContent":"<div label-module="para-title"><h3><div label-module="para"><dl><dt><div label-module="para"><div label-module="para"><b>强连通图</b>：给定有向图G=(VE)，并且给定该图G中的任意两个<a target="_blank" href="https://baike.baidu.com/item/%E7%BB%93%E7%82%B9">结点</a>u和v，如果结点u与结点v相互<a target="_blank" href="https://baike.baidu.com/item/%E5%8F%AF%E8%BE%BE">可达</a>，即至少存在一条路径可以由结点u开始，到结点v终止，同时存在至少有一条路径可以由结点v开始，到结点u终止，那么就称该有向图G是强连通图。</div><div label-module="para"><b>弱连通图:</b>若至少有一对结点不满足单向连通，但去掉边的方向后从无向图的观点看是<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE">连通图</a>，则D称为弱连通图．</div><div label-module="para"><b>单向连通图:</b>若每对结点至少有一个方向是连通的，则D称为单向连通图.<sup> [3]</sup><a name="ref_[3]_807915"> </a></div><div label-module="para"><b>强连通分支:</b>有向图G的极大强连通子图称为该有向图的强连通分支。<sup> [4]</sup><a name="ref_[4]_807915"> </a></div><div label-module="para"><b>有向通路：</b>无环有向图D中总存在这样一个独立集5，使得y—Js中任何一点"，存在H∈S，从M到"有长度不超过2的有向通路．<sup> [5]</sup><a name="ref_[5]_807915"> </a></div></div></dt></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"强连通图：给定有向图G=(VE)，并且给定该图G中的任意两个结点u和v，如果结点u与结点v相互可达，即至少存在一条路径可以由结点u开始，到结点v终止，同时存在至少有一条路径可以由结点v开始，到结点u终止，那么就称该有向图G是强连通图。 弱连通图:若至少有一对结点不满足单向连通，但去掉边的方向后从无向图的观点看是连通图，则D称为弱连通图． 单向连通图:若每对结点至少有一个方向是连通的，则D称为单向连通图. [3]  强连通分支:有向图G的极大强连通子图称为该有向图的强连通分支。 [4]  有向通路：无环有向图D中总存在这样一个独立集5，使得y—Js中任何一点"，存在H∈S，从M到"有长度不超过2的有向通路． [5] ",
            "assembleScratchTime":"2019-03-03 19:07:00",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856916,
            "assembleContent":"<div label-module="para-title"><h3><div label-module="para"><dl><dt><div label-module="para"><div label-module="para"><div label-module="para">除了孤立顶点外，任意顶点都至少与一条边相关联，因此，任何有向图，不考虑孤立顶点，可以由其边集完<div><a nslog-type="9317" href="https://baike.baidu.com/pic/%E6%9C%89%E5%90%91%E5%9B%BE/1852743/0/c9fcc3cec3fdfc0392ec15ccdd3f8794a4c22629?fr=lemma&ct=single" target="_blank" title=""><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=bc989f243da85edffe8cf921795509d8/c9fcc3cec3fdfc0392ec15ccdd3f8794a4c22629.jpg" alt=""></a></div>全描述．例如，如果D的边如下：</div><div label-module="para">(1，1)，(1，2)，(1，3)，(1，4)，(2，2)，(2，3)，(2，4)，(3，3)，(3，4)，(4，4)，</div><div label-module="para">注意，我们是按照字典序列出D的边的，只不过这里不是a，b，c，…，而是1，2，3.....</div><div label-module="para">依照这种思想，我们可以用<a target="_blank" href="https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069">矩阵</a>来完全地描述任何有向图，这就是有向图的邻接矩阵．<sup>[6]</sup><a name="ref_[6]_807915"> </a></div></div></div></dt></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"除了孤立顶点外，任意顶点都至少与一条边相关联，因此，任何有向图，不考虑孤立顶点，可以由其边集完 全描述．例如，如果D的边如下： (1，1)，(1，2)，(1，3)，(1，4)，(2，2)，(2，3)，(2，4)，(3，3)，(3，4)，(4，4)， 注意，我们是按照字典序列出D的边的，只不过这里不是a，b，c，…，而是1，2，3..... 依照这种思想，我们可以用矩阵来完全地描述任何有向图，这就是有向图的邻接矩阵．[6] ",
            "assembleScratchTime":"2019-03-03 19:07:10",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856917,
            "assembleContent":"<div label-module="para-title"><h2>最短路的求解</h2><h3><div label-module="para"><dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para-title"><a href="javascript:;"><em></em>编辑</a></div><div label-module="para">对于有向图最短路问题，计算步骤与求解无向图最短路问题相同，主要区别在于：无向图最短路问题使用单标号法。单标号法是对每一点赋予一个路权标号；而有向最短路问题使用双标号法．双标号法是对每一点赋予两个标号：<a target="_blank" href="https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84">路径</a>和<a target="_blank" href="https://baike.baidu.com/item/%E8%B7%AF%E6%9D%83">路权</a>。<sup> [7]</sup><a name="ref_[7]_807915"> </a></div></div></div></div></dt></dl></div></h3><h3><div label-module="para"><div></div></div><div></div></h3></div>  ",
            "assembleText":"最短路的求解 编辑 对于有向图最短路问题，计算步骤与求解无向图最短路问题相同，主要区别在于：无向图最短路问题使用单标号法。单标号法是对每一点赋予一个路权标号；而有向最短路问题使用双标号法．双标号法是对每一点赋予两个标号：路径和路权。 [7] ",
            "assembleScratchTime":"2019-03-03 19:07:19",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743?fr=aladdin",
            "type":"text"
        },
        {
            "assembleId":2856918,
            "assembleContent":"<div label-module="para-title"><h2>可达性</h2><h2><div label-module="para">对于一个<a target="_blank" href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE">无向图</a>来说，如果它是<a target="_blank" href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A/8663628">连通</a>的，那么它的任意两个顶点之问必存在一条路径，因此，通过这一路径可从一个顶点“到达”另一个顶点，若从顶点“可以到达u，则从u也可以到达“，也即v和u之间是互相可以到达的。</div><div label-module="para">对于有向图，情形就不同了，因为存在从u到v的路径，并不蕴涵也存在从v到u的路径。</div><div label-module="para">设D是一个有向图，且u、v∈D，若存在从顶点u到顶点v的一条路径，则称从顶点v到顶点u可达。</div><div label-module="para">可达的慨念与从u到v的各种路径的数目及路径的长度无关。另外，为了完备起见，规定任一顶点到达它自身的是可达的。</div><div label-module="para">可达性是一个有向图顶点的二元关系，依照定义，它是自反的，且是传递的。一般来说，可达不是对称的，也不是反对称的。</div></h2><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"可达性 对于一个无向图来说，如果它是连通的，那么它的任意两个顶点之问必存在一条路径，因此，通过这一路径可从一个顶点“到达”另一个顶点，若从顶点“可以到达u，则从u也可以到达“，也即v和u之间是互相可以到达的。 对于有向图，情形就不同了，因为存在从u到v的路径，并不蕴涵也存在从v到u的路径。 设D是一个有向图，且u、v∈D，若存在从顶点u到顶点v的一条路径，则称从顶点v到顶点u可达。 可达的慨念与从u到v的各种路径的数目及路径的长度无关。另外，为了完备起见，规定任一顶点到达它自身的是可达的。 可达性是一个有向图顶点的二元关系，依照定义，它是自反的，且是传递的。一般来说，可达不是对称的，也不是反对称的。",
            "assembleScratchTime":"2019-03-15 19:44:28",
            "facetId":557505,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861770,
            "assembleContent":"<div label-module="para-title"><h4><span id="Directed_graph">Directed graph</span></h4><h4><p>A <i>directed graph</i> or <i>digraph</i> is a graph in which edges have orientations. It is written as an ordered pair <i>G</i> = (<i>V</i>, <i>A</i>) (sometimes <i>G</i> = (<i>V</i>, <i>E</i>)) with</p><ul><li><i>V</i> a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)" title="Set (mathematics)">set</a> whose <a href="https://en.wikipedia.org/wiki/Element_(mathematics)" title="Element (mathematics)">elements</a> are called <i>vertices</i>, <i>nodes</i>, or <i>points</i>;</li><li><i>A</i> a set of <a href="https://en.wikipedia.org/wiki/Ordered_pair" title="Ordered pair">ordered pairs</a> of vertices, called <i>arrows</i>, <i>directed edges</i> (sometimes simply <i>edges</i> with the corresponding set named <i>E</i> instead of <i>A</i>), <i>directed arcs</i>, or <i>directed lines</i>.</li></ul><p>An arrow (<i>x</i>, <i>y</i>) is considered to be directed <i>from</i> <i>x</i> <i>to</i> <i>y</i>; <i>y</i> is called the <i>head</i> and <i>x</i> is called the <i>tail</i> of the arrow; <i>y</i> is said to be a <i>direct successor</i> of <i>x</i> and <i>x</i> is said to be a <i>direct predecessor</i> of <i>y</i>. If a <a href="https://en.wikipedia.org/wiki/Path_(graph_theory)" title="Path (graph theory)">path</a> leads from <i>x</i> to <i>y</i>, then <i>y</i> is said to be a <i>successor</i> of <i>x</i> and <i>reachable</i> from <i>x</i>, and <i>x</i> is said to be a <i>predecessor</i> of <i>y</i>. The arrow (<i>y</i>, <i>x</i>) is called the <i>inverted arrow</i> of (<i>x</i>, <i>y</i>).</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"Directed graph A directed graph or digraph is a graph in which edges have orientations. It is written as an ordered pair G = (V, A) (sometimes G = (V, E)) with V a set whose elements are called vertices, nodes, or points; A a set of ordered pairs of vertices, called arrows, directed edges (sometimes simply edges with the corresponding set named E instead of A), directed arcs, or directed lines. An arrow (x, y) is considered to be directed from x to y; y is called the head and x is called the tail of the arrow; y is said to be a direct successor of x and x is said to be a direct predecessor of y. If a path leads from x to y, then y is said to be a successor of x and reachable from x, and x is said to be a predecessor of y. The arrow (y, x) is called the inverted arrow of (x, y).",
            "assembleScratchTime":"2019-03-15 19:46:20",
            "facetId":557505,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861772,
            "assembleContent":"<div label-module="para-title"><h4>A directed graph <i>G</i> is called <i>symmetric</i> if, for every arrow in <i>G</i>, the corresponding inverted arrow also belongs to <i>G</i>. A symmetric loopless directed graph <i>G</i> = (<i>V</i>, <i>A</i>) is equivalent to a simple undirected graph <i>G′</i> = (<i>V</i>, <i>E</i>), where the pairs of inverse arrows in <i>A</i> correspond one-to-one with the edges in <i>E</i>; thus the number of edges in <i>G′</i> is |<i>E</i> | = |<i>A</i> |/2, that is half the number of arrows in <i>G</i>. </h4><div><a href="https://en.wikipedia.org/wiki/File:Directed.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Directed.svg/125px-Directed.svg.png" decoding="async" width="125" height="113" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Directed.svg/188px-Directed.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/a2/Directed.svg/250px-Directed.svg.png 2x"></a></div><h4><span style="font-family: "Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 14px;">A directed graph.</span> <br></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"A directed graph G is called symmetric if, for every arrow in G, the corresponding inverted arrow also belongs to G. A symmetric loopless directed graph G = (V, A) is equivalent to a simple undirected graph G′ = (V, E), where the pairs of inverse arrows in A correspond one-to-one with the edges in E; thus the number of edges in G′ is |E | = |A |/2, that is half the number of arrows in G.  A directed graph. ",
            "assembleScratchTime":"2019-03-15 19:46:35",
            "facetId":557505,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863358,
            "assembleContent":"<h2><p>对于一个图G，若每条边都是有方向的，则称该图为有向图。图示如下：</p><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516730681397.jpg"></p><p>因此，(V<sub>i</sub>，V<sub>j</sub>)和(V<sub>j</sub>，V<sub>i</sub>)是两条不同的有向边。注意，有向边又称为弧。</p><p>有向图的顶点集和边集分别表示为：</p><p>V(G)={V<sub>1</sub>，V<sub>2</sub>，V<sub>3</sub>}</p><p>E(G)={<V<sub>1</sub>，V<sub>2</sub>>，<V<sub>2</sub>，V<sub>3</sub>>，<V<sub>3</sub>，V<sub>1</sub>>，<V<sub>1</sub>，V<sub>3</sub>>}</p></h2> ",
            "assembleText":"对于一个图G，若每条边都是有方向的，则称该图为有向图。图示如下： 因此，(Vi，Vj)和(Vj，Vi)是两条不同的有向边。注意，有向边又称为弧。 有向图的顶点集和边集分别表示为： V(G)={V1，V2，V3} E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}",
            "assembleScratchTime":"2019-03-20 22:41:58",
            "facetId":557505,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863500,
            "assembleContent":"<h3>如果给图的每条边规定一个方向，那么得到的图称为<b>有向图</b>，其边也称为有向边。在有向图中，与一个节点相关联的边有出边和入边之分，而与一个有向边关联的两个点也有始点和终点之分。相反，边没有方向的图称为<b>无向图</b>。  <br></h3> ",
            "assembleText":"如果给图的每条边规定一个方向，那么得到的图称为有向图，其边也称为有向边。在有向图中，与一个节点相关联的边有出边和入边之分，而与一个有向边关联的两个点也有始点和终点之分。相反，边没有方向的图称为无向图。  ",
            "assembleScratchTime":"2019-03-21 20:00:53",
            "facetId":557505,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863959,
            "assembleContent":"<h6>有向图</h6><h4><p>有向边（弧）的有限集合。</p><p>有向图即图的边是有方向的，也称为弧。用<v, w>表示，v为弧尾，w 是弧头。</p></h4> ",
            "assembleText":"有向图 有向边（弧）的有限集合。 有向图即图的边是有方向的，也称为弧。用<v, w>表示，v为弧尾，w 是弧头。",
            "assembleScratchTime":"2019-03-23 20:37:56",
            "facetId":557505,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2861762,
            "assembleContent":"<h4><span id="Cycle_graph">Cycle graph</span></h4><h3><p>A <i>cycle graph</i> or <i>circular graph</i> of order <i>n</i> ≥ 3 is a graph in which the vertices can be listed in an order <i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, …, <i>v</i><sub><i>n</i></sub> such that the edges are the {<i>v</i><sub><i>i</i></sub>, <i>v</i><sub><i>i</i>+1</sub>} where <i>i</i> = 1, 2, …, <i>n</i> − 1, plus the edge {<i>v</i><sub><i>n</i></sub>, <i>v</i><sub>1</sub>}. Cycle graphs can be characterized as connected graphs in which the degree of all vertices is 2. If a cycle graph occurs as a subgraph of another graph, it is a cycle or circuit in that graph.</p></h3>  ",
            "assembleText":"Cycle graph A cycle graph or circular graph of order n ≥ 3 is a graph in which the vertices can be listed in an order v1, v2, …, vn such that the edges are the {vi, vi+1} where i = 1, 2, …, n − 1, plus the edge {vn, v1}. Cycle graphs can be characterized as connected graphs in which the degree of all vertices is 2. If a cycle graph occurs as a subgraph of another graph, it is a cycle or circuit in that graph.",
            "assembleScratchTime":"2019-03-15 19:43:04",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861785,
            "assembleContent":"<div label-module="para-title"><h4><span id="Regular_graph">Regular graph</span><br></h4><h4><p>A <i>regular graph</i> is a graph in which each vertex has the same number of neighbours, i.e., every vertex has the same degree. A regular graph with vertices of degree <i>k</i> is called a <i>k</i>‑regular graph or regular graph of degree <i>k</i>.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Regular graph A regular graph is a graph in which each vertex has the same number of neighbours, i.e., every vertex has the same degree. A regular graph with vertices of degree k is called a k‑regular graph or regular graph of degree k.",
            "assembleScratchTime":"2019-03-15 19:53:22",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861779,
            "assembleContent":"<div label-module="para-title"><h4><span id="Oriented_graph">Oriented graph</span></h4><h4><p>An <i>oriented graph</i> is a directed graph in which at most one of (<i>x</i>, <i>y</i>) and (<i>y</i>, <i>x</i>) may be arrows of the graph. That is, it is a directed graph that can be formed as an <a href="https://en.wikipedia.org/wiki/Orientation_(graph_theory)" title="Orientation (graph theory)">orientation</a> of an undirected graph. However, some authors use "oriented graph" to mean the same as "directed graph".</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Oriented graph An oriented graph is a directed graph in which at most one of (x, y) and (y, x) may be arrows of the graph. That is, it is a directed graph that can be formed as an orientation of an undirected graph. However, some authors use "oriented graph" to mean the same as "directed graph".",
            "assembleScratchTime":"2019-03-15 19:48:22",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861780,
            "assembleContent":"<div label-module="para-title"><h4><span id="Mixed_graph">Mixed graph</span></h4><h4><p>A <i>mixed graph</i> is a graph in which some edges may be directed and some may be undirected. It is written as an ordered triple <i>G</i> = (<i>V</i>, <i>E</i>, <i>A</i>) with <i>V</i>, <i>E</i>, and <i>A</i> defined as above. Directed and undirected graphs are special cases.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Mixed graph A mixed graph is a graph in which some edges may be directed and some may be undirected. It is written as an ordered triple G = (V, E, A) with V, E, and A defined as above. Directed and undirected graphs are special cases.",
            "assembleScratchTime":"2019-03-15 19:48:35",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861782,
            "assembleContent":"<div label-module="para-title"><h4><span id="Multigraph">Multigraph</span><br></h4><h4><p><i><a href="https://en.wikipedia.org/wiki/Multiple_edge" title="Multiple edge">Multiple edges</a></i> are two or more edges that connect the same two vertices. A <i><a href="https://en.wikipedia.org/wiki/Loop_(graph_theory)" title="Loop (graph theory)">loop</a></i> is an edge (directed or undirected) that connects a vertex to itself; it may be permitted or not, according to the application. In this context, an edge with two different ends is called a <i>link</i>.</p><p>A <i>multigraph</i>, as opposed to a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graphs">simple graph</a>, is an undirected graph in which multiple edges (and sometimes loops) are allowed.</p><p>Where graphs are defined so as to <i>disallow</i> both multiple edges and loops, a multigraph is often defined to mean a graph which can have both multiple edges and loops, although many use the term <i><a href="https://en.wikipedia.org/wiki/Pseudograph" title="Pseudograph">pseudograph</a></i> for this meaning. Where graphs are defined so as to <i>allow</i> both multiple edges and loops, a multigraph is often defined to mean a graph without loops.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Multigraph Multiple edges are two or more edges that connect the same two vertices. A loop is an edge (directed or undirected) that connects a vertex to itself; it may be permitted or not, according to the application. In this context, an edge with two different ends is called a link. A multigraph, as opposed to a simple graph, is an undirected graph in which multiple edges (and sometimes loops) are allowed. Where graphs are defined so as to disallow both multiple edges and loops, a multigraph is often defined to mean a graph which can have both multiple edges and loops, although many use the term pseudograph for this meaning. Where graphs are defined so as to allow both multiple edges and loops, a multigraph is often defined to mean a graph without loops.",
            "assembleScratchTime":"2019-03-15 19:49:07",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861784,
            "assembleContent":"<div label-module="para-title"><h4><span id="Simple_graph">Simple graph</span></h4><h4><p>A simple graph is an undirected graph with neither <a href="https://en.wikipedia.org/wiki/Multiple_edges" title="Multiple edges">multiple edges</a> nor <a href="https://en.wikipedia.org/wiki/Loop_(graph_theory)" title="Loop (graph theory)">loops</a>. In a simple graph the edges form a <i>set</i> (rather than a <a href="https://en.wikipedia.org/wiki/Multiset" title="Multiset">multiset</a>) and each edge is an unordered pair of <i>distinct</i>vertices. Thus, we can define a <b>simple graph</b> to be a set <i>V</i> of vertices together with a set <i>E</i> of edges, which are 2-element subsets of <i>V</i>.</p><p>In a simple graph with <i>n</i> vertices, the degree of every vertex is at most <i>n</i> − 1.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Simple graph A simple graph is an undirected graph with neither multiple edges nor loops. In a simple graph the edges form a set (rather than a multiset) and each edge is an unordered pair of distinctvertices. Thus, we can define a simple graph to be a set V of vertices together with a set E of edges, which are 2-element subsets of V. In a simple graph with n vertices, the degree of every vertex is at most n − 1.",
            "assembleScratchTime":"2019-03-15 19:49:39",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861787,
            "assembleContent":"<div label-module="para-title"><h4><span id="Complete_graph">Complete graph</span><br></h4><h4><div><div><a href="https://en.wikipedia.org/wiki/File:Complete_graph_K5.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Complete_graph_K5.svg/125px-Complete_graph_K5.svg.png" decoding="async" width="125" height="123" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Complete_graph_K5.svg/188px-Complete_graph_K5.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Complete_graph_K5.svg/250px-Complete_graph_K5.svg.png 2x"></a><div><div><a href="https://en.wikipedia.org/wiki/File:Complete_graph_K5.svg" title="Enlarge"></a></div>A complete graph with 5 vertices. Each vertex has an edge to every other vertex.</div></div></div><p>A <i>complete graph</i> is a graph in which each pair of vertices is joined by an edge. A complete graph contains all possible edges.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Complete graph A complete graph with 5 vertices. Each vertex has an edge to every other vertex. A complete graph is a graph in which each pair of vertices is joined by an edge. A complete graph contains all possible edges.",
            "assembleScratchTime":"2019-03-15 19:58:15",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861788,
            "assembleContent":"<div label-module="para-title"><h4><span id="Connected_graph">Connected graph</span><br></h4><h4><p>In an undirected graph, an unordered pair of vertices {<i>x</i>, <i>y</i>} is called <i>connected</i> if a path leads from <i>x</i> to <i>y</i>. Otherwise, the unordered pair is called <i>disconnected</i>.</p><p>A <i>connected graph</i> is an undirected graph in which every unordered pair of vertices in the graph is connected. Otherwise, it is called a <i>disconnected graph</i>.</p><p>In a directed graph, an ordered pair of vertices (<i>x</i>, <i>y</i>) is called <i>strongly connected</i> if a directed path leads from <i>x</i> to <i>y</i>. Otherwise, the ordered pair is called <i>weakly connected</i> if an undirected path leads from <i>x</i> to <i>y</i> after replacing all of its directed edges with undirected edges. Otherwise, the ordered pair is called <i>disconnected</i>.</p><p>A <i>strongly connected graph</i> is a directed graph in which every ordered pair of vertices in the graph is strongly connected. Otherwise, it is called a <i>weakly connected graph</i> if every ordered pair of vertices in the graph is weakly connected. Otherwise it is called a <i>disconnected graph</i>.</p><p>A <i><a href="https://en.wikipedia.org/wiki/K-vertex-connected_graph" title="K-vertex-connected graph">k-vertex-connected graph</a></i> or <i><a href="https://en.wikipedia.org/wiki/K-edge-connected_graph" title="K-edge-connected graph">k-edge-connected graph</a></i> is a graph in which no set of <i>k</i> − 1 vertices (respectively, edges) exists that, when removed, disconnects the graph. A <i>k</i>-vertex-connected graph is often called simply a <i>k-connected graph</i>.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Connected graph In an undirected graph, an unordered pair of vertices {x, y} is called connected if a path leads from x to y. Otherwise, the unordered pair is called disconnected. A connected graph is an undirected graph in which every unordered pair of vertices in the graph is connected. Otherwise, it is called a disconnected graph. In a directed graph, an ordered pair of vertices (x, y) is called strongly connected if a directed path leads from x to y. Otherwise, the ordered pair is called weakly connected if an undirected path leads from x to y after replacing all of its directed edges with undirected edges. Otherwise, the ordered pair is called disconnected. A strongly connected graph is a directed graph in which every ordered pair of vertices in the graph is strongly connected. Otherwise, it is called a weakly connected graph if every ordered pair of vertices in the graph is weakly connected. Otherwise it is called a disconnected graph. A k-vertex-connected graph or k-edge-connected graph is a graph in which no set of k − 1 vertices (respectively, edges) exists that, when removed, disconnects the graph. A k-vertex-connected graph is often called simply a k-connected graph.",
            "assembleScratchTime":"2019-03-15 19:58:53",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861791,
            "assembleContent":"<div label-module="para-title"><h4><span id="Bipartite_graph">Bipartite graph</span><br></h4><h4><p>A <i><a href="https://en.wikipedia.org/wiki/Bipartite_graph" title="Bipartite graph">bipartite graph</a></i> is a simple graph in which the vertex set can be <a href="https://en.wikipedia.org/wiki/Partition_of_a_set" title="Partition of a set">partitioned</a> into two sets, <i>W</i> and <i>X</i>, so that no two vertices in <i>W</i> share a common edge and no two vertices in <i>X</i> share a common edge. Alternatively, it is a graph with a <a href="https://en.wikipedia.org/wiki/Chromatic_number" title="Chromatic number">chromatic number</a> of 2.</p><p>In a <a href="https://en.wikipedia.org/wiki/Complete_bipartite_graph" title="Complete bipartite graph">complete bipartite graph</a>, the vertex set is the union of two disjoint sets, <i>W</i> and <i>X</i>, so that every vertex in <i>W</i> is adjacent to every vertex in <i>X</i> but there are no edges within <i>W</i> or <i>X</i>.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Bipartite graph A bipartite graph is a simple graph in which the vertex set can be partitioned into two sets, W and X, so that no two vertices in W share a common edge and no two vertices in X share a common edge. Alternatively, it is a graph with a chromatic number of 2. In a complete bipartite graph, the vertex set is the union of two disjoint sets, W and X, so that every vertex in W is adjacent to every vertex in X but there are no edges within W or X.",
            "assembleScratchTime":"2019-03-15 20:02:48",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861792,
            "assembleContent":"<div label-module="para-title"><h4><span id="Path_graph">Path graph</span><br></h4><h4><p>A <i>path graph</i> or <i>linear graph</i> of order <i>n</i> ≥ 2 is a graph in which the vertices can be listed in an order <i>v</i><sub>1</sub>, <i>v</i><sub>2</sub>, …, <i>v</i><sub><i>n</i></sub> such that the edges are the {<i>v</i><sub><i>i</i></sub>, <i>v</i><sub><i>i</i>+1</sub>} where <i>i</i> = 1, 2, …, <i>n</i> − 1. Path graphs can be characterized as connected graphs in which the degree of all but two vertices is 2 and the degree of the two remaining vertices is 1. If a path graph occurs as a <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs" title="Glossary of graph theory">subgraph</a> of another graph, it is a <a href="https://en.wikipedia.org/wiki/Path_(graph_theory)" title="Path (graph theory)">path</a> in that graph.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Path graph A path graph or linear graph of order n ≥ 2 is a graph in which the vertices can be listed in an order v1, v2, …, vn such that the edges are the {vi, vi+1} where i = 1, 2, …, n − 1. Path graphs can be characterized as connected graphs in which the degree of all but two vertices is 2 and the degree of the two remaining vertices is 1. If a path graph occurs as a subgraph of another graph, it is a path in that graph.",
            "assembleScratchTime":"2019-03-15 20:03:04",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863359,
            "assembleContent":"<h2><p>我们将具有n(n-1)/2条边的无向图称为无向完全图。同理，将具有n(n-1)条边的有向图称为有向完全图。  <br></p></h2> ",
            "assembleText":"我们将具有n(n-1)/2条边的无向图称为无向完全图。同理，将具有n(n-1)条边的有向图称为有向完全图。  ",
            "assembleScratchTime":"2019-03-20 22:42:24",
            "facetId":557502,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863364,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>连通图是指图G中任意两个顶点V<sub>i</sub>和V<sub>j</sub>都连通，则称为连通图。  <br></p></h3> ",
            "assembleText":"连通图是指图G中任意两个顶点Vi和Vj都连通，则称为连通图。  ",
            "assembleScratchTime":"2019-03-20 22:53:53",
            "facetId":557502,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863366,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>强连通图是对于有向图而言的，与无向图的连通图类似。  <br></p></h3> ",
            "assembleText":"强连通图是对于有向图而言的，与无向图的连通图类似。  ",
            "assembleScratchTime":"2019-03-20 22:54:27",
            "facetId":557502,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863367,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>带”权值”的连通图称为网。如图所示：</p><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516732346259.jpg"></p></h3> ",
            "assembleText":"带”权值”的连通图称为网。如图所示：",
            "assembleScratchTime":"2019-03-20 22:56:29",
            "facetId":557502,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863501,
            "assembleContent":"<h3><span id="简单图">简单图</span></h3><h3><p>一个图如果</p><ol><li>没有两条边，它们所关联的两个点都相同（在<i>有向图</i>中，没有两条边的起点终点都分别相同）；</li><li>每条边所关联的是两个不同的顶点</li></ol><dl><dd>则称为简单图（Simple graph）。简单的有向图和无向图都可以使用以上的“二元组的定义”，但形如<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (x,x)}"><semantics><annotation encoding="application/x-tex">{\displaystyle (x,x)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/72f9e25892f6d000349b8bb6578a59567efbdd63" aria-hidden="true" alt="(x,x)">的序对不能属于E。而无向图的边集必须是对称的，即如果<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (x,y)\in E}"><semantics><annotation encoding="application/x-tex">{\displaystyle (x,y)\in E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9ae449747f6f0429c02e36830b8a2ff94ac3dc77" aria-hidden="true" alt="(x,y)\in E">，那么<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (y,x)\in E}"><semantics><annotation encoding="application/x-tex">{\displaystyle (y,x)\in E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/882f7e261a417a9f4a6d6425b0bfee67472edf82" aria-hidden="true" alt="(y,x)\in E">。</dd></dl></h3> ",
            "assembleText":"简单图 一个图如果 没有两条边，它们所关联的两个点都相同（在有向图中，没有两条边的起点终点都分别相同）； 每条边所关联的是两个不同的顶点 则称为简单图（Simple graph）。简单的有向图和无向图都可以使用以上的“二元组的定义”，但形如 {\displaystyle (x,x)}的序对不能属于E。而无向图的边集必须是对称的，即如果 {\displaystyle (x,y)\in E}，那么 {\displaystyle (y,x)\in E}。",
            "assembleScratchTime":"2019-03-21 20:02:45",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863502,
            "assembleContent":"<h3><span id="多重圖">多重图</span></h3><h3><p>若允许两结点间的边数多于一条，又允许顶点通过同一条边和自己关联，则为多重图的概念。它只能用“三元组的定义”。</p></h3> ",
            "assembleText":"多重图 若允许两结点间的边数多于一条，又允许顶点通过同一条边和自己关联，则为多重图的概念。它只能用“三元组的定义”。",
            "assembleScratchTime":"2019-03-21 20:02:58",
            "facetId":557502,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863649,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><p>完全图可分为有向完全图和无向完全图两种，如果一个图的任意两个结点之间有且只有一条边，则称此图为无向完全图，若任意两个结点之间有且只有方向相反的两条边，则称为有向完全图。  <br></p></div></div></div></dt></h2>   ",
            "assembleText":"完全图可分为有向完全图和无向完全图两种，如果一个图的任意两个结点之间有且只有一条边，则称此图为无向完全图，若任意两个结点之间有且只有方向相反的两条边，则称为有向完全图。  ",
            "assembleScratchTime":"2019-03-22 16:59:07",
            "facetId":557502,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863676,
            "assembleContent":"<div><li>设G是n阶无向简单图，若G中每个顶点均与其余n-1个顶点相邻，则称G为n阶无向完全图，简称n阶完全图，记作Kn(n>=1).</li>
<li>设D是n阶有向简单图，若D中每个顶点都邻接到其余n-1个顶点，则称D是n阶有向完全图.</li>
<li>设D是n阶有向简单图，若D的基图是n阶无向完全图Kn，则称D是n阶竞赛图.</li>
<li>n阶无向完全图，n阶有向完全图，n阶竞赛图的边数分别为n(n-1)/2，n(n-1)，n(n-1)/2.</li></div><br><br> ",
            "assembleText":"设G是n阶无向简单图，若G中每个顶点均与其余n-1个顶点相邻，则称G为n阶无向完全图，简称n阶完全图，记作Kn(n>=1). 设D是n阶有向简单图，若D中每个顶点都邻接到其余n-1个顶点，则称D是n阶有向完全图. 设D是n阶有向简单图，若D的基图是n阶无向完全图Kn，则称D是n阶竞赛图. n阶无向完全图，n阶有向完全图，n阶竞赛图的边数分别为n(n-1)/2，n(n-1)，n(n-1)/2.",
            "assembleScratchTime":"2019-03-22 17:14:28",
            "facetId":557502,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863775,
            "assembleContent":"<ol start="7"><li>k-正则图<br>设G是n阶无向简单图，若G中任意一个顶点的度都为k，则称G为k-正则图.</li></ol> ",
            "assembleText":"k-正则图 设G是n阶无向简单图，若G中任意一个顶点的度都为k，则称G为k-正则图.",
            "assembleScratchTime":"2019-03-22 23:07:53",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863958,
            "assembleContent":"<h4>图的分类</h4><p>按照图边的方向，可以分为有向图和无向图。</p> ",
            "assembleText":"图的分类 按照图边的方向，可以分为有向图和无向图。",
            "assembleScratchTime":"2019-03-23 20:37:42",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863963,
            "assembleContent":"<h4>完全图</h4><h6><p>完全图也可以根据图边的方向进行划分，分为有向完全图和无向完全图。</p></h6> ",
            "assembleText":"完全图 完全图也可以根据图边的方向进行划分，分为有向完全图和无向完全图。",
            "assembleScratchTime":"2019-03-23 20:45:57",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863964,
            "assembleContent":"<h6>有向完全图</h6><h4><p>如果任意两个顶点之间都存在方向相反的两条弧，则称为有向完全图。</p><p>每个顶点都与其他 n - 1 个顶点有一条边，由于方向不重复，所以一共有 n * (n - 1)条边。</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/15399725-21b439b26b6c57de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/262/format/webp"></div></div><div>有向完全图</div></div></h4> ",
            "assembleText":"有向完全图 如果任意两个顶点之间都存在方向相反的两条弧，则称为有向完全图。 每个顶点都与其他 n - 1 个顶点有一条边，由于方向不重复，所以一共有 n * (n - 1)条边。 有向完全图",
            "assembleScratchTime":"2019-03-23 20:46:06",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863965,
            "assembleContent":"<h6>无向完全图</h6><h6><p>如果任意两个顶点之间都存在边，则称为无向完全图。</p><p>每个顶点都与其他 n - 1 个顶点有一条边，由于重复，所以一共有 n * (n - 1) / 2 条边。</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/15399725-ca3ec042e9e3f6bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/289/format/webp"></div></div><div>无向完全图</div></div></h6> ",
            "assembleText":"无向完全图 如果任意两个顶点之间都存在边，则称为无向完全图。 每个顶点都与其他 n - 1 个顶点有一条边，由于重复，所以一共有 n * (n - 1) / 2 条边。 无向完全图",
            "assembleScratchTime":"2019-03-23 20:46:13",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863966,
            "assembleContent":"<h4>子图</h4><h6><p>假设有两个图 G(V, E) 和 G'(V', E')，若 V' 是 V 的子集，E' 是 E 的子集，那么 G' 是 G 的子图。</p><p>若子图的顶点与 G的顶点相同，则称为 G 的生成子图。</p><br></h6> ",
            "assembleText":"子图 假设有两个图 G(V, E) 和 G'(V', E')，若 V' 是 V 的子集，E' 是 E 的子集，那么 G' 是 G 的子图。 若子图的顶点与 G的顶点相同，则称为 G 的生成子图。",
            "assembleScratchTime":"2019-03-23 20:46:20",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863967,
            "assembleContent":"<h4>连通</h4><h4><p>顶点 v 和 v' 之间有路径，则称为连通。</p><p>图中任意两个顶点都是连通的，则称为连通图。</p><p>顶点 v 到顶点 w都有路径，称为强连通，图中任意一对顶点都是强连通，则这个图称为强连通图。</p></h4> ",
            "assembleText":"连通 顶点 v 和 v' 之间有路径，则称为连通。 图中任意两个顶点都是连通的，则称为连通图。 顶点 v 到顶点 w都有路径，称为强连通，图中任意一对顶点都是强连通，则这个图称为强连通图。",
            "assembleScratchTime":"2019-03-23 20:46:33",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863971,
            "assembleContent":"<h2>有向图和无向图</h2><h2><div>
<p>如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图有 n(n-1)/2 条边。</p>
<p>同样地，如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有 n 个顶点的有向完全图有 n(n-1) 条边。</p></div><br><br></h2> ",
            "assembleText":"有向图和无向图 如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图有 n(n-1)/2 条边。 同样地，如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有 n 个顶点的有向完全图有 n(n-1) 条边。",
            "assembleScratchTime":"2019-03-23 20:48:26",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863973,
            "assembleContent":"<h2>简单图</h2><h2><p>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们要研究的图都是简单图。如下所示，都不是简单图，不属于我们学习的范畴。</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-7e75aebc4e2d0fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp"></div></div><div>非简单图示例</div></div></h2> ",
            "assembleText":"简单图 在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们要研究的图都是简单图。如下所示，都不是简单图，不属于我们学习的范畴。 非简单图示例",
            "assembleScratchTime":"2019-03-23 20:49:08",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863974,
            "assembleContent":"<h2>稀疏图和稠密图</h2><h2><p>有很少条边或弧的图称为稀疏图，反之称为稠密图。这是一个相对的概念。</p></h2> ",
            "assembleText":"稀疏图和稠密图 有很少条边或弧的图称为稀疏图，反之称为稠密图。这是一个相对的概念。",
            "assembleScratchTime":"2019-03-23 20:49:26",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863975,
            "assembleContent":"<h2>网</h2><h2><p>带权的图称为网，权指的是在图的边或弧上的数字，例如下图就是一张带权的图：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-53e307dac6e28204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/228/format/webp"></div></div><div>网</div></div></h2> ",
            "assembleText":"网 带权的图称为网，权指的是在图的边或弧上的数字，例如下图就是一张带权的图： 网",
            "assembleScratchTime":"2019-03-23 20:49:37",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864112,
            "assembleContent":"<div>有向无环图，称为DAG图。  <span style="font-family: "Source Sans Pro", sans-serif; font-size: 12px;"><br></span></div> ",
            "assembleText":"有向无环图，称为DAG图。  ",
            "assembleScratchTime":"2019-03-23 21:38:44",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864139,
            "assembleContent":"<h4><p><strong>简单图</strong></p><ul><li>(1) 不存在重复边</li><li>(2) 不存在顶点到自身的边</li></ul></h4> ",
            "assembleText":"简单图 (1) 不存在重复边 (2) 不存在顶点到自身的边",
            "assembleScratchTime":"2019-03-23 21:43:03",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864141,
            "assembleContent":"<h4><p><strong>多重图</strong> ： 与<strong>简单图</strong>相对  <br></p></h4> ",
            "assembleText":"多重图 ： 与简单图相对  ",
            "assembleScratchTime":"2019-03-23 21:43:14",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864144,
            "assembleContent":"<h4><p><strong>子图</strong><br>有 G = (V , E) , G' = (V' ，E')<br>若 V'⊆V，E‘⊆E，则 G' 是 G 的子图<br>若 有V(G') = V(G) 的子图 G' ,则为G的生成子图  <br></p></h4> ",
            "assembleText":"子图 有 G = (V , E) , G' = (V' ，E') 若 V'⊆V，E‘⊆E，则 G' 是 G 的子图 若 有V(G') = V(G) 的子图 G' ,则为G的生成子图  ",
            "assembleScratchTime":"2019-03-23 21:43:52",
            "facetId":557502,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864656,
            "assembleContent":"<p></p><h4>欧拉图</h4><h3 id="算法思路寻找图中所有的哈密顿路"><p>先定义一下欧拉路径(有称欧拉链)和欧拉闭路（有称欧拉圈）：</p><pre><code>1. 欧拉路径，包含图G中所有边的简单开路径。通俗的说,把所有的边遍历且仅遍历一次的通路，不会回到出发点。
2. 欧拉闭路，包含所有边的简单闭路径(简单回路)。同上含所有边、不经过重复边、但回到出发点</code></pre></h3> ",
            "assembleText":"欧拉图 先定义一下欧拉路径(有称欧拉链)和欧拉闭路（有称欧拉圈）： 1. 欧拉路径，包含图G中所有边的简单开路径。通俗的说,把所有的边遍历且仅遍历一次的通路，不会回到出发点。
2. 欧拉闭路，包含所有边的简单闭路径(简单回路)。同上含所有边、不经过重复边、但回到出发点",
            "assembleScratchTime":"2019-03-24 16:14:37",
            "facetId":557502,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/fireflylane/article/details/84473276",
            "type":"text"
        },
        {
            "assembleId":2864657,
            "assembleContent":"<p></p><h4><ul><li>规定平凡图是欧拉图</li><li>含有欧拉路径的图叫做半欧拉图</li></ul></h4> ",
            "assembleText":"规定平凡图是欧拉图 含有欧拉路径的图叫做半欧拉图",
            "assembleScratchTime":"2019-03-24 16:15:07",
            "facetId":557502,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/40bbe3939699",
            "type":"text"
        },
        {
            "assembleId":2865772,
            "assembleContent":"<h5>4.1.7 符号图</h5><h3><div><div>
<p>实际应用中通常图都是通过文件,网页定义的,使用的是字符串而非数字代替顶点,为了适应这样的应用我们必须定义拥有如下输入格式:</p>
<p>1 .顶点为字符串.<br>
2.用指定的分隔符来隔开顶点<br>
3.每一行都表示一条边的集合,每一条边都连着这一行的第一个名称表示的顶点和其他名称所表示的顶点<br>
4.顶点树V和边数E是隐式定义的</p>
</div><br><br>作者：浩林Leon<br>链接：https://www.jianshu.com/p/817a5a2cedf3<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h3> ",
            "assembleText":"4.1.7 符号图 实际应用中通常图都是通过文件,网页定义的,使用的是字符串而非数字代替顶点,为了适应这样的应用我们必须定义拥有如下输入格式: 1 .顶点为字符串. 2.用指定的分隔符来隔开顶点 3.每一行都表示一条边的集合,每一条边都连着这一行的第一个名称表示的顶点和其他名称所表示的顶点 4.顶点树V和边数E是隐式定义的 作者：浩林Leon 链接：https://www.jianshu.com/p/817a5a2cedf3 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-24 22:37:43",
            "facetId":557502,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/817a5a2cedf3",
            "type":"text"
        },
        {
            "assembleId":2856982,
            "assembleContent":"<p>在图中实现最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点，比如从武汉出发的高铁可以到达哪些城市，一些城市可以直达，一些城市不能直达。现在有一份全国高铁模拟图，要从某个城市（顶点）开始，沿着铁轨（边）移动到其他城市（顶点），有两种方法可以用来搜索图：深度优先搜索（DFS）和广度优先搜索（BFS）。它们最终都会到达所有连通的顶点，深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现，不同的实现机制导致不同的搜索方式。  <br></p> ",
            "assembleText":"在图中实现最基本的操作之一就是搜索从一个指定顶点可以到达哪些顶点，比如从武汉出发的高铁可以到达哪些城市，一些城市可以直达，一些城市不能直达。现在有一份全国高铁模拟图，要从某个城市（顶点）开始，沿着铁轨（边）移动到其他城市（顶点），有两种方法可以用来搜索图：深度优先搜索（DFS）和广度优先搜索（BFS）。它们最终都会到达所有连通的顶点，深度优先搜索通过栈来实现，而广度优先搜索通过队列来实现，不同的实现机制导致不同的搜索方式。  ",
            "assembleScratchTime":"2019-03-03 19:37:33",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856983,
            "assembleContent":"<h4>①、深度优先搜索（DFS）</h4><p>    深度优先搜索算法有如下规则：</p><p>　　规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。</p><p>　　规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。</p><p>　　规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。</p><p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209225344107-1667286888.png" alt=""></p><p>　　对于上图，应用深度优先搜索如下：假设选取 A 顶点为起始点，并且按照字母优先顺序进行访问，那么应用规则 1 ，接下来访问顶点 B，然后标记它，并将它放入栈中；再次应用规则 1，接下来访问顶点 F，再次应用规则 1，访问顶点 H。我们这时候发现，没有 H 顶点的邻接点了，这时候应用规则 2，从栈中弹出 H，这时候回到了顶点 F，但是我们发现 F 也除了 H 也没有与之邻接且未访问的顶点了，那么再弹出 F，这时候回到顶点 B，同理规则 1 应用不了，应用规则 2，弹出 B，这时候栈中只有顶点 A了，然后 A 还有未访问的邻接点，所有接下来访问顶点 C，但是 C又是这条线的终点，所以从栈中弹出它，再次回到 A，接着访问 D,G,I，最后也回到了 A，然后访问 E，但是最后又回到了顶点 A，这时候我们发现 A没有未访问的邻接点了，所以也把它弹出栈。现在栈中已无顶点，于是应用规则 3，完成了整个搜索过程。</p><p>　　深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。这里以邻接矩阵为例，找到顶点所在的行，从第一列开始向后寻找值为1的列；列号是邻接顶点的号码，检查这个顶点是否未访问过，如果是这样，那么这就是要访问的下一个顶点，如果该行没有顶点既等于1（邻接）且又是未访问的，那么与指定点相邻接的顶点就全部访问过了（后面会用算法实现）。</p> ",
            "assembleText":"①、深度优先搜索（DFS） 　　深度优先搜索算法有如下规则： 　　规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。 　　规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。 　　规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。 　　 　　对于上图，应用深度优先搜索如下：假设选取 A 顶点为起始点，并且按照字母优先顺序进行访问，那么应用规则 1 ，接下来访问顶点 B，然后标记它，并将它放入栈中；再次应用规则 1，接下来访问顶点 F，再次应用规则 1，访问顶点 H。我们这时候发现，没有 H 顶点的邻接点了，这时候应用规则 2，从栈中弹出 H，这时候回到了顶点 F，但是我们发现 F 也除了 H 也没有与之邻接且未访问的顶点了，那么再弹出 F，这时候回到顶点 B，同理规则 1 应用不了，应用规则 2，弹出 B，这时候栈中只有顶点 A了，然后 A 还有未访问的邻接点，所有接下来访问顶点 C，但是 C又是这条线的终点，所以从栈中弹出它，再次回到 A，接着访问 D,G,I，最后也回到了 A，然后访问 E，但是最后又回到了顶点 A，这时候我们发现 A没有未访问的邻接点了，所以也把它弹出栈。现在栈中已无顶点，于是应用规则 3，完成了整个搜索过程。 　　深度优先搜索在于能够找到与某一顶点邻接且没有访问过的顶点。这里以邻接矩阵为例，找到顶点所在的行，从第一列开始向后寻找值为1的列；列号是邻接顶点的号码，检查这个顶点是否未访问过，如果是这样，那么这就是要访问的下一个顶点，如果该行没有顶点既等于1（邻接）且又是未访问的，那么与指定点相邻接的顶点就全部访问过了（后面会用算法实现）。",
            "assembleScratchTime":"2019-03-03 19:37:58",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856984,
            "assembleContent":"<h4>②、广度优先搜索（BFS）</h4><h4><p>　　深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。</p><p>　　规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。</p><p>　　规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。</p><p>　　规则3：如果因为队列为空而不能执行规则 2，则搜索结束。</p><p>　　对于上面的图，应用广度优先搜索：以A为起始点，首先访问所有与 A 相邻的顶点，并在访问的同时将其插入队列中，现在已经访问了 A,B,C,D和E。这时队列（从头到尾）包含 BCDE，已经没有未访问的且与顶点 A 邻接的顶点了，所以从队列中取出B，寻找与B邻接的顶点，这时找到F，所以把F插入到队列中。已经没有未访问且与B邻接的顶点了，所以从队列列头取出C，它没有未访问的邻接点。因此取出 D 并访问 G，D也没有未访问的邻接点了，所以取出E，现在队列中有 FG，在取出 F，访问 H，然后取出 G，访问 I，现在队列中有 HI，当取出他们时，发现没有其它为访问的顶点了，这时队列为空，搜索结束。</p></h4> ",
            "assembleText":"②、广度优先搜索（BFS） 　　深度优先搜索要尽可能的远离起始点，而广度优先搜索则要尽可能的靠近起始点，它首先访问起始顶点的所有邻接点，然后再访问较远的区域，这种搜索不能用栈实现，而是用队列实现。 　　规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中。 　　规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点。 　　规则3：如果因为队列为空而不能执行规则 2，则搜索结束。 　　对于上面的图，应用广度优先搜索：以A为起始点，首先访问所有与 A 相邻的顶点，并在访问的同时将其插入队列中，现在已经访问了 A,B,C,D和E。这时队列（从头到尾）包含 BCDE，已经没有未访问的且与顶点 A 邻接的顶点了，所以从队列中取出B，寻找与B邻接的顶点，这时找到F，所以把F插入到队列中。已经没有未访问且与B邻接的顶点了，所以从队列列头取出C，它没有未访问的邻接点。因此取出 D 并访问 G，D也没有未访问的邻接点了，所以取出E，现在队列中有 FG，在取出 F，访问 H，然后取出 G，访问 I，现在队列中有 HI，当取出他们时，发现没有其它为访问的顶点了，这时队列为空，搜索结束。",
            "assembleScratchTime":"2019-03-03 19:38:14",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856985,
            "assembleContent":"<h4><pre><code>package com.ys.graph;<br> <br>public class StackX {<br>    private final int SIZE = 20;<br>    private int[] st;<br>    private int top;<br>     <br>    public StackX(){<br>        st = new int[SIZE];<br>        top = -1;<br>    }<br>     <br>    public void push(int j){<br>        st[++top] = j;<br>    }<br>     <br>    public int pop(){<br>        return st[top--];<br>    }<br>     <br>    public int peek(){<br>        return st[top];<br>    }<br>     <br>    public boolean isEmpty(){<br>        return (top == -1);<br>    }<br> <br>}</code></pre><p><br></p></h4> ",
            "assembleText":"package com.ys.graph;  public class StackX {     private final int SIZE = 20;     private int[] st;     private int top;          public StackX(){         st = new int[SIZE];         top = -1;     }          public void push(int j){         st[++top] = j;     }          public int pop(){         return st[top--];     }          public int peek(){         return st[top];     }          public boolean isEmpty(){         return (top == -1);     }  }",
            "assembleScratchTime":"2019-03-03 19:38:55",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856986,
            "assembleContent":"<h4><pre><code><p>package com.ys.graph;<br> <br>public class Queue {<br>    private final int SIZE = 20;<br>    private int[] queArray;<br>    private int front;<br>    private int rear;<br>     <br>    public Queue(){<br>        queArray = new int[SIZE];<br>        front = 0;<br>        rear = -1;<br>    }<br>     <br>    public void insert(int j) {<br>        if(rear == SIZE-1) {<br>            rear = -1;<br>        }<br>        queArray[++rear] = j;<br>    }<br>     <br>    public int remove() {<br>        int temp = queArray[front++];<br>        if(front == SIZE) {<br>            front = 0;<br>        }<br>        return temp;<br>    }<br>     <br>    public boolean isEmpty() {<br>        return (rear+1 == front || front+SIZE-1 == rear);<br>    }<br>}</p></code></pre></h4> ",
            "assembleText":"package com.ys.graph; public class Queue { private final int SIZE = 20; private int[] queArray; private int front; private int rear; public Queue(){ queArray = new int[SIZE]; front = 0; rear = -1; } public void insert(int j) { if(rear == SIZE-1) { rear = -1; } queArray[++rear] = j; } public int remove() { int temp = queArray[front++]; if(front == SIZE) { front = 0; } return temp; } public boolean isEmpty() { return (rear+1 == front || front+SIZE-1 == rear); } }",
            "assembleScratchTime":"2019-03-03 19:39:10",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856987,
            "assembleContent":"<h4><pre><code><p>

</p><div><code>package</code> <code>com.ys.graph;</code></div><div> </div><div><code>public</code> <code>class</code> <code>Graph {</code></div><div><code>    </code><code>private</code> <code>final</code> <code>int</code> <code>MAX_VERTS = </code><code>20</code><code>;</code><code>//表示顶点的个数</code></div><div><code>    </code><code>private</code> <code>Vertex vertexList[];</code><code>//用来存储顶点的数组</code></div><div><code>    </code><code>private</code> <code>int</code> <code>adjMat[][];</code><code>//用邻接矩阵来存储 边,数组元素0表示没有边界，1表示有边界</code></div><div><code>    </code><code>private</code> <code>int</code> <code>nVerts;</code><code>//顶点个数</code></div><div><code>    </code><code>private</code> <code>StackX theStack;</code><code>//用栈实现深度优先搜索</code></div><div><code>    </code><code>private</code> <code>Queue queue;</code><code>//用队列实现广度优先搜索</code></div><div><code>    </code><code>/**</code></div><div><code>     </code><code>* 顶点类</code></div><div><code>     </code><code>* @author vae</code></div><div><code>     </code><code>*/</code></div><div><code>    </code><code>class</code> <code>Vertex {</code></div><div><code>        </code><code>public</code> <code>char</code> <code>label;</code></div><div><code>        </code><code>public</code> <code>boolean</code> <code>wasVisited;</code></div><div><code>        </code> </div><div><code>        </code><code>public</code> <code>Vertex(</code><code>char</code> <code>label){</code></div><div><code>            </code><code>this</code><code>.label = label;</code></div><div><code>            </code><code>wasVisited = </code><code>false</code><code>;</code></div><div><code>        </code><code>}</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>public</code> <code>Graph(){</code></div><div><code>        </code><code>vertexList = </code><code>new</code> <code>Vertex[MAX_VERTS];</code></div><div><code>        </code><code>adjMat = </code><code>new</code> <code>int</code><code>[MAX_VERTS][MAX_VERTS];</code></div><div><code>        </code><code>nVerts = </code><code>0</code><code>;</code><code>//初始化顶点个数为0</code></div><div><code>        </code><code>//初始化邻接矩阵所有元素都为0，即所有顶点都没有边</code></div><div><code>        </code><code>for</code><code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i < MAX_VERTS; i++) {</code></div><div><code>            </code><code>for</code><code>(</code><code>int</code> <code>j = </code><code>0</code><code>; j < MAX_VERTS; j++) {</code></div><div><code>                </code><code>adjMat[i][j] = </code><code>0</code><code>;</code></div><div><code>            </code><code>}</code></div><div><code>        </code><code>}</code></div><div><code>        </code><code>theStack = </code><code>new</code> <code>StackX();</code></div><div><code>        </code><code>queue = </code><code>new</code> <code>Queue();</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>//将顶点添加到数组中，是否访问标志置为wasVisited=false(未访问)</code></div><div><code>    </code><code>public</code> <code>void</code> <code>addVertex(</code><code>char</code> <code>lab) {</code></div><div><code>        </code><code>vertexList[nVerts++] = </code><code>new</code> <code>Vertex(lab);</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>//注意用邻接矩阵表示边，是对称的，两部分都要赋值</code></div><div><code>    </code><code>public</code> <code>void</code> <code>addEdge(</code><code>int</code> <code>start, </code><code>int</code> <code>end) {</code></div><div><code>        </code><code>adjMat[start][end] = </code><code>1</code><code>;</code></div><div><code>        </code><code>adjMat[end][start] = </code><code>1</code><code>;</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>//打印某个顶点表示的值</code></div><div><code>    </code><code>public</code> <code>void</code> <code>displayVertex(</code><code>int</code> <code>v) {</code></div><div><code>        </code><code>System.out.print(vertexList[v].label);</code></div><div><code>    </code><code>}</code></div><div><code>    </code><code>/**深度优先搜索算法:</code></div><div><code>     </code><code>* 1、用peek()方法检查栈顶的顶点</code></div><div><code>     </code><code>* 2、用getAdjUnvisitedVertex()方法找到当前栈顶点邻接且未被访问的顶点</code></div><div><code>     </code><code>* 3、第二步方法返回值不等于-1则找到下一个未访问的邻接顶点，访问这个顶点，并入栈</code></div><div><code>     </code><code>*    如果第二步方法返回值等于 -1，则没有找到，出栈</code></div><div><code>     </code><code>*/</code></div><div><code>    </code><code>public</code> <code>void</code> <code>depthFirstSearch() {</code></div><div><code>        </code><code>//从第一个顶点开始访问</code></div><div><code>        </code><code>vertexList[</code><code>0</code><code>].wasVisited = </code><code>true</code><code>; </code><code>//访问之后标记为true</code></div><div><code>        </code><code>displayVertex(</code><code>0</code><code>);</code><code>//打印访问的第一个顶点</code></div><div><code>        </code><code>theStack.push(</code><code>0</code><code>);</code><code>//将第一个顶点放入栈中</code></div><div><code>        </code> </div><div><code>        </code><code>while</code><code>(!theStack.isEmpty()) {</code></div><div><code>            </code><code>//找到栈当前顶点邻接且未被访问的顶点</code></div><div><code>            </code><code>int</code> <code>v = getAdjUnvisitedVertex(theStack.peek());</code></div><div><code>            </code><code>if</code><code>(v == -</code><code>1</code><code>) {   </code><code>//如果当前顶点值为-1，则表示没有邻接且未被访问顶点，那么出栈顶点</code></div><div><code>                </code><code>theStack.pop();</code></div><div><code>            </code><code>}</code><code>else</code> <code>{ </code><code>//否则访问下一个邻接顶点</code></div><div><code>                </code><code>vertexList[v].wasVisited = </code><code>true</code><code>;</code></div><div><code>                </code><code>displayVertex(v);</code></div><div><code>                </code><code>theStack.push(v);</code></div><div><code>            </code><code>}</code></div><div><code>        </code><code>}</code></div><div><code>        </code> </div><div><code>        </code><code>//栈访问完毕，重置所有标记位wasVisited=false</code></div><div><code>        </code><code>for</code><code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i < nVerts; i++) {</code></div><div><code>            </code><code>vertexList[i].wasVisited = </code><code>false</code><code>;</code></div><div><code>        </code><code>}</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>//找到与某一顶点邻接且未被访问的顶点</code></div><div><code>    </code><code>public</code> <code>int</code> <code>getAdjUnvisitedVertex(</code><code>int</code> <code>v) {</code></div><div><code>        </code><code>for</code><code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i < nVerts; i++) {</code></div><div><code>            </code><code>//v顶点与i顶点相邻（邻接矩阵值为1）且未被访问 wasVisited==false</code></div><div><code>            </code><code>if</code><code>(adjMat[v][i] == </code><code>1</code> <code>&& vertexList[i].wasVisited == </code><code>false</code><code>) {</code></div><div><code>                </code><code>return</code> <code>i;</code></div><div><code>            </code><code>}</code></div><div><code>        </code><code>}</code></div><div><code>        </code><code>return</code> <code>-</code><code>1</code><code>;</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>/**</code></div><div><code>     </code><code>* 广度优先搜索算法：</code></div><div><code>     </code><code>* 1、用remove()方法检查栈顶的顶点</code></div><div><code>     </code><code>* 2、试图找到这个顶点还未访问的邻节点</code></div><div><code>     </code><code>* 3、 如果没有找到，该顶点出列</code></div><div><code>     </code><code>* 4、 如果找到这样的顶点，访问这个顶点，并把它放入队列中</code></div><div><code>     </code><code>*/</code></div><div><code>    </code><code>public</code> <code>void</code> <code>breadthFirstSearch(){</code></div><div><code>        </code><code>vertexList[</code><code>0</code><code>].wasVisited = </code><code>true</code><code>;</code></div><div><code>        </code><code>displayVertex(</code><code>0</code><code>);</code></div><div><code>        </code><code>queue.insert(</code><code>0</code><code>);</code></div><div><code>        </code><code>int</code> <code>v2;</code></div><div><code>        </code> </div><div><code>        </code><code>while</code><code>(!queue.isEmpty()) {</code></div><div><code>            </code><code>int</code> <code>v1 = queue.remove();</code></div><div><code>            </code><code>while</code><code>((v2 = getAdjUnvisitedVertex(v1)) != -</code><code>1</code><code>) {</code></div><div><code>                </code><code>vertexList[v2].wasVisited = </code><code>true</code><code>;</code></div><div><code>                </code><code>displayVertex(v2);</code></div><div><code>                </code><code>queue.insert(v2);</code></div><div><code>            </code><code>}</code></div><div><code>        </code><code>}</code></div><div><code>        </code> </div><div><code>        </code><code>//搜索完毕，初始化，以便于下次搜索</code></div><div><code>        </code><code>for</code><code>(</code><code>int</code> <code>i = </code><code>0</code><code>; i < nVerts; i++) {</code></div><div><code>            </code><code>vertexList[i].wasVisited = </code><code>false</code><code>;</code></div><div><code>        </code><code>}</code></div><div><code>    </code><code>}</code></div><div><code>    </code> </div><div><code>    </code><code>public</code> <code>static</code> <code>void</code> <code>main(String[] args) {</code></div><div><code>        </code><code>Graph graph = </code><code>new</code> <code>Graph();</code></div><div><code>        </code><code>graph.addVertex(</code><code>'A'</code><code>);</code></div><div><code>        </code><code>graph.addVertex(</code><code>'B'</code><code>);</code></div><div><code>        </code><code>graph.addVertex(</code><code>'C'</code><code>);</code></div><div><code>        </code><code>graph.addVertex(</code><code>'D'</code><code>);</code></div><div><code>        </code><code>graph.addVertex(</code><code>'E'</code><code>);</code></div><div><code>        </code> </div><div><code>        </code><code>graph.addEdge(</code><code>0</code><code>, </code><code>1</code><code>);</code><code>//AB</code></div><div><code>        </code><code>graph.addEdge(</code><code>1</code><code>, </code><code>2</code><code>);</code><code>//BC</code></div><div><code>        </code><code>graph.addEdge(</code><code>0</code><code>, </code><code>3</code><code>);</code><code>//AD</code></div><div><code>        </code><code>graph.addEdge(</code><code>3</code><code>, </code><code>4</code><code>);</code><code>//DE</code></div><div><code>        </code> </div><div><code>        </code><code>System.out.println(</code><code>"深度优先搜索算法 :"</code><code>);</code></div><div><code>        </code><code>graph.depthFirstSearch();</code><code>//ABCDE</code></div><div><code>        </code> </div><div><code>        </code><code>System.out.println();</code></div><div><code>        </code><code>System.out.println(</code><code>"----------------------"</code><code>);</code></div><div><code>        </code> </div><div><code>        </code><code>System.out.println(</code><code>"广度优先搜索算法 :"</code><code>);</code></div><div><code>        </code><code>graph.breadthFirstSearch();</code><code>//ABDCE</code></div><div><code>    </code><code>}</code></div><div><code>}</code></div><p>

</p></code></pre></h4> ",
            "assembleText":"package com.ys.graph;   public class Graph {     private final int MAX_VERTS = 20;//表示顶点的个数     private Vertex vertexList[];//用来存储顶点的数组     private int adjMat[][];//用邻接矩阵来存储 边,数组元素0表示没有边界，1表示有边界     private int nVerts;//顶点个数     private StackX theStack;//用栈实现深度优先搜索     private Queue queue;//用队列实现广度优先搜索     /**      * 顶点类      * @author vae      */     class Vertex {         public char label;         public boolean wasVisited;                   public Vertex(char label){             this.label = label;             wasVisited = false;         }     }           public Graph(){         vertexList = new Vertex[MAX_VERTS];         adjMat = new int[MAX_VERTS][MAX_VERTS];         nVerts = 0;//初始化顶点个数为0         //初始化邻接矩阵所有元素都为0，即所有顶点都没有边         for(int i = 0; i < MAX_VERTS; i++) {             for(int j = 0; j < MAX_VERTS; j++) {                 adjMat[i][j] = 0;             }         }         theStack = new StackX();         queue = new Queue();     }           //将顶点添加到数组中，是否访问标志置为wasVisited=false(未访问)     public void addVertex(char lab) {         vertexList[nVerts++] = new Vertex(lab);     }           //注意用邻接矩阵表示边，是对称的，两部分都要赋值     public void addEdge(int start, int end) {         adjMat[start][end] = 1;         adjMat[end][start] = 1;     }           //打印某个顶点表示的值     public void displayVertex(int v) {         System.out.print(vertexList[v].label);     }     /**深度优先搜索算法:      * 1、用peek()方法检查栈顶的顶点      * 2、用getAdjUnvisitedVertex()方法找到当前栈顶点邻接且未被访问的顶点      * 3、第二步方法返回值不等于-1则找到下一个未访问的邻接顶点，访问这个顶点，并入栈      *    如果第二步方法返回值等于 -1，则没有找到，出栈      */     public void depthFirstSearch() {         //从第一个顶点开始访问         vertexList[0].wasVisited = true; //访问之后标记为true         displayVertex(0);//打印访问的第一个顶点         theStack.push(0);//将第一个顶点放入栈中                   while(!theStack.isEmpty()) {             //找到栈当前顶点邻接且未被访问的顶点             int v = getAdjUnvisitedVertex(theStack.peek());             if(v == -1) {   //如果当前顶点值为-1，则表示没有邻接且未被访问顶点，那么出栈顶点                 theStack.pop();             }else { //否则访问下一个邻接顶点                 vertexList[v].wasVisited = true;                 displayVertex(v);                 theStack.push(v);             }         }                   //栈访问完毕，重置所有标记位wasVisited=false         for(int i = 0; i < nVerts; i++) {             vertexList[i].wasVisited = false;         }     }           //找到与某一顶点邻接且未被访问的顶点     public int getAdjUnvisitedVertex(int v) {         for(int i = 0; i < nVerts; i++) {             //v顶点与i顶点相邻（邻接矩阵值为1）且未被访问 wasVisited==false             if(adjMat[v][i] == 1 && vertexList[i].wasVisited == false) {                 return i;             }         }         return -1;     }           /**      * 广度优先搜索算法：      * 1、用remove()方法检查栈顶的顶点      * 2、试图找到这个顶点还未访问的邻节点      * 3、 如果没有找到，该顶点出列      * 4、 如果找到这样的顶点，访问这个顶点，并把它放入队列中      */     public void breadthFirstSearch(){         vertexList[0].wasVisited = true;         displayVertex(0);         queue.insert(0);         int v2;                   while(!queue.isEmpty()) {             int v1 = queue.remove();             while((v2 = getAdjUnvisitedVertex(v1)) != -1) {                 vertexList[v2].wasVisited = true;                 displayVertex(v2);                 queue.insert(v2);             }         }                   //搜索完毕，初始化，以便于下次搜索         for(int i = 0; i < nVerts; i++) {             vertexList[i].wasVisited = false;         }     }           public static void main(String[] args) {         Graph graph = new Graph();         graph.addVertex('A');         graph.addVertex('B');         graph.addVertex('C');         graph.addVertex('D');         graph.addVertex('E');                   graph.addEdge(0, 1);//AB         graph.addEdge(1, 2);//BC         graph.addEdge(0, 3);//AD         graph.addEdge(3, 4);//DE                   System.out.println("深度优先搜索算法 :");         graph.depthFirstSearch();//ABCDE                   System.out.println();         System.out.println("----------------------");                   System.out.println("广度优先搜索算法 :");         graph.breadthFirstSearch();//ABDCE     } }",
            "assembleScratchTime":"2019-03-03 19:39:34",
            "facetId":557520,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2863368,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>深度优先搜索遍历</p><p>深度优先搜索(DFS)遍历类似于树的前序遍历。其基本思路是：</p><p>①假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点V为初始出发点，首先访问出发点V，并将其标记为已访问过。</p><p>②然后依次从V出发搜索V的每个邻接点W，若W未曾访问过，则以W作为新的出发点出发，继续进行深度优先遍历，直到图中所有和V有路径相通的顶点都被访问到。</p><p>③若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。</p></h3> ",
            "assembleText":"深度优先搜索遍历 深度优先搜索(DFS)遍历类似于树的前序遍历。其基本思路是： ①假设初始状态是图中所有顶点都未曾访问过，则可从图G中任意一顶点V为初始出发点，首先访问出发点V，并将其标记为已访问过。 ②然后依次从V出发搜索V的每个邻接点W，若W未曾访问过，则以W作为新的出发点出发，继续进行深度优先遍历，直到图中所有和V有路径相通的顶点都被访问到。 ③若此时图中仍有顶点未被访问，则另选一个未曾访问的顶点作为起点，重复上述步骤，直到图中所有顶点都被访问到为止。",
            "assembleScratchTime":"2019-03-20 22:57:19",
            "facetId":557520,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863369,
            "assembleContent":"<h3 id="autoid-2-2-0"><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516733289957.jpg">  <br></p></h3> ",
            "assembleText":"  ",
            "assembleScratchTime":"2019-03-20 22:57:39",
            "facetId":557520,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863370,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>广度优先搜索遍历</p><p>广度优先搜索遍历(BFS)类似于树的按层次遍历。其基本思路是：</p><p>①首先访问出发点V<sub>i</sub></p><p>②接着依次访问V<sub>i</sub>的所有未被访问过的邻接点V<sub>i1</sub>，V<sub>i2</sub>，V<sub>i3</sub>，…，V<sub>it</sub>并均标记为已访问过。</p><p>③然后再按照V<sub>i1</sub>，V<sub>i2</sub>，… ，V<sub>it</sub>的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点V<sub>i</sub>有路径相通的顶点都被访问过为止。</p></h3> ",
            "assembleText":"广度优先搜索遍历 广度优先搜索遍历(BFS)类似于树的按层次遍历。其基本思路是： ①首先访问出发点Vi ②接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，Vi3，…，Vit并均标记为已访问过。 ③然后再按照Vi1，Vi2，… ，Vit的次序，访问每一个顶点的所有未曾访问过的顶点并均标记为已访问过，依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。",
            "assembleScratchTime":"2019-03-20 22:57:53",
            "facetId":557520,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863371,
            "assembleContent":"<h3 id="autoid-2-2-0"><p><br></p><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516734019011.jpg"></p><p>因此，图(f)采用广度优先搜索遍历以V<sub>0</sub>为出发点的顶点序列为：V<sub>0</sub>，V<sub>1</sub>，V<sub>3</sub>，V<sub>4</sub>，V<sub>2</sub>，V<sub>6</sub>，V<sub>8</sub>，V<sub>5</sub>，V<sub>7</sub></p><p>如果采用邻接矩阵存储，则时间复杂度为O(n<sup>2</sup>)，如果采用邻接表存储，则时间复杂度为O(n+e)</p></h3> ",
            "assembleText":"因此，图(f)采用广度优先搜索遍历以V0为出发点的顶点序列为：V0，V1，V3，V4，V2，V6，V8，V5，V7 如果采用邻接矩阵存储，则时间复杂度为O(n2)，如果采用邻接表存储，则时间复杂度为O(n+e)",
            "assembleScratchTime":"2019-03-20 22:58:07",
            "facetId":557520,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2864091,
            "assembleContent":"<ul><li>图的遍历：从图中某一个顶点出发遍历途中其余顶点，每一个顶点仅被访问一次。  <br></li></ul> ",
            "assembleText":"图的遍历：从图中某一个顶点出发遍历途中其余顶点，每一个顶点仅被访问一次。  ",
            "assembleScratchTime":"2019-03-23 21:33:25",
            "facetId":557520,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864092,
            "assembleContent":"<div><p>基本思路：<br>
（1）树有四种遍历方式，因为根节点只有一个。而图的复杂情况是的顺着一个点向下寻找，极有可能最后又找到自己，形成回路导致死循环。<br>
（2）所以要设置一个数组voisited[n]，n是图中顶点个数，初值为0，当该顶点被遍历后，修改数组元素的值为1<br>
（3）基于此，形成了2中遍历方案：</p>
<h4>深度优先遍历&广度优先遍历</h4></div><br> ",
            "assembleText":"基本思路： （1）树有四种遍历方式，因为根节点只有一个。而图的复杂情况是的顺着一个点向下寻找，极有可能最后又找到自己，形成回路导致死循环。 （2）所以要设置一个数组voisited[n]，n是图中顶点个数，初值为0，当该顶点被遍历后，修改数组元素的值为1 （3）基于此，形成了2中遍历方案： 深度优先遍历&广度优先遍历",
            "assembleScratchTime":"2019-03-23 21:33:50",
            "facetId":557520,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2861753,
            "assembleContent":"<h4>In <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, graphs are used to represent networks of communication, data organization, computational devices, the flow of computation, etc. For instance, the link structure of a <a href="https://en.wikipedia.org/wiki/Website" title="Website">website</a> can be represented by a directed graph, in which the vertices represent web pages and directed edges represent <a href="https://en.wikipedia.org/wiki/Hyperlink" title="Hyperlink">links</a> from one page to another. A similar approach can be taken to problems in social media,<sup id="cite_ref-5"><a href="https://en.wikipedia.org/wiki/Graph_theory#cite_note-5">[5]</a></sup> travel, biology, computer chip design, mapping the progression of neuro-degenerative diseases,<sup id="cite_ref-6"><a href="https://en.wikipedia.org/wiki/Graph_theory#cite_note-6">[6]</a></sup><sup id="cite_ref-7"><a href="https://en.wikipedia.org/wiki/Graph_theory#cite_note-7">[7]</a></sup> and many other fields. The development of <a href="https://en.wikipedia.org/wiki/Algorithm" title="Algorithm">algorithms</a> to handle graphs is therefore of major interest in computer science. The <a href="https://en.wikipedia.org/wiki/Graph_transformation" title="Graph transformation">transformation of graphs</a> is often formalized and represented by <a href="https://en.wikipedia.org/wiki/Graph_rewriting" title="Graph rewriting">graph rewrite systems</a>. Complementary to <a href="https://en.wikipedia.org/wiki/Graph_transformation" title="Graph transformation">graph transformation</a>systems focusing on rule-based in-memory manipulation of graphs are <a href="https://en.wikipedia.org/wiki/Graph_database" title="Graph database">graph databases</a> geared towards <a href="https://en.wikipedia.org/wiki/Database_transaction" title="Database transaction">transaction</a>-safe, <a href="https://en.wikipedia.org/wiki/Persistence_(computer_science)" title="Persistence (computer science)">persistent</a> storing and querying of <a href="https://en.wikipedia.org/wiki/Graph_(data_structure)" title="Graph (data structure)">graph-structured data</a>.  <br></h4>  ",
            "assembleText":"In computer science, graphs are used to represent networks of communication, data organization, computational devices, the flow of computation, etc. For instance, the link structure of a website can be represented by a directed graph, in which the vertices represent web pages and directed edges represent links from one page to another. A similar approach can be taken to problems in social media,[5] travel, biology, computer chip design, mapping the progression of neuro-degenerative diseases,[6][7] and many other fields. The development of algorithms to handle graphs is therefore of major interest in computer science. The transformation of graphs is often formalized and represented by graph rewrite systems. Complementary to graph transformationsystems focusing on rule-based in-memory manipulation of graphs are graph databases geared towards transaction-safe, persistent storing and querying of graph-structured data.  ",
            "assembleScratchTime":"2019-03-15 19:37:45",
            "facetId":557387,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Tree_traversal",
            "type":"text"
        },
        {
            "assembleId":2861756,
            "assembleContent":"<h4>In one very common sense of the term,<sup id="cite_ref-4"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-4">[4]</a></sup> a <i>graph</i> is an <a href="https://en.wikipedia.org/wiki/Ordered_pair" title="Ordered pair">ordered pair</a> <i>G</i> = (<i>V</i>, <i>E</i>) comprising a <a href="https://en.wikipedia.org/wiki/Set_(mathematics)" title="Set (mathematics)">set</a> <i>V</i> of <i>vertices</i>, <i>nodes</i> or <i>points</i> together with a set <i>E</i> of <i>edges</i>, <i>arcs</i> or <i>lines</i>, which are 2-element subsets of <i>V</i> (i.e., an edge is associated with two vertices, and the association takes the form of the unordered pair of the vertices). To avoid ambiguity, this type of graph may be described precisely as <i><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Undirected_graph" title="Graph (discrete mathematics)">undirected</a></i> and <i><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph" title="Graph (discrete mathematics)">simple</a></i>.  <br></h4>  ",
            "assembleText":"In one very common sense of the term,[4] a graph is an ordered pair G = (V, E) comprising a set V of vertices, nodes or points together with a set E of edges, arcs or lines, which are 2-element subsets of V (i.e., an edge is associated with two vertices, and the association takes the form of the unordered pair of the vertices). To avoid ambiguity, this type of graph may be described precisely as undirected and simple.  ",
            "assembleScratchTime":"2019-03-15 19:39:02",
            "facetId":557387,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863356,
            "assembleContent":"<h2><p>什么是图呢？</p><p>图是一种复杂的非线性结构。</p><p>在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前驱和一个直接后继；</p><p>在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(父节点)及下一层的多个元素(孩子节点)相关；</p><p>而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。</p><p>图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)</p></h2> ",
            "assembleText":"什么是图呢？ 图是一种复杂的非线性结构。 在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前驱和一个直接后继； 在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(父节点)及下一层的多个元素(孩子节点)相关； 而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。 图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)",
            "assembleScratchTime":"2019-03-20 22:41:18",
            "facetId":557387,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863497,
            "assembleContent":"<div>在<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8" title="数学">数学</a>的分支<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA" title="图论">图论</a>中，<b>图</b>（<span lang="en">Graph</span>）用于表示物件与物件之间的关系，是<a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E8%AB%96" title="图论">图论</a>的基本研究对象。一张图由一些小圆点（称为<b>顶点</b>或<b>结点</b>）和连结这些圆点的直线或曲线（称为<b><a href="https://zh.wikipedia.org/wiki/%E9%82%8A" title="边">边</a></b>）组成。<a href="https://zh.wikipedia.org/wiki/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E7%BA%A6%E7%91%9F%E5%A4%AB%C2%B7%E8%A5%BF%E5%B0%94%E7%BB%B4%E6%96%AF%E7%89%B9" title="詹姆斯·约瑟夫·西尔维斯特">西尔维斯特</a>在1878年首次提出“图”这一名词  <br></div> ",
            "assembleText":"在数学的分支图论中，图（Graph）用于表示物件与物件之间的关系，是图论的基本研究对象。一张图由一些小圆点（称为顶点或结点）和连结这些圆点的直线或曲线（称为边）组成。西尔维斯特在1878年首次提出“图”这一名词  ",
            "assembleScratchTime":"2019-03-21 19:58:36",
            "facetId":557387,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863498,
            "assembleContent":"<div><h3><span id="二元組的定義">二元组的定义</span></h3><p>一张<b>图</b> <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G}"><semantics><annotation encoding="application/x-tex">{\displaystyle G}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G"> 是一个<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%BA%8F%E5%AF%B9" title="有序对">二元组</a><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (V,E)}"><semantics><annotation encoding="application/x-tex">{\displaystyle (V,E)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a01724c7d662052bd5f1c34cb725c8001634069a" aria-hidden="true" alt="(V,E)">，其中<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V}"><semantics><annotation encoding="application/x-tex">{\displaystyle V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af0f6064540e84211d0ffe4dac72098adfa52845" aria-hidden="true" alt="V">称为顶点集，<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E}"><semantics><annotation encoding="application/x-tex">{\displaystyle E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" aria-hidden="true" alt="E">称为边集。它们亦可写成<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V(G)}"><semantics><annotation encoding="application/x-tex">{\displaystyle V(G)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8ba39dee5fd7f4467e387af4026315fb1fb21628" aria-hidden="true" alt="V(G)">和<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E(G)}"><semantics><annotation encoding="application/x-tex">{\displaystyle E(G)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c9fe79ce568f84c67757cfb1b3c9660698e8b20a" aria-hidden="true" alt="E(G)">。 <math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E}"><semantics><annotation encoding="application/x-tex">{\displaystyle E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" aria-hidden="true" alt="E">的元素是一个二元组数对，用<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (x,y)}"><semantics><annotation encoding="application/x-tex">{\displaystyle (x,y)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/41cf50e4a314ca8e2c30964baa8d26e5be7a9386" aria-hidden="true" alt="(x,y)">表示，其中<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle x,y\in V}"><semantics><annotation encoding="application/x-tex">{\displaystyle x,y\in V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/89e1c8106b3df898a0338c2ebce32902e4941fc8" aria-hidden="true" alt="x,y \in V">。</p></div> ",
            "assembleText":"二元组的定义 一张图  {\displaystyle G} 是一个二元组 {\displaystyle (V,E)}，其中 {\displaystyle V}称为顶点集， {\displaystyle E}称为边集。它们亦可写成 {\displaystyle V(G)}和 {\displaystyle E(G)}。  {\displaystyle E}的元素是一个二元组数对，用 {\displaystyle (x,y)}表示，其中 {\displaystyle x,y\in V}。",
            "assembleScratchTime":"2019-03-21 19:59:19",
            "facetId":557387,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863499,
            "assembleContent":"<h3><span id="三元組的定義">三元组的定义</span></h3><h3><p>一张<b>图</b> <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G"> 是一个三元组<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle (V,E,I)}"><semantics><annotation encoding="application/x-tex">{\displaystyle (V,E,I)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/25e6727f545b24b65b25e83f42c35471dd4800eb" aria-hidden="true" alt="(V,E,I)">，其中<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V}"><semantics><annotation encoding="application/x-tex">{\displaystyle V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af0f6064540e84211d0ffe4dac72098adfa52845" aria-hidden="true" alt="V">称为顶集（Vertices set），<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E}"><semantics><annotation encoding="application/x-tex">{\displaystyle E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" aria-hidden="true" alt="E">称为边集（Edges set），<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E}"><semantics><annotation encoding="application/x-tex">{\displaystyle E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" aria-hidden="true" alt="E">与<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V}"><semantics><annotation encoding="application/x-tex">{\displaystyle V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af0f6064540e84211d0ffe4dac72098adfa52845" aria-hidden="true" alt="V">不相交；<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle I}"><semantics><annotation encoding="application/x-tex">{\displaystyle I}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/535ea7fc4134a31cbe2251d9d3511374bc41be9f" aria-hidden="true" alt="I">称为关联函数，<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle I}"><semantics><annotation encoding="application/x-tex">{\displaystyle I}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/535ea7fc4134a31cbe2251d9d3511374bc41be9f" aria-hidden="true" alt="I">将<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E}"><semantics><annotation encoding="application/x-tex">{\displaystyle E}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4232c9de2ee3eec0a9c0a19b15ab92daa6223f9b" aria-hidden="true" alt="E">中的每一个元素映射到<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V\times V}"><semantics><annotation encoding="application/x-tex">{\displaystyle V\times V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/55115711e4cc81797cf763ed90fc991a306523e7" aria-hidden="true" alt="V\times V">。如果<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle I(e)=(u,v)(e\in E,u,v\in V)}"><semantics><annotation encoding="application/x-tex">{\displaystyle I(e)=(u,v)(e\in E,u,v\in V)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/43c0e276c188a193b162049a36d34b21ffc26e29" aria-hidden="true" alt="I(e)=(u,v) (e\in E, u,v \in V)">那么称边<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle e}"><semantics><annotation encoding="application/x-tex">{\displaystyle e}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cd253103f0876afc68ebead27a5aa9867d927467" aria-hidden="true" alt="e">连接顶点<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u,v}"><semantics><annotation encoding="application/x-tex">{\displaystyle u,v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7e66f4b32a0181923cc1337a5634f38241e5c697" aria-hidden="true" alt="u,v">，而<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u,v}"><semantics><annotation encoding="application/x-tex">{\displaystyle u,v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7e66f4b32a0181923cc1337a5634f38241e5c697" aria-hidden="true" alt="u,v">则称作<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle e}"><semantics><annotation encoding="application/x-tex">{\displaystyle e}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cd253103f0876afc68ebead27a5aa9867d927467" aria-hidden="true" alt="e">的端点，<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u,v}"><semantics><annotation encoding="application/x-tex">{\displaystyle u,v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7e66f4b32a0181923cc1337a5634f38241e5c697" aria-hidden="true" alt="u,v">此时关于<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle e}"><semantics><annotation encoding="application/x-tex">{\displaystyle e}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cd253103f0876afc68ebead27a5aa9867d927467" aria-hidden="true" alt="e">相邻。同时，若两条边<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle i,j}"><semantics><annotation encoding="application/x-tex">{\displaystyle i,j}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f4cbf8bbc622154cda8208d6e339495fe16a1f9a" aria-hidden="true" alt="i,j">有一个公共顶点<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u}"><semantics><annotation encoding="application/x-tex">{\displaystyle u}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" aria-hidden="true" alt="u">，则称<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle i,j}"><semantics><annotation encoding="application/x-tex">{\displaystyle i,j}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f4cbf8bbc622154cda8208d6e339495fe16a1f9a" aria-hidden="true" alt="i,j">关于<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u}"><semantics><annotation encoding="application/x-tex">{\displaystyle u}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" aria-hidden="true" alt="u">相邻。</p></h3> ",
            "assembleText":"三元组的定义 一张图  是一个三元组 {\displaystyle (V,E,I)}，其中 {\displaystyle V}称为顶集（Vertices set）， {\displaystyle E}称为边集（Edges set）， {\displaystyle E}与 {\displaystyle V}不相交； {\displaystyle I}称为关联函数， {\displaystyle I}将 {\displaystyle E}中的每一个元素映射到 {\displaystyle V\times V}。如果 {\displaystyle I(e)=(u,v)(e\in E,u,v\in V)}那么称边 {\displaystyle e}连接顶点 {\displaystyle u,v}，而 {\displaystyle u,v}则称作 {\displaystyle e}的端点， {\displaystyle u,v}此时关于 {\displaystyle e}相邻。同时，若两条边 {\displaystyle i,j}有一个公共顶点 {\displaystyle u}，则称 {\displaystyle i,j}关于 {\displaystyle u}相邻。",
            "assembleScratchTime":"2019-03-21 20:00:10",
            "facetId":557387,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863645,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para">图是什么，图是一种数据结构，一种非线性结构，所谓的非线性结构，浅显地理解的话，就是图的存储不是像链表这样的线性存储结构，而是由两个集合所组成的一种数据结构。  <br></div></div></div></dt></h2>   ",
            "assembleText":"图是什么，图是一种数据结构，一种非线性结构，所谓的非线性结构，浅显地理解的话，就是图的存储不是像链表这样的线性存储结构，而是由两个集合所组成的一种数据结构。  ",
            "assembleScratchTime":"2019-03-22 16:51:01",
            "facetId":557387,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863646,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><p>一个图中有两类东西，一种是结点，一种结点之间的连线。要用一种数据结构来表示的话，首先我们需要一个集合来存储所有的点，我们用V这个集合来表示（vertex），还需要另一个集合来存储所有的边，我们用E来表示(Edge)，那么一个图就可以表示为：</p><blockquote><p><strong>G = (V，E）</strong></p></blockquote></div></div></div></dt></h2>   ",
            "assembleText":"一个图中有两类东西，一种是结点，一种结点之间的连线。要用一种数据结构来表示的话，首先我们需要一个集合来存储所有的点，我们用V这个集合来表示（vertex），还需要另一个集合来存储所有的边，我们用E来表示(Edge)，那么一个图就可以表示为： G = (V，E）",
            "assembleScratchTime":"2019-03-22 16:51:15",
            "facetId":557387,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863647,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><p>有的图的边是有方向的，有的是没有方向的。</p><p>（A,B）表示A结点与B结点之间无方向的边，<A,B>则表示方向为从A到B的一条边，当然，如果是<B,A>，则方向相反。因此从边的方向我们就可以把图分为<strong>有向图</strong>和<strong>无向图</strong>两种。</p></div></div></div></dt></h2>   ",
            "assembleText":"有的图的边是有方向的，有的是没有方向的。 （A,B）表示A结点与B结点之间无方向的边，<A,B>则表示方向为从A到B的一条边，当然，如果是<B,A>，则方向相反。因此从边的方向我们就可以把图分为有向图和无向图两种。",
            "assembleScratchTime":"2019-03-22 16:53:57",
            "facetId":557387,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863819,
            "assembleContent":"<div>图是一个系统的表示，它包含离散的互连元素。元素由节点表示，互连由边表示。  <br></div> ",
            "assembleText":"图是一个系统的表示，它包含离散的互连元素。元素由节点表示，互连由边表示。  ",
            "assembleScratchTime":"2019-03-22 23:17:58",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863956,
            "assembleContent":"<p>在计算机科学中，一个图就是一些 <code>顶点</code>的集合，这些顶点通过一系列<code>边</code>结对（连接）。顶点用源圆圈表示，边就是这些圆圈之间的连线。</p><p>顶点之间通过边连接。</p><p>顶点有时也称为节点或交点，边有时也称为链接。图不可以为空。</p> ",
            "assembleText":"在计算机科学中，一个图就是一些 顶点的集合，这些顶点通过一系列边结对（连接）。顶点用源圆圈表示，边就是这些圆圈之间的连线。 顶点之间通过边连接。 顶点有时也称为节点或交点，边有时也称为链接。图不可以为空。",
            "assembleScratchTime":"2019-03-23 20:37:14",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863957,
            "assembleContent":"<p>V（G）表示图 G 中顶点的有限非空集。用 V 表示图 G 中顶点的个数，也称为图 G 的<code>阶</code>。</p><p>E（G）表示图 G 中顶点之间的关系（边）集合。用 E 表示图 G 中边的条数。</p> ",
            "assembleText":"V（G）表示图 G 中顶点的有限非空集。用 V 表示图 G 中顶点的个数，也称为图 G 的阶。 E（G）表示图 G 中顶点之间的关系（边）集合。用 E 表示图 G 中边的条数。",
            "assembleScratchTime":"2019-03-23 20:37:28",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863968,
            "assembleContent":"<h4>图（Graph）是数据结构中最复杂的一种结构，线性表描述的是一对一关系，树描述的是一对多关系，而图描述的是多对多关系。无论是一对一还是一对多，都有一个明确的切入点，而图却不具备这种简单的属性。正因为此，关于图的基础知识也是最多，下面我们就先对这些基础知识进行梳理。  <br></h4> ",
            "assembleText":"图（Graph）是数据结构中最复杂的一种结构，线性表描述的是一对一关系，树描述的是一对多关系，而图描述的是多对多关系。无论是一对一还是一对多，都有一个明确的切入点，而图却不具备这种简单的属性。正因为此，关于图的基础知识也是最多，下面我们就先对这些基础知识进行梳理。  ",
            "assembleScratchTime":"2019-03-23 20:47:06",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863969,
            "assembleContent":"<h2>图的定义</h2><h4><blockquote><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V, E)，其中 G 表示一个图， V 是图 G 中顶点的集合， E 是图 G 中边的集合。顶点，就是图中的数据元素，边则用来表示数据之间的逻辑关系。顶点是有穷非空的，边则可以为空集。</p></blockquote></h4> ",
            "assembleText":"图的定义 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V, E)，其中 G 表示一个图， V 是图 G 中顶点的集合， E 是图 G 中边的集合。顶点，就是图中的数据元素，边则用来表示数据之间的逻辑关系。顶点是有穷非空的，边则可以为空集。",
            "assembleScratchTime":"2019-03-23 20:47:23",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864056,
            "assembleContent":"<h3><p>图G是一个有序二元组(V,E)，其中V称为顶集(Vertices Set)，E称为边集(Edges set)，E的元素都是二元组，用(x,y)表示，其中x,y∈V。如果(x,y)等同于(y,x)，则这条边是无向的，否则就是有向的，并且称x为尾，y为头。  <br></p></h3>   ",
            "assembleText":"图G是一个有序二元组(V,E)，其中V称为顶集(Vertices Set)，E称为边集(Edges set)，E的元素都是二元组，用(x,y)表示，其中x,y∈V。如果(x,y)等同于(y,x)，则这条边是无向的，否则就是有向的，并且称x为尾，y为头。  ",
            "assembleScratchTime":"2019-03-23 21:27:52",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/5c1ec12b155b",
            "type":"text"
        },
        {
            "assembleId":2864133,
            "assembleContent":"<div><h4>图的基本概念 ：</h4>
<h5>图G 由 顶点集V 和 边集E 组成，记为 G = ( V， E )</h5>
<h6>V = {v1, v2, ... , vn} , E = { (u,v) | u ∈V ，v ∈ V }</h6>
<p><strong>注 ：</strong> 线性表可以是空表，树可以是空树；<br>
但是<strong>图不可以是空图</strong>，<strong>图的 V <code>一定</code>非空</strong>，<strong>E可以为空</strong>，表示此时图中只有顶点而没有边</p></div> ",
            "assembleText":"图的基本概念 ： 图G 由 顶点集V 和 边集E 组成，记为 G = ( V， E ) V = {v1, v2, ... , vn} , E = { (u,v) | u ∈V ，v ∈ V } 注 ： 线性表可以是空表，树可以是空树； 但是图不可以是空图，图的 V 一定非空，E可以为空，表示此时图中只有顶点而没有边",
            "assembleScratchTime":"2019-03-23 21:42:09",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864389,
            "assembleContent":"<ul><li><div><h4>图的基本概念 ：</h4>
<h5>图G 由 顶点集V 和 边集E 组成，记为 G = ( V， E )</h5>
<h6>V = {v1, v2, ... , vn} , E = { (u,v) | u ∈V ，v ∈ V }</h6>
<p><strong>注 ：</strong> 线性表可以是空表，树可以是空树；<br>
但是<strong>图不可以是空图</strong>，<strong>图的 V <code>一定</code>非空</strong>，<strong>E可以为空</strong>，表示此时图中只有顶点而没有边</p></div><br></li></ul> ",
            "assembleText":"图的基本概念 ： 图G 由 顶点集V 和 边集E 组成，记为 G = ( V， E ) V = {v1, v2, ... , vn} , E = { (u,v) | u ∈V ，v ∈ V } 注 ： 线性表可以是空表，树可以是空树； 但是图不可以是空图，图的 V 一定非空，E可以为空，表示此时图中只有顶点而没有边",
            "assembleScratchTime":"2019-03-24 11:43:43",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864409,
            "assembleContent":"<ul><li><h4><div><p>图是一种复杂的非线性结构。</p>
<p>在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前驱和一个直接后继；</p>
<p>在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(父节点)及下一层的多个元素(孩子节点)相关；</p>
<p>而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。</p>
<p>图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)</p></div><br><br></h4></li></ul> ",
            "assembleText":"图是一种复杂的非线性结构。 在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素(除第一个和最后一个外)只有一个直接前驱和一个直接后继； 在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素(父节点)及下一层的多个元素(孩子节点)相关； 而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。 图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E)",
            "assembleScratchTime":"2019-03-24 11:47:56",
            "facetId":557387,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/348bd5b17e28",
            "type":"text"
        },
        {
            "assembleId":2861793,
            "assembleContent":"<div label-module="para-title"><h4>Two edges of a graph are called <i>adjacent</i> if they share a common vertex. Two arrows of a directed graph are called <i>consecutive</i> if the head of the first one is the tail of the second one. Similarly, two vertices are called <i>adjacent</i> if they share a common edge (<i>consecutive</i> if the first one is the tail and the second one is the head of an arrow), in which case the common edge is said to <i>join</i>the two vertices. An edge and a vertex on that edge are called <i>incident</i>.  <br></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Two edges of a graph are called adjacent if they share a common vertex. Two arrows of a directed graph are called consecutive if the head of the first one is the tail of the second one. Similarly, two vertices are called adjacent if they share a common edge (consecutive if the first one is the tail and the second one is the head of an arrow), in which case the common edge is said to jointhe two vertices. An edge and a vertex on that edge are called incident.  ",
            "assembleScratchTime":"2019-03-15 20:06:41",
            "facetId":557388,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861798,
            "assembleContent":"<div label-module="para-title"><h4><p>The graph with only one vertex and no edges is called the <i>trivial graph</i>. A graph with only vertices and no edges is known as an <i>edgeless graph</i>. The graph with no vertices and no edges is sometimes called the <i><a href="https://en.wikipedia.org/wiki/Null_graph" title="Null graph">null graph</a></i> or <i>empty graph</i>, but the terminology is not consistent and not all mathematicians allow this object.  <br></p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"The graph with only one vertex and no edges is called the trivial graph. A graph with only vertices and no edges is known as an edgeless graph. The graph with no vertices and no edges is sometimes called the null graph or empty graph, but the terminology is not consistent and not all mathematicians allow this object.  ",
            "assembleScratchTime":"2019-03-15 20:07:11",
            "facetId":557388,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2856977,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>①、顶点：</h4><h4><p>　　在大多数情况下，顶点表示某个真实世界的对象，这个对象必须用数据项来描述。比如在一个飞机航线模拟程序中，顶点表示城市，那么它需要存储城市的名字、海拔高度、地理位置和其它相关信息，因此通常用一个顶点类的对象来表示一个顶点，这里我们仅仅在顶点中存储了一个字母来标识顶点，同时还有一个标志位，用来判断该顶点有没有被访问过（用于后面的搜索）。</p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"①、顶点： 　　在大多数情况下，顶点表示某个真实世界的对象，这个对象必须用数据项来描述。比如在一个飞机航线模拟程序中，顶点表示城市，那么它需要存储城市的名字、海拔高度、地理位置和其它相关信息，因此通常用一个顶点类的对象来表示一个顶点，这里我们仅仅在顶点中存储了一个字母来标识顶点，同时还有一个标志位，用来判断该顶点有没有被访问过（用于后面的搜索）。",
            "assembleScratchTime":"2019-03-03 19:36:07",
            "facetId":557388,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856978,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4><pre><code>/**<br> * 顶点类<br> * @author vae<br> */<br>public class Vertex {<br>    public char label;<br>    public boolean wasVisited;<br>     <br>    public Vertex(char label){<br>        this.label = label;<br>        wasVisited = false;<br>    }<br>}</code></pre><p><br></p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"/**  * 顶点类  * @author vae  */ public class Vertex {     public char label;     public boolean wasVisited;          public Vertex(char label){         this.label = label;         wasVisited = false;     } }",
            "assembleScratchTime":"2019-03-03 19:36:28",
            "facetId":557388,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2861796,
            "assembleContent":"<div label-module="para-title"><h4><p>Normally, the vertices of a graph, by their nature as elements of a set, are distinguishable. This kind of graph may be called <i>vertex-labeled</i>. However, for many questions it is better to treat vertices as indistinguishable. (Of course, the vertices may be still distinguishable by the properties of the graph itself, e.g., by the numbers of incident edges.) The same remarks apply to edges, so graphs with labeled edges are called <i>edge-labeled</i>. Graphs with labels attached to edges or vertices are more generally designated as <i>labeled</i>. Consequently, graphs in which vertices are indistinguishable and edges are indistinguishable are called <i>unlabeled</i>. (Note that in the literature, the term <i>labeled</i> may apply to other kinds of labeling, besides that which serves only to distinguish different vertices or edges.)</p><p>The <a href="https://en.wikipedia.org/wiki/Category_theory" title="Category theory">category</a> of all graphs is the <a href="https://en.wikipedia.org/wiki/Slice_category" title="Slice category">slice category</a> Set ↓ <i>D</i> where <i>D</i>: Set → Set is the <a href="https://en.wikipedia.org/wiki/Functor" title="Functor">functor</a> taking a set <i>s</i> to <i>s</i> × <i>s</i>.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"Normally, the vertices of a graph, by their nature as elements of a set, are distinguishable. This kind of graph may be called vertex-labeled. However, for many questions it is better to treat vertices as indistinguishable. (Of course, the vertices may be still distinguishable by the properties of the graph itself, e.g., by the numbers of incident edges.) The same remarks apply to edges, so graphs with labeled edges are called edge-labeled. Graphs with labels attached to edges or vertices are more generally designated as labeled. Consequently, graphs in which vertices are indistinguishable and edges are indistinguishable are called unlabeled. (Note that in the literature, the term labeled may apply to other kinds of labeling, besides that which serves only to distinguish different vertices or edges.) The category of all graphs is the slice category Set ↓ D where D: Set → Set is the functor taking a set s to s × s.",
            "assembleScratchTime":"2019-03-15 20:07:02",
            "facetId":557388,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863673,
            "assembleContent":"<h2><ul><li>顶点数叫做图的阶，n个顶点的图称为n阶图</li><li>一条边也没有叫做零图，1阶零图称为平凡图，平凡图只有1个顶点</li><li>顶点集为空集的图叫做空图</li><li>将有向图的各条有向边改成无向边后得到的无向图称为这个有向图的基图</li><li>图中没有边关联的顶点叫做孤立点</li></ul></h2>    ",
            "assembleText":"顶点数叫做图的阶，n个顶点的图称为n阶图 一条边也没有叫做零图，1阶零图称为平凡图，平凡图只有1个顶点 顶点集为空集的图叫做空图 将有向图的各条有向边改成无向边后得到的无向图称为这个有向图的基图 图中没有边关联的顶点叫做孤立点",
            "assembleScratchTime":"2019-03-22 17:12:09",
            "facetId":557388,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863674,
            "assembleContent":"<h2><ul><li><div><div>多重图与简单图<br>
在无向图中，如果关联一对顶点的无向边多余1条，则称这些边为平行边，平行边的条数称为重数。<br>
在有向图中，如果关联一对顶点的有向边多余1条，并且这些边的方向相同，则称这些边为平行边。<br>
含平行边的图称为多重图，既不含平行边也不含环（vi=vj对应的一条边）的图称为简单图。</div><br><br>作者：zizhan<br>链接：https://www.jianshu.com/p/d761bdc76bf7<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></li></ul></h2>    ",
            "assembleText":"多重图与简单图 在无向图中，如果关联一对顶点的无向边多余1条，则称这些边为平行边，平行边的条数称为重数。 在有向图中，如果关联一对顶点的有向边多余1条，并且这些边的方向相同，则称这些边为平行边。 含平行边的图称为多重图，既不含平行边也不含环（vi=vj对应的一条边）的图称为简单图。 作者：zizhan 链接：https://www.jianshu.com/p/d761bdc76bf7 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-22 17:12:19",
            "facetId":557388,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2864082,
            "assembleContent":"<div><li>无向图的邻接矩阵都是沿对角线对称的</li>
<li>要知道无向图中某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和；</li>
<li>对于有向图，要知道某个顶点的出度，其实就是这个顶点vi在邻接矩阵中第i行的元素之和，如果要知道某个顶点的入度，那就是第i列的元素之和。<br>
*邻接矩阵代码的实现（虽长但有注释不难滴）</li></div><br> ",
            "assembleText":"无向图的邻接矩阵都是沿对角线对称的 要知道无向图中某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和； 对于有向图，要知道某个顶点的出度，其实就是这个顶点vi在邻接矩阵中第i行的元素之和，如果要知道某个顶点的入度，那就是第i列的元素之和。 *邻接矩阵代码的实现（虽长但有注释不难滴）",
            "assembleScratchTime":"2019-03-23 21:31:39",
            "facetId":557388,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864154,
            "assembleContent":"<h4><div>图的两种表示方法：邻接表和邻接矩阵，既可以表示有向图，也可以表示无向图  <br></div></h4> ",
            "assembleText":"图的两种表示方法：邻接表和邻接矩阵，既可以表示有向图，也可以表示无向图  ",
            "assembleScratchTime":"2019-03-23 21:47:18",
            "facetId":557388,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864280,
            "assembleContent":"<p>图的两种表示方法：邻接表和邻接矩阵，既可以表示有向图，也可以表示无向图</p><p>通常使用邻接表表示法，这种方法表示稀疏图（图中的边数远小于点个数）比较紧凑。但当遇到稠密图（|E|接近|V|^2）或必须很快辨别两个给定顶点是否有邻接边时，通常使用邻接矩阵。</p> ",
            "assembleText":"图的两种表示方法：邻接表和邻接矩阵，既可以表示有向图，也可以表示无向图 通常使用邻接表表示法，这种方法表示稀疏图（图中的边数远小于点个数）比较紧凑。但当遇到稠密图（|E|接近|V|^2）或必须很快辨别两个给定顶点是否有邻接边时，通常使用邻接矩阵。",
            "assembleScratchTime":"2019-03-23 23:29:31",
            "facetId":557388,
            "sourceId":4,
            "domainId":413,
            "url":"https://blog.csdn.net/M87138/article/details/40000991",
            "type":"text"
        },
        {
            "assembleId":2865172,
            "assembleContent":"<h3>图的基本性质</h3><h2><div>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫节点，在图中数据元素，我们称之为顶点(Vertex)。</li>
<li>线性表中可以没有元素，称为空表；树中可以没有节点。称为空树；图中不能没有顶点，可以没有边。</li>
<li>线性表中，相邻的数据元素之间具有线性关系；树中，相邻两层的节点具有层次关系；而图中，任意两点之间都可能有关系，顶点之间的逻辑关系用边表示，边集可以是空的。</li></ul></div><br><br><br></h2> ",
            "assembleText":"图的基本性质 线性表中我们把数据元素叫元素，树中将数据元素叫节点，在图中数据元素，我们称之为顶点(Vertex)。 线性表中可以没有元素，称为空表；树中可以没有节点。称为空树；图中不能没有顶点，可以没有边。 线性表中，相邻的数据元素之间具有线性关系；树中，相邻两层的节点具有层次关系；而图中，任意两点之间都可能有关系，顶点之间的逻辑关系用边表示，边集可以是空的。",
            "assembleScratchTime":"2019-03-24 21:13:37",
            "facetId":557388,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/27cbc1fe14fd",
            "type":"text"
        },
        {
            "assembleId":2863821,
            "assembleContent":"<div>在某些图中，边具有长度，成本或权重等属性。例如，在路线图中，边的长度可能代表两个城市之间的距离，或旅行时间。在社交网络中，可能会有不同的边来表示不同种类的关系：朋友，商业伙伴等。  <br></div> ",
            "assembleText":"在某些图中，边具有长度，成本或权重等属性。例如，在路线图中，边的长度可能代表两个城市之间的距离，或旅行时间。在社交网络中，可能会有不同的边来表示不同种类的关系：朋友，商业伙伴等。  ",
            "assembleScratchTime":"2019-03-22 23:18:38",
            "facetId":557389,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863822,
            "assembleContent":"<div>边可以是有向或无向的，这取决于它们表示的关系是不对称的还是对称的。在路线图中，你可能会使用有向边表示单向街道，使用无向边表示双向街道。在某些社交网络，如 Facebook，好友是对称的：如果 A 是 B 的朋友，那么 B 也是 A 的朋友。但在 Twitter 上，“关注”关系并不对称；如果 A 关注了 B，这并不意味着 B  关注 A。因此，你可以使用无向边来表示 Facebook 网络，并将有向边用于 Twitter。</div><br><br> ",
            "assembleText":"边可以是有向或无向的，这取决于它们表示的关系是不对称的还是对称的。在路线图中，你可能会使用有向边表示单向街道，使用无向边表示双向街道。在某些社交网络，如 Facebook，好友是对称的：如果 A 是 B 的朋友，那么 B 也是 A 的朋友。但在 Twitter 上，“关注”关系并不对称；如果 A 关注了 B，这并不意味着 B 关注 A。因此，你可以使用无向边来表示 Facebook 网络，并将有向边用于 Twitter。",
            "assembleScratchTime":"2019-03-22 23:18:54",
            "facetId":557389,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863823,
            "assembleContent":"<div>图也很有用，因为有许多现实世界的问题可以使用图的算法来解决。例如，Dijkstra 的最短路径算法，是从图中找到某个节点到所有其他节点的最短路径的有效方式。路径是两个节点之间的，带有边的节点序列。  <br></div> ",
            "assembleText":"图也很有用，因为有许多现实世界的问题可以使用图的算法来解决。例如，Dijkstra 的最短路径算法，是从图中找到某个节点到所有其他节点的最短路径的有效方式。路径是两个节点之间的，带有边的节点序列。  ",
            "assembleScratchTime":"2019-03-22 23:19:04",
            "facetId":557389,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2864005,
            "assembleContent":"<h3>树形拓扑（Tree Topology）</h3><h3><div><div>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/3320837-27c12c762bc955d8.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/546/format/webp"></div>
</div>
<div>Tree Topology</div>
</div>
<p>适用场景：适用于根据自然的环境限制（如火墙）来搭建这种拓扑结构。</p>
<p>每一个根节点都是关键节点，特别是R节点。因此这种拓扑的使用场景较少，我能想到的场景也就是网络线缆，火墙等因素所导致不得不使用这种拓扑架构。</p></div><br><br>作者：MisterCH<br>链接：https://www.jianshu.com/p/20abde0bc863<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h3>  ",
            "assembleText":"树形拓扑（Tree Topology） Tree Topology 适用场景：适用于根据自然的环境限制（如火墙）来搭建这种拓扑结构。 每一个根节点都是关键节点，特别是R节点。因此这种拓扑的使用场景较少，我能想到的场景也就是网络线缆，火墙等因素所导致不得不使用这种拓扑架构。 作者：MisterCH 链接：https://www.jianshu.com/p/20abde0bc863 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:03:55",
            "facetId":557389,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/20abde0bc863",
            "type":"text"
        },
        {
            "assembleId":2864006,
            "assembleContent":"<h3>网格拓扑</h3><h3><div><div>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/3320837-b4a4d986f117aa6e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/286/format/webp"></div>
</div>
<div>Mesh Topology</div>
</div>
<p>适用场景：适用于根据自然的环境限制（如火墙）来搭建这种拓扑结构。</p>
<p>相比树形结构，有较健壮的结构。但是每增加一个节点，都需要考虑集群转发节点数量的问题（networkTTL）。因此需要有一个机制在每增加一个节点的时候都需要调整相连节点的networkTTL。</p></div><br><br>作者：MisterCH<br>链接：https://www.jianshu.com/p/20abde0bc863<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h3>  ",
            "assembleText":"网格拓扑 Mesh Topology 适用场景：适用于根据自然的环境限制（如火墙）来搭建这种拓扑结构。 相比树形结构，有较健壮的结构。但是每增加一个节点，都需要考虑集群转发节点数量的问题（networkTTL）。因此需要有一个机制在每增加一个节点的时候都需要调整相连节点的networkTTL。 作者：MisterCH 链接：https://www.jianshu.com/p/20abde0bc863 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:04:04",
            "facetId":557389,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/20abde0bc863",
            "type":"text"
        },
        {
            "assembleId":2861799,
            "assembleContent":"<div label-module="para-title"><h4><ul><li>The diagram at right is a graphic representation of the following graph:</li></ul><dl><dd><dl><dd><i>V</i> = {1, 2, 3, 4, 5, 6};</dd><dd><i>E</i> = {{1, 2}, {1, 5}, {2, 3}, {2, 5}, {3, 4}, {4, 5}, {4, 6}}.</dd></dl></dd></dl><ul><li>In <a href="https://en.wikipedia.org/wiki/Category_theory" title="Category theory">category theory</a>, a <a href="https://en.wikipedia.org/wiki/Category_(mathematics)" title="Category (mathematics)">small category</a> can be represented by a directed multigraph in which the objects of the category are represented as vertices and the <a href="https://en.wikipedia.org/wiki/Morphism" title="Morphism">morphisms</a> as directed edges. Then, the <a href="https://en.wikipedia.org/wiki/Functor" title="Functor">functors</a> between categories induce some, but not necessarily all, of the <a href="https://en.wikipedia.org/wiki/Digraph_morphism" title="Digraph morphism">digraph morphisms</a> of the graph.</li><li>In <a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, directed graphs are used to represent knowledge (e.g., <a href="https://en.wikipedia.org/wiki/Conceptual_graph" title="Conceptual graph">conceptual graph</a>), <a href="https://en.wikipedia.org/wiki/Finite_state_machine" title="Finite state machine">finite state machines</a>, and many other discrete structures.</li><li>A <a href="https://en.wikipedia.org/wiki/Binary_relation" title="Binary relation">binary relation</a> <i>R</i> on a set <i>X</i> defines a directed graph. An element <i>x</i> of <i>X</i> is a direct predecessor of an element <i>y</i> of <i>X</i> if and only if <i>xRy</i>.</li><li>A directed graph can model information networks such as <a href="https://en.wikipedia.org/wiki/Twitter" title="Twitter">Twitter</a>, with one user following another.<sup id="cite_ref-snatwitter_12-0"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-snatwitter-12">[12]</a></sup><sup id="cite_ref-twitterwtf_13-0"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-twitterwtf-13">[13]</a></sup></li><li>Particularly regular examples of directed graphs are given by the <a href="https://en.wikipedia.org/wiki/Cayley_graph" title="Cayley graph">Cayley graphs</a> of finitely-generated groups, as well as <a href="https://en.wikipedia.org/wiki/Schreier_coset_graph" title="Schreier coset graph">Schreier coset graphs</a></li></ul></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"The diagram at right is a graphic representation of the following graph: V = {1, 2, 3, 4, 5, 6}; E = {{1, 2}, {1, 5}, {2, 3}, {2, 5}, {3, 4}, {4, 5}, {4, 6}}. In category theory, a small category can be represented by a directed multigraph in which the objects of the category are represented as vertices and the morphisms as directed edges. Then, the functors between categories induce some, but not necessarily all, of the digraph morphisms of the graph. In computer science, directed graphs are used to represent knowledge (e.g., conceptual graph), finite state machines, and many other discrete structures. A binary relation R on a set X defines a directed graph. An element x of X is a direct predecessor of an element y of X if and only if xRy. A directed graph can model information networks such as Twitter, with one user following another.[12][13] Particularly regular examples of directed graphs are given by the Cayley graphs of finitely-generated groups, as well as Schreier coset graphs",
            "assembleScratchTime":"2019-03-15 20:07:40",
            "facetId":557390,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861755,
            "assembleContent":"<h4><a href="https://en.wikipedia.org/wiki/File:6n-graf.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/250px-6n-graf.svg.png" decoding="async" width="250" height="165" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/375px-6n-graf.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/5/5b/6n-graf.svg/500px-6n-graf.svg.png 2x"></a><div><div><a href="https://en.wikipedia.org/wiki/File:6n-graf.svg" title="Enlarge"></a></div>A <a href="https://en.wikipedia.org/wiki/Graph_drawing" title="Graph drawing">drawing</a> of a <a href="https://en.wikipedia.org/wiki/Labeled_graph" title="Labeled graph">labeled graph</a> on 6 vertices and 7 edges.</div></h4>  ",
            "assembleText":"A drawing of a labeled graph on 6 vertices and 7 edges.",
            "assembleScratchTime":"2019-03-15 19:38:24",
            "facetId":557390,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863362,
            "assembleContent":"<h3 id="autoid-2-2-0">拿图(b)来举例，由公式可以得到图G的边数e=(D(V<sub>1</sub>)+D(V<sub>2</sub>)+D(V<sub>3</sub>))/2=(3+2+3)/2=4</h3><h3 id="autoid-2-2-0">  <img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516730681397.jpg" style="font-family: "Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif; font-size: 14px;"><br></h3> ",
            "assembleText":"拿图(b)来举例，由公式可以得到图G的边数e=(D(V1)+D(V2)+D(V3))/2=(3+2+3)/2=4   ",
            "assembleScratchTime":"2019-03-20 22:47:41",
            "facetId":557390,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863365,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>下面是一个非连通图的例子：</p><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516732192699.jpg"></p><p>上图中，因为V<sub>5</sub>和V<sub>6</sub>是单独的，所以是非连通图。</p></h3> ",
            "assembleText":"下面是一个非连通图的例子： 上图中，因为V5和V6是单独的，所以是非连通图。",
            "assembleScratchTime":"2019-03-20 22:54:10",
            "facetId":557390,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863660,
            "assembleContent":"<h1><p>以下是一个<strong>无向图</strong>的邻接矩阵表示示例：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/165290-d99d5a14e0a632fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/426/format/webp"></div></div></div><p>从上图我们可以看到，无向图的邻接矩阵是<strong>对称矩阵</strong>，也<strong>一定</strong>是对称矩阵。且其左上角到右下角的对角线上值为零（对角线上表示的是相同的结点）</p></h1>   ",
            "assembleText":"以下是一个无向图的邻接矩阵表示示例： 从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵。且其左上角到右下角的对角线上值为零（对角线上表示的是相同的结点）",
            "assembleScratchTime":"2019-03-22 17:02:51",
            "facetId":557390,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863661,
            "assembleContent":"<h1><p><strong>有向图</strong>的邻接矩阵是怎样的呢？</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/165290-c89798c1f5d44686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/397/format/webp"></div></div></div></h1>   ",
            "assembleText":"有向图的邻接矩阵是怎样的呢？",
            "assembleScratchTime":"2019-03-22 17:03:04",
            "facetId":557390,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863663,
            "assembleContent":"<h1><p>用邻接表来表示一个图，如下：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/165290-7119446cbb8c7341.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/489/format/webp"></div></div></div><p>每一个结点后面所接的结点都是它的邻接结点。</p></h1>   ",
            "assembleText":"用邻接表来表示一个图，如下： 每一个结点后面所接的结点都是它的邻接结点。",
            "assembleScratchTime":"2019-03-22 17:04:03",
            "facetId":557390,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863820,
            "assembleContent":"<div>例如，你可以表示一个路线图，每个城市都是一个节点，每个城市之间的路线是一条边。或者你可以表示一个社交网络，每个人是节点，如果他们是朋友，两个人之间有边，否则没有。  <br></div> ",
            "assembleText":"例如，你可以表示一个路线图，每个城市都是一个节点，每个城市之间的路线是一条边。或者你可以表示一个社交网络，每个人是节点，如果他们是朋友，两个人之间有边，否则没有。  ",
            "assembleScratchTime":"2019-03-22 23:18:26",
            "facetId":557390,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863962,
            "assembleContent":"<h6><div><div><img src="https://upload-images.jianshu.io/upload_images/15399725-0d99c9d5f80d64ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/777/format/webp"></div></div><div>有向图（左）无向图（右）</div></h6> ",
            "assembleText":"有向图（左）无向图（右）",
            "assembleScratchTime":"2019-03-23 20:45:25",
            "facetId":557390,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863972,
            "assembleContent":"<h2><p>如下所示，左图为无向完全图，右侧为有向完全图：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-1692761b574904db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/555/format/webp"></div></div><div>有向图和无向图</div></div></h2> ",
            "assembleText":"如下所示，左图为无向完全图，右侧为有向完全图： 有向图和无向图",
            "assembleScratchTime":"2019-03-23 20:48:41",
            "facetId":557390,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2861767,
            "assembleContent":"<div label-module="para-title"><h4><span id="Undirected_graph">Undirected graph</span></h4><h4><p>An <i>undirected graph</i> is a graph in which edges have no orientation. The edge (<i>x</i>, <i>y</i>) is identical to the edge (<i>y</i>, <i>x</i>). That is, they are not ordered pairs, but unordered pairs—i.e., sets of two vertices {<i>x</i>, <i>y</i>} (or 2-<a href="https://en.wikipedia.org/wiki/Multiset" title="Multiset">multisets</a> in the case of <a href="https://en.wikipedia.org/wiki/Loop_(graph_theory)" title="Loop (graph theory)">loops</a>). The maximum number of edges in an undirected graph without a loop is <i>n</i>(<i>n</i> − 1)/2, where <i>n</i> is the number of nodes in the graph.</p></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"Undirected graph An undirected graph is a graph in which edges have no orientation. The edge (x, y) is identical to the edge (y, x). That is, they are not ordered pairs, but unordered pairs—i.e., sets of two vertices {x, y} (or 2-multisets in the case of loops). The maximum number of edges in an undirected graph without a loop is n(n − 1)/2, where n is the number of nodes in the graph.",
            "assembleScratchTime":"2019-03-15 19:45:32",
            "facetId":557506,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861768,
            "assembleContent":"<div label-module="para-title"><h4><div><a href="https://en.wikipedia.org/wiki/File:Undirected.svg"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Undirected.svg/125px-Undirected.svg.png" decoding="async" width="125" height="113" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Undirected.svg/188px-Undirected.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Undirected.svg/250px-Undirected.svg.png 2x"></a></div><div>A <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#Simple_graph" title="Graph (discrete mathematics)">simple</a> undirected graph with three vertices and three edges. Each vertex has degree two, so this is also a regular graph.</div></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"A simple undirected graph with three vertices and three edges. Each vertex has degree two, so this is also a regular graph.",
            "assembleScratchTime":"2019-03-15 19:45:43",
            "facetId":557506,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863357,
            "assembleContent":"<h2><p>对于一个图，若每条边都是没有方向的，则称该图为无向图。图示如下：</p><p><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516730223298.jpg"></p><p>因此，(V<sub>i</sub>，V<sub>j</sub>)和(V<sub>j</sub>，V<sub>i</sub>)表示的是同一条边。注意，无向图是用小括号，而下面介绍的有向图是用尖括号。</p><p>无向图的顶点集和边集分别表示为：</p><p>V(G)={V<sub>1</sub>，V<sub>2</sub>，V<sub>3</sub>，V<sub>4</sub>，V<sub>5</sub>}</p><p>E(G)={(V<sub>1</sub>，V<sub>2</sub>)，(V<sub>1</sub>，V<sub>4</sub>)，(V<sub>2</sub>，V<sub>3</sub>)，(V<sub>2</sub>，V<sub>5</sub>)，(V<sub>3</sub>，V<sub>4</sub>)，(V<sub>3</sub>，V<sub>5</sub>)，(V<sub>4</sub>，V<sub>5</sub>)}</p></h2> ",
            "assembleText":"对于一个图，若每条边都是没有方向的，则称该图为无向图。图示如下： 因此，(Vi，Vj)和(Vj，Vi)表示的是同一条边。注意，无向图是用小括号，而下面介绍的有向图是用尖括号。 无向图的顶点集和边集分别表示为： V(G)={V1，V2，V3，V4，V5} E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}",
            "assembleScratchTime":"2019-03-20 22:41:42",
            "facetId":557506,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863961,
            "assembleContent":"<h6>无向图</h6><h6><p>无向边（边）的有限集合。<br>即边没有方向</p><div><div><br></div></div></h6> ",
            "assembleText":"无向图 无向边（边）的有限集合。 即边没有方向",
            "assembleScratchTime":"2019-03-23 20:44:44",
            "facetId":557506,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b8a1abead31e",
            "type":"text"
        },
        {
            "assembleId":2863361,
            "assembleContent":"<h3 id="autoid-2-2-0">不管是无向图还是有向图，边数e、顶点数n和顶点的度数有如下关系：<br><img src="https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516731345534.jpg">  <br></h3> ",
            "assembleText":"不管是无向图还是有向图，边数e、顶点数n和顶点的度数有如下关系：   ",
            "assembleScratchTime":"2019-03-20 22:47:15",
            "facetId":557509,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863389,
            "assembleContent":"<h3 id="autoid-2-2-0"><p><img src="http://yotta.xjtushilei.com:8090/1553094691256/203537311.png" style="max-width:100%;"><br></p></h3>  ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-20 23:11:32",
            "facetId":557509,
            "sourceId":11,
            "domainId":413,
            "url":"https://wenku.baidu.com/view/d71d0aeb81c758f5f61f67cc.html",
            "type":"text"
        },
        {
            "assembleId":2863977,
            "assembleContent":"<h2><div><div><p>对于无向图G=(V, {E})，如果边(v, v')∈E，则称顶点 v 和 v' 互为邻接点，即 v 和 v' 相邻接，边(v, v')依附于顶点 v 和 v'，或者说(v, v')与顶点 v 和 v' 相关联。顶点 v 的度是和 v 相关联的边的数目，记为<strong>TD(v)</strong>。无向图的边的个数和顶点度数的关系如下：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-27ac5033c61fd49e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/133/format/webp"></div>
</div>
<div>无向图边和度</div></div></div><br><br>作者：大大纸飞机<br>链接：https://www.jianshu.com/p/9b263135be59<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h2> ",
            "assembleText":"对于无向图G=(V, {E})，如果边(v, v')∈E，则称顶点 v 和 v' 互为邻接点，即 v 和 v' 相邻接，边(v, v')依附于顶点 v 和 v'，或者说(v, v')与顶点 v 和 v' 相关联。顶点 v 的度是和 v 相关联的边的数目，记为TD(v)。无向图的边的个数和顶点度数的关系如下： 无向图边和度 作者：大大纸飞机 链接：https://www.jianshu.com/p/9b263135be59 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 20:50:21",
            "facetId":557509,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863978,
            "assembleContent":"<h2><div><p>对于有向图G=(V, {E})，如果弧<v, v'>∈E，则称顶点 v 邻接到 v'，v' 邻接自 v，弧<v, v'>和顶点 v,  v'相关联。以顶点 v 为头的弧的数目称为 v 的入度，记为<strong>ID(v)</strong>，以 v 为尾的弧的数目称为 v 的出度，记为<strong>OD(v)</strong>，顶点 v 的度为<strong>TD(v) = ID(v) + OD(v)</strong>。有向图的弧的个数和出度、入度的关系如下：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-46c03ba9521d73f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/224/format/webp"></div>
</div>
<div>有向图弧和度</div></div></div><br><br></h2> ",
            "assembleText":"对于有向图G=(V, {E})，如果弧<v, v'>∈E，则称顶点 v 邻接到 v'，v' 邻接自 v，弧<v, v'>和顶点 v, v'相关联。以顶点 v 为头的弧的数目称为 v 的入度，记为ID(v)，以 v 为尾的弧的数目称为 v 的出度，记为OD(v)，顶点 v 的度为TD(v) = ID(v) + OD(v)。有向图的弧的个数和出度、入度的关系如下： 有向图弧和度",
            "assembleScratchTime":"2019-03-23 20:50:32",
            "facetId":557509,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2861765,
            "assembleContent":"<div label-module="para-title"><h4><span id="Weighted_graph">Weighted graph</span></h4><h2><p>A <i>weighted graph</i> is a graph in which a number (the weight) is assigned to each edge.<sup id="cite_ref-9"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-9">[9]</a></sup> Such weights might represent for example costs, lengths or capacities, depending on the problem at hand. Some authors call such a graph a <i>network</i>.<sup id="cite_ref-10"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-10">[10]</a></sup><sup id="cite_ref-11"><a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)#cite_note-11">[11]</a></sup> <a href="https://en.wikipedia.org/wiki/Weighted_correlation_network_analysis" title="Weighted correlation network analysis">Weighted correlation networks</a> can be defined by soft-thresholding the pairwise correlations among variables (e.g. gene measurements). Such graphs arise in many contexts, for example in <a href="https://en.wikipedia.org/wiki/Shortest_path_problem" title="Shortest path problem">shortest path problems</a> such as the <a href="https://en.wikipedia.org/wiki/Traveling_salesman_problem" title="Traveling salesman problem">traveling salesman problem</a>.</p></h2><h3><div label-module="para"><div></div></div><div></div></h3></div>   ",
            "assembleText":"Weighted graph A weighted graph is a graph in which a number (the weight) is assigned to each edge.[9] Such weights might represent for example costs, lengths or capacities, depending on the problem at hand. Some authors call such a graph a network.[10][11] Weighted correlation networks can be defined by soft-thresholding the pairwise correlations among variables (e.g. gene measurements). Such graphs arise in many contexts, for example in shortest path problems such as the traveling salesman problem.",
            "assembleScratchTime":"2019-03-15 19:44:54",
            "facetId":557510,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861802,
            "assembleContent":"<div label-module="para-title"><h4><ul><li><i>unary operations</i>, which create a new graph from an initial one, such as:<ul><li><a href="https://en.wikipedia.org/wiki/Edge_contraction" title="Edge contraction">edge contraction</a>,</li><li><a href="https://en.wikipedia.org/wiki/Line_graph" title="Line graph">line graph</a>,</li><li><a href="https://en.wikipedia.org/wiki/Dual_graph" title="Dual graph">dual graph</a>,</li><li><a href="https://en.wikipedia.org/wiki/Complement_graph" title="Complement graph">complement graph</a>,</li><li><a href="https://en.wikipedia.org/wiki/Graph_rewriting" title="Graph rewriting">graph rewriting</a>;</li></ul></li></ul></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"unary operations, which create a new graph from an initial one, such as: edge contraction, line graph, dual graph, complement graph, graph rewriting;",
            "assembleScratchTime":"2019-03-15 20:08:38",
            "facetId":557516,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2861803,
            "assembleContent":"<div label-module="para-title"><h4><ul><li><i>binary operations</i>, which create a new graph from two initial ones, such as:<ul><li><a href="https://en.wikipedia.org/wiki/Disjoint_union_of_graphs" title="Disjoint union of graphs">disjoint union of graphs</a>,</li><li><a href="https://en.wikipedia.org/wiki/Cartesian_product_of_graphs" title="Cartesian product of graphs">cartesian product of graphs</a>,</li><li><a href="https://en.wikipedia.org/wiki/Tensor_product_of_graphs" title="Tensor product of graphs">tensor product of graphs</a>,</li><li><a href="https://en.wikipedia.org/wiki/Strong_product_of_graphs" title="Strong product of graphs">strong product of graphs</a>,</li><li><a href="https://en.wikipedia.org/wiki/Lexicographic_product_of_graphs" title="Lexicographic product of graphs">lexicographic product of graphs</a>,</li><li><a href="https://en.wikipedia.org/wiki/Series-parallel_graph" title="Series-parallel graph">series-parallel graphs</a>.</li></ul></li></ul></h4><h3><div label-module="para"><div></div></div><div></div></h3></div>    ",
            "assembleText":"binary operations, which create a new graph from two initial ones, such as: disjoint union of graphs, cartesian product of graphs, tensor product of graphs, strong product of graphs, lexicographic product of graphs, series-parallel graphs.",
            "assembleScratchTime":"2019-03-15 20:08:47",
            "facetId":557516,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2864288,
            "assembleContent":"<h3><p>时间复杂度</p><ul><li>邻接表存储时间复杂度O(V+E)</li><li>邻接矩阵存储时间复杂度O(V^2)</li></ul></h3> ",
            "assembleText":"时间复杂度 邻接表存储时间复杂度O(V+E) 邻接矩阵存储时间复杂度O(V^2)",
            "assembleScratchTime":"2019-03-23 23:32:04",
            "facetId":557523,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b3df2a2e2a43",
            "type":"text"
        },
        {
            "assembleId":2864430,
            "assembleContent":"<ul><li><h3><div><p>广度优先搜索如果采用邻接矩阵存储，则时间复杂度为O(n<sup>2</sup>)，如果采用邻接表存储，则时间复杂度为O(n+e)  <br></p></div></h3></li></ul>  ",
            "assembleText":"广度优先搜索如果采用邻接矩阵存储，则时间复杂度为O(n2)，如果采用邻接表存储，则时间复杂度为O(n+e)  ",
            "assembleScratchTime":"2019-03-24 11:52:33",
            "facetId":557523,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/348bd5b17e28",
            "type":"text"
        },
        {
            "assembleId":2864432,
            "assembleContent":"<ul><li><h3><div><p>深度优先搜索如果采用邻接矩阵存储，则时间复杂度为O(n<sup>2</sup>)；如果采用邻接表存储，时间复杂度为O(n+e)  <br></p></div></h3></li></ul> ",
            "assembleText":"深度优先搜索如果采用邻接矩阵存储，则时间复杂度为O(n2)；如果采用邻接表存储，时间复杂度为O(n+e)  ",
            "assembleScratchTime":"2019-03-24 11:52:22",
            "facetId":557523,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/348bd5b17e28",
            "type":"text"
        },
        {
            "assembleId":2863507,
            "assembleContent":"<h3><ul><li>一个不带权图中若两点不相邻，邻接矩阵相应位置为0，对带权图（网），相应位置为∞。一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一。在邻接表中，对图中每个顶点建立一个单链表（并按建立的次序编号），第i个单链表中的结点表示依附于顶点vi的边（对于有向图是以顶点vi为尾的弧）。每个结点由两个域组成：邻接点域（Adjvex），用以指示与vi邻接的点在图中的位置，链域（Nextarc）用以指向依附于顶点vi的下一条边所对应的结点。如果用邻接表存放网（带权图）的信息，则还需要在结点中增加一个存放权值的域（Info）。每个顶点的单链表中结点的个数即为该顶点的出度（与该顶点连接的边的总数）。无论是存储图或网，都需要在每个单链表前设一表头结点，这些表头结点的第一个域data用于存放结点vi的编号i，第二个域firstarc用于指向链表中第一个结点。  <br></li></ul></h3> ",
            "assembleText":"一个不带权图中若两点不相邻，邻接矩阵相应位置为0，对带权图（网），相应位置为∞。一个图的邻接矩阵表示是唯一的，但其邻接表表示不唯一。在邻接表中，对图中每个顶点建立一个单链表（并按建立的次序编号），第i个单链表中的结点表示依附于顶点vi的边（对于有向图是以顶点vi为尾的弧）。每个结点由两个域组成：邻接点域（Adjvex），用以指示与vi邻接的点在图中的位置，链域（Nextarc）用以指向依附于顶点vi的下一条边所对应的结点。如果用邻接表存放网（带权图）的信息，则还需要在结点中增加一个存放权值的域（Info）。每个顶点的单链表中结点的个数即为该顶点的出度（与该顶点连接的边的总数）。无论是存储图或网，都需要在每个单链表前设一表头结点，这些表头结点的第一个域data用于存放结点vi的编号i，第二个域firstarc用于指向链表中第一个结点。  ",
            "assembleScratchTime":"2019-03-21 20:19:13",
            "facetId":557640,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)#%E6%9C%AF%E8%AF%AD",
            "type":"text"
        },
        {
            "assembleId":2863658,
            "assembleContent":"<h1>存储结构</h1><h3><p>要存储一个图，我们知道图既有结点，又有边，对于有权图来说，每条边上还带有权值。常用的图的存储结构主要有以下二种：</p><ul><li>邻接矩阵</li><li>邻接表</li></ul></h3>   ",
            "assembleText":"存储结构 要存储一个图，我们知道图既有结点，又有边，对于有权图来说，每条边上还带有权值。常用的图的存储结构主要有以下二种： 邻接矩阵 邻接表",
            "assembleScratchTime":"2019-03-22 17:02:24",
            "facetId":557640,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863659,
            "assembleContent":"<h1>邻接矩阵</h1><h1><div><div>
<p>我们知道，要表示结点，我们可以用一个一维数组来表示，然而对于结点和结点之间的关系，则无法简单地用一维数组来表示了，我们可以用二维数组来表示，也就是一个矩阵形式的表示方法。</p>
<p>我们假设A是这个二维数组，那么A中的一个元素aij不仅体现出了结点vi和结点vj的关系，而且aij的值正可以表示权值的大小。</p></div><br><br>作者：beanlam<br>链接：https://www.jianshu.com/p/a47a147ec92c<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h1>   ",
            "assembleText":"邻接矩阵 我们知道，要表示结点，我们可以用一个一维数组来表示，然而对于结点和结点之间的关系，则无法简单地用一维数组来表示了，我们可以用二维数组来表示，也就是一个矩阵形式的表示方法。 我们假设A是这个二维数组，那么A中的一个元素aij不仅体现出了结点vi和结点vj的关系，而且aij的值正可以表示权值的大小。 作者：beanlam 链接：https://www.jianshu.com/p/a47a147ec92c 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-22 17:02:35",
            "facetId":557640,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863662,
            "assembleContent":"<h1>邻接表</h1><h1><p>我们知道，图的邻接矩阵存储方法用的是一个n*n的矩阵，当这个矩阵是稠密的矩阵（比如说当图是完全图的时候），那么当然选择用邻接矩阵存储方法。<br>可是如果这个矩阵是一个稀疏的矩阵呢，这个时候邻接表存储结构就是一种更节省空间的存储结构了。</p></h1>   ",
            "assembleText":"邻接表 我们知道，图的邻接矩阵存储方法用的是一个n*n的矩阵，当这个矩阵是稠密的矩阵（比如说当图是完全图的时候），那么当然选择用邻接矩阵存储方法。 可是如果这个矩阵是一个稀疏的矩阵呢，这个时候邻接表存储结构就是一种更节省空间的存储结构了。",
            "assembleScratchTime":"2019-03-22 17:03:18",
            "facetId":557640,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863664,
            "assembleContent":"<h2>邻接矩阵与邻接表的比较</h2><h1><p>当图中结点数目较小且边较多时，采用邻接矩阵效率更高。<br>当节点数目远大且边的数目远小于相同结点的完全图的边数时，采用邻接表存储结构更有效率。</p></h1>   ",
            "assembleText":"邻接矩阵与邻接表的比较 当图中结点数目较小且边较多时，采用邻接矩阵效率更高。 当节点数目远大且边的数目远小于相同结点的完全图的边数时，采用邻接表存储结构更有效率。",
            "assembleScratchTime":"2019-03-22 17:04:19",
            "facetId":557640,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863665,
            "assembleContent":"<h2>邻接矩阵模型类</h2><h2><p>邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。</p></h2>   ",
            "assembleText":"邻接矩阵模型类 邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。",
            "assembleScratchTime":"2019-03-22 17:04:36",
            "facetId":557640,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863795,
            "assembleContent":"<p>关联矩阵和邻接矩阵<br>无向图的关联矩阵mij记录的是顶点vi与边ej的关联次数（度）<br>有向图的邻接矩阵aij记录的是顶点vi邻接到顶点vj的有向边的条数  <br></p> ",
            "assembleText":"关联矩阵和邻接矩阵 无向图的关联矩阵mij记录的是顶点vi与边ej的关联次数（度） 有向图的邻接矩阵aij记录的是顶点vi邻接到顶点vj的有向边的条数  ",
            "assembleScratchTime":"2019-03-22 23:11:20",
            "facetId":557640,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863796,
            "assembleContent":"<p>欧拉图</p><ul><li>通过图（有向图或无向图）中所有边一次且仅一次遍历所有顶点的通路称为欧拉通路</li><li>通过图中所有边一次且仅一次遍历所有顶点的回路称为欧拉回路，具有欧拉回路的图称为欧拉图。规定平凡图是欧拉图。</li><li>具有欧拉通路而无欧拉回路的图称为半欧拉图。</li></ul> ",
            "assembleText":"欧拉图 通过图（有向图或无向图）中所有边一次且仅一次遍历所有顶点的通路称为欧拉通路 通过图中所有边一次且仅一次遍历所有顶点的回路称为欧拉回路，具有欧拉回路的图称为欧拉图。规定平凡图是欧拉图。 具有欧拉通路而无欧拉回路的图称为半欧拉图。",
            "assembleScratchTime":"2019-03-22 23:11:48",
            "facetId":557640,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863988,
            "assembleContent":"<h1>图的存储</h1><h2><p>线性表和图都有一个明确的切入点，但是对图而言，每个顶点都可以当做是起点，而且每个顶点之间都可能有逻辑关系，也就是说，单纯的使用数组或链表是无法完成图的存储的。</p></h2>  ",
            "assembleText":"图的存储 线性表和图都有一个明确的切入点，但是对图而言，每个顶点都可以当做是起点，而且每个顶点之间都可能有逻辑关系，也就是说，单纯的使用数组或链表是无法完成图的存储的。",
            "assembleScratchTime":"2019-03-23 20:54:09",
            "facetId":557640,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864425,
            "assembleContent":"<ul><li><h3>图的两种存储结构</h3><h3><ol><li><p>邻接矩阵，原理就是用两个数组，一个数组保存顶点集，一个数组保存边集。</p></li><li><p>邻接表，邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点V<sub>i</sub>，把所有邻接于V<sub>i</sub>的顶点V<sub>j</sub>链成一个单链表，这个单链表称为顶点V<sub>i</sub>的邻接表。</p></li></ol></h3></li></ul> ",
            "assembleText":"图的两种存储结构 邻接矩阵，原理就是用两个数组，一个数组保存顶点集，一个数组保存边集。 邻接表，邻接表是图的一种链式存储结构。这种存储结构类似于树的孩子链表。对于图G中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。",
            "assembleScratchTime":"2019-03-24 11:50:47",
            "facetId":557640,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/348bd5b17e28",
            "type":"text"
        },
        {
            "assembleId":2856952,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>①、邻接：</h4><p>　　如果两个顶点被同一条边连接，就称这两个顶点是邻接的，如上图 I 和 G 就是邻接的，而 I 和 F 就不是。有时候也将和某个指定顶点邻接的顶点叫做它的邻居，比如顶点 G 的邻居是 I、H、F。</p></div></div></div></div></dt></dl> ",
            "assembleText":"①、邻接： 　　如果两个顶点被同一条边连接，就称这两个顶点是邻接的，如上图 I 和 G 就是邻接的，而 I 和 F 就不是。有时候也将和某个指定顶点邻接的顶点叫做它的邻居，比如顶点 G 的邻居是 I、H、F。",
            "assembleScratchTime":"2019-03-03 19:16:47",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856954,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>②、路径：</h4><h4><p>　　路径是边的序列，比如从顶点B到顶点J的路径为 BAEJ，当然还有别的路径 BCDJ，BACDJ等等。</p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"②、路径： 　　路径是边的序列，比如从顶点B到顶点J的路径为 BAEJ，当然还有别的路径 BCDJ，BACDJ等等。",
            "assembleScratchTime":"2019-03-03 19:16:56",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856955,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>③、连通图和非连通图：</h4><h4><p>　　如果至少有一条路径可以连接起所有的顶点，那么这个图称作连通的；如果假如存在从某个顶点不能到达另外一个顶点，则称为非联通的。</p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"③、连通图和非连通图： 　　如果至少有一条路径可以连接起所有的顶点，那么这个图称作连通的；如果假如存在从某个顶点不能到达另外一个顶点，则称为非联通的。",
            "assembleScratchTime":"2019-03-03 19:17:04",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856956,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>④、有向图和无向图：</h4><h4><p>　　如果图中的边没有方向，可以从任意一边到达另一边，则称为无向图；比如双向高速公路，A城市到B城市可以开车从A驶向B，也可以开车从B城市驶向A城市。但是如果只能从A城市驶向B城市的图，那么则称为有向图。</p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"④、有向图和无向图： 　　如果图中的边没有方向，可以从任意一边到达另一边，则称为无向图；比如双向高速公路，A城市到B城市可以开车从A驶向B，也可以开车从B城市驶向A城市。但是如果只能从A城市驶向B城市的图，那么则称为有向图。",
            "assembleScratchTime":"2019-03-03 19:17:14",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856957,
            "assembleContent":"<dl><dt><div label-module="para"><div label-module="para"><div label-module="para"><div label-module="para"><h4>⑤、有权图和无权图：</h4><h4><p>　　图中的边被赋予一个权值，权值是一个数字，它能代表两个顶点间的物理距离，或者从一个顶点到另一个顶点的时间，这种图被称为有权图；反之边没有赋值的则称为无权图。</p><p>　　本篇博客我们讨论的是无权无向图。</p></h4></div></div></div></div></dt></dl> ",
            "assembleText":"⑤、有权图和无权图： 　　图中的边被赋予一个权值，权值是一个数字，它能代表两个顶点间的物理距离，或者从一个顶点到另一个顶点的时间，这种图被称为有权图；反之边没有赋值的则称为无权图。 　　本篇博客我们讨论的是无权无向图。",
            "assembleScratchTime":"2019-03-03 19:17:22",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856979,
            "assembleContent":"<h4>②、边：</h4><p>　　在前面讲解各种树的数据结构时，大多数树都是每个节点包含它的子节点的引用，比如红黑树、二叉树。也有用数组表示树，树组中节点的位置决定了它和其它节点的关系，比如堆就是用数组表示。</p><p>　　然而图并不像树，图没有固定的结构，图的每个顶点可以与任意多个顶点相连，为了模拟这种自由形式的组织结构，用如下两种方式表示图：邻接矩阵和邻接表（如果一条边连接两个顶点，那么这两个顶点就是邻接的）</p><p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209221659888-720670354.png" alt=""></p> ",
            "assembleText":"②、边： 　　在前面讲解各种树的数据结构时，大多数树都是每个节点包含它的子节点的引用，比如红黑树、二叉树。也有用数组表示树，树组中节点的位置决定了它和其它节点的关系，比如堆就是用数组表示。 　　然而图并不像树，图没有固定的结构，图的每个顶点可以与任意多个顶点相连，为了模拟这种自由形式的组织结构，用如下两种方式表示图：邻接矩阵和邻接表（如果一条边连接两个顶点，那么这两个顶点就是邻接的） 　　",
            "assembleScratchTime":"2019-03-03 19:36:46",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856988,
            "assembleContent":"<p>对于图的操作，还有一个最常用的就是找到最小生成树，最小生成树就是用最少的边连接所有顶点。对于给定的一组顶点，可能有很多种最小生成树，但是最小生成树的边的数量 E 总是比顶点 V 的数量小1，即：</p><p>　　V = E + 1</p><p>　　这里不用关心边的长度，不是找最短的路径（会在带权图中讲解），而是找最少数量的边，可以基于深度优先搜索和广度优先搜索来实现。</p><p>　　比如基于深度优先搜索，我们记录走过的边，就可以创建一个最小生成树。因为DFS 访问所有顶点，但只访问一次，它绝对不会两次访问同一个顶点，但她看到某条边将到达一个已访问的顶点，它就不会走这条边，它从来不遍历那些不可能的边，因此，DFS 算法走过整个图的路径必定是最小生成树。</p> ",
            "assembleText":"对于图的操作，还有一个最常用的就是找到最小生成树，最小生成树就是用最少的边连接所有顶点。对于给定的一组顶点，可能有很多种最小生成树，但是最小生成树的边的数量 E 总是比顶点 V 的数量小1，即： 　　V = E + 1 　　这里不用关心边的长度，不是找最短的路径（会在带权图中讲解），而是找最少数量的边，可以基于深度优先搜索和广度优先搜索来实现。 　　比如基于深度优先搜索，我们记录走过的边，就可以创建一个最小生成树。因为DFS 访问所有顶点，但只访问一次，它绝对不会两次访问同一个顶点，但她看到某条边将到达一个已访问的顶点，它就不会走这条边，它从来不遍历那些不可能的边，因此，DFS 算法走过整个图的路径必定是最小生成树。",
            "assembleScratchTime":"2019-03-03 19:40:09",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856989,
            "assembleContent":"<div><div><div id="highlighter_62949"><pre><code>//基于深度优先搜索找到最小生成树<br>public void mst(){<br>    vertexList[0].wasVisited = true;<br>    theStack.push(0);<br>     <br>    while(!theStack.isEmpty()){<br>        int currentVertex = theStack.peek();<br>        int v = getAdjUnvisitedVertex(currentVertex);<br>        if(v == -1){<br>            theStack.pop();<br>        }else{<br>            vertexList[v].wasVisited = true;<br>            theStack.push(v);<br>             <br>            displayVertex(currentVertex);<br>            displayVertex(v);<br>            System.out.print(" ");<br>        }<br>    }<br>     <br>    //搜索完毕，初始化，以便于下次搜索<br>    for(int i = 0; i < nVerts; i++) {<br>        vertexList[i].wasVisited = false;<br>    }<br>}</code></pre><p><br></p></div></div></div> ",
            "assembleText":"//基于深度优先搜索找到最小生成树 public void mst(){     vertexList[0].wasVisited = true;     theStack.push(0);          while(!theStack.isEmpty()){         int currentVertex = theStack.peek();         int v = getAdjUnvisitedVertex(currentVertex);         if(v == -1){             theStack.pop();         }else{             vertexList[v].wasVisited = true;             theStack.push(v);                          displayVertex(currentVertex);             displayVertex(v);             System.out.print(" ");         }     }          //搜索完毕，初始化，以便于下次搜索     for(int i = 0; i < nVerts; i++) {         vertexList[i].wasVisited = false;     } }",
            "assembleScratchTime":"2019-03-03 19:40:27",
            "facetId":557668,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2861758,
            "assembleContent":"<h3><span id="Adjacency_relation">Adjacency relation</span></h3><h4><p>The edges <i>E</i> of an undirected graph <i>G</i> induce a symmetric binary relation ~ on <i>V</i>that is called the <i>adjacency relation</i> of <i>G</i>. Specifically, for each edge {<i>x</i>, <i>y</i>}, the vertices <i>x</i> and <i>y</i> are said to be <i>adjacent</i> to one another, which is denoted <i>x</i> ~ <i>y</i>.</p></h4>  ",
            "assembleText":"Adjacency relation The edges E of an undirected graph G induce a symmetric binary relation ~ on Vthat is called the adjacency relation of G. Specifically, for each edge {x, y}, the vertices x and y are said to be adjacent to one another, which is denoted x ~ y.",
            "assembleScratchTime":"2019-03-15 19:40:11",
            "facetId":557668,
            "sourceId":1,
            "domainId":413,
            "url":"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)",
            "type":"text"
        },
        {
            "assembleId":2863360,
            "assembleContent":"<h3 id="autoid-2-2-0">顶点的度</h3><h2><p>对于无向图，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V<sub>3</sub>的度D(V<sub>3</sub>)=3</p><p>对于有向图，顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，图(b)中顶点V<sub>1</sub>的入度ID(V<sub>1</sub>)=1，出度OD(V<sub>1</sub>)=2，所以D(V<sub>1</sub>)=ID(V<sub>1</sub>)+OD(V<sub>1</sub>)=1+2=3</p></h2> ",
            "assembleText":"顶点的度 对于无向图，顶点的度表示以该顶点作为一个端点的边的数目。比如，图(a)无向图中顶点V3的度D(V3)=3 对于有向图，顶点的度分为入度和出度。入度表示以该顶点为终点的入边数目，出度是以该顶点为起点的出边数目，该顶点的度等于其入度和出度之和。比如，图(b)中顶点V1的入度ID(V1)=1，出度OD(V1)=2，所以D(V1)=ID(V1)+OD(V1)=1+2=3",
            "assembleScratchTime":"2019-03-20 22:46:52",
            "facetId":557668,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863363,
            "assembleContent":"<h3 id="autoid-2-2-0"><p>路径，比如在无向图G中，存在一个顶点序列V<sub>p</sub>，V<sub>i1</sub>，V<sub>i2</sub>，V<sub>i3</sub>…，V<sub>im</sub>，V<sub>q</sub>，使得(V<sub>p</sub>,V<sub>i1</sub>)，(V<sub>i1</sub>,V<sub>i2</sub>)，…，(V<sub>im</sub>,V<sub>q</sub>)均属于边集E(G)，则称顶点V<sub>p</sub>到V<sub>q</sub>存在一条路径。</p><p>路径长度，是指一条路径上经过的边的数量。</p><p>回路，指一条路径的起点和终点为同一个顶点。</p></h3> ",
            "assembleText":"路径，比如在无向图G中，存在一个顶点序列Vp，Vi1，Vi2，Vi3…，Vim，Vq，使得(Vp,Vi1)，(Vi1,Vi2)，…，(Vim,Vq)均属于边集E(G)，则称顶点Vp到Vq存在一条路径。 路径长度，是指一条路径上经过的边的数量。 回路，指一条路径的起点和终点为同一个顶点。",
            "assembleScratchTime":"2019-03-20 22:48:01",
            "facetId":557668,
            "sourceId":13,
            "domainId":413,
            "url":"https://www.cnblogs.com/nnngu/p/8339622.html",
            "type":"text"
        },
        {
            "assembleId":2863390,
            "assembleContent":"<h3 id="autoid-2-2-0"><p><img src="http://yotta.xjtushilei.com:8090/1553095172387/130589366.png" style="max-width:100%;"><br></p></h3>  ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-20 23:19:33",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://wenku.baidu.com/view/d71d0aeb81c758f5f61f67cc.html",
            "type":"text"
        },
        {
            "assembleId":2863392,
            "assembleContent":"<h3 id="autoid-2-2-0"><p><img src="http://yotta.xjtushilei.com:8090/1553095253763/1620250467.png" style="max-width:100%;"><br></p></h3>  ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-20 23:20:54",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://wenku.baidu.com/view/d71d0aeb81c758f5f61f67cc.html",
            "type":"text"
        },
        {
            "assembleId":2863503,
            "assembleContent":"<h3><ul><li><b>阶</b>（Order）：图<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G}"><semantics><annotation encoding="application/x-tex">{\displaystyle G}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G">中顶集<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V}"><semantics><annotation encoding="application/x-tex">{\displaystyle V}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af0f6064540e84211d0ffe4dac72098adfa52845" aria-hidden="true" alt="V">的大小称作图<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G}"><semantics><annotation encoding="application/x-tex">{\displaystyle G}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G">的阶。</li><li><b>子图</b>（Sub-Graph）：图<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G'}"><semantics><annotation encoding="application/x-tex">{\displaystyle G'}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/76634fad5818a777669a77cd8c86d1d816e4c402" aria-hidden="true" alt="G'">称作图<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G}"><semantics><annotation encoding="application/x-tex">{\displaystyle G}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G">的子图如果<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V(G')\subseteq V(G)}"><semantics><annotation encoding="application/x-tex">{\displaystyle V(G')\subseteq V(G)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/891fb720a69d0a46e52afac0431cca23c0a98e92" aria-hidden="true" alt="V(G')\subseteq V(G)">以及<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle E(G')\subseteq E(G)}"><semantics><annotation encoding="application/x-tex">{\displaystyle E(G')\subseteq E(G)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b39363db01c9e8c25725744bd91f6b729a2f7ab7" aria-hidden="true" alt="E(G')\subseteq E(G)">。</li><li><b>生成子图</b>（Spanning Sub-Graph）：指满足条件<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle V(G')=V(G)}"><semantics><annotation encoding="application/x-tex">{\displaystyle V(G')=V(G)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5df43d4e3cc0c494da305059a52737a32defd991" aria-hidden="true" alt="V(G')=V(G)">的<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G}"><semantics><annotation encoding="application/x-tex">{\displaystyle G}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f5f3c8921a3b352de45446a6789b104458c9f90b" aria-hidden="true" alt="G">的子图<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle G'}"><semantics><annotation encoding="application/x-tex">{\displaystyle G'}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/76634fad5818a777669a77cd8c86d1d816e4c402" aria-hidden="true" alt="G'">。</li></ul></h3> ",
            "assembleText":"阶（Order）：图 {\displaystyle G}中顶集 {\displaystyle V}的大小称作图 {\displaystyle G}的阶。 子图（Sub-Graph）：图 {\displaystyle G'}称作图 {\displaystyle G}的子图如果 {\displaystyle V(G')\subseteq V(G)}以及 {\displaystyle E(G')\subseteq E(G)}。 生成子图（Spanning Sub-Graph）：指满足条件 {\displaystyle V(G')=V(G)}的 {\displaystyle G}的子图 {\displaystyle G'}。",
            "assembleScratchTime":"2019-03-21 20:18:10",
            "facetId":557668,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863504,
            "assembleContent":"<h3><ul><li><ul><li><b>度</b>（Degree）：一个顶点的度是指与该顶点相关联的总边数，顶点<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v}"><semantics><annotation encoding="application/x-tex">{\displaystyle v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597" aria-hidden="true" alt="v">的度记作<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle d(v)}"><semantics><annotation encoding="application/x-tex">{\displaystyle d(v)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a957838fc14ceeffef8dc6ba66fad2680cae3656" aria-hidden="true" alt="d(v)">。度和边有如下关系：<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle \sum _{v\in V}d(v)=2\left|E\right|}"><semantics><annotation encoding="application/x-tex">{\displaystyle \sum _{v\in V}d(v)=2\left|E\right|}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3135ba94ea6fdaca02cf88a156b9f2bdaae6d546" aria-hidden="true" alt="\sum_{v\in V} d(v)=2\left|E\right|">。</li><li><b>出度</b>（Out-degree）和<b>入度</b>（In-degree）：对有向图而言，顶点的度还可分为出度和入度。一个顶点的出度为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle d_{o}}"><semantics><annotation encoding="application/x-tex">{\displaystyle d_{o}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db086c421821a5de9a49de753a122c28ad4233c9" aria-hidden="true" alt="d_o">，是指有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle d_{o}}"><semantics><annotation encoding="application/x-tex">{\displaystyle d_{o}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db086c421821a5de9a49de753a122c28ad4233c9" aria-hidden="true" alt="d_o">条边以该顶点为起点，或说与该点关联的出边共有<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle d_{o}}"><semantics><annotation encoding="application/x-tex">{\displaystyle d_{o}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/db086c421821a5de9a49de753a122c28ad4233c9" aria-hidden="true" alt="d_o">条。入度的概念也类似。</li></ul></li></ul></h3> ",
            "assembleText":"度（Degree）：一个顶点的度是指与该顶点相关联的总边数，顶点 {\displaystyle v}的度记作 {\displaystyle d(v)}。度和边有如下关系： {\displaystyle \sum _{v\in V}d(v)=2\left|E\right|}。 出度（Out-degree）和入度（In-degree）：对有向图而言，顶点的度还可分为出度和入度。一个顶点的出度为 {\displaystyle d_{o}}，是指有 {\displaystyle d_{o}}条边以该顶点为起点，或说与该点关联的出边共有 {\displaystyle d_{o}}条。入度的概念也类似。",
            "assembleScratchTime":"2019-03-21 20:18:18",
            "facetId":557668,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863505,
            "assembleContent":"<h3><div><ul><li><b>自环</b>（Loop）：若一条边的两个顶点相同，则此边称作自环。</li><li><b>路径</b>（Path）：从顶点u到顶点v的一条路径是指一个序列<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{0},e_{1},v_{1},e_{2},v_{2},...e_{k},v_{k}}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{0},e_{1},v_{1},e_{2},v_{2},...e_{k},v_{k}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2fc75ab7becb8860fd3229d274ab29a278bb54ee" aria-hidden="true" alt="v_0,e_1,v_1,e_2,v_2,...e_k,v_k">，<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle e_{i}}"><semantics><annotation encoding="application/x-tex">{\displaystyle e_{i}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ebdc3a9cb1583d3204eff8918b558c293e0d2cf3" aria-hidden="true" alt="e_i">的起点终点为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{i-1}}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{i-1}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f64987f4447177f86c030062509a3aee2a8db2cf" aria-hidden="true" alt="v_{i-1}">及<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{i}}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{i}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7dffe5726650f6daac54829972a94f38eb8ec127" aria-hidden="true" alt="v_i">；<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle k}"><semantics><annotation encoding="application/x-tex">{\displaystyle k}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40" aria-hidden="true" alt="k">称作路径的长度；<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{0}=u}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{0}=u}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc356ed7e6efc0db9627bf39d2eb1ddeff4220e7" aria-hidden="true" alt="v_0=u">，称为路径的起点；<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{k}=v}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{k}=v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/bff146d3586688f830168e4ec48759f5a8028055" aria-hidden="true" alt="v_k=v">，称为路径的终点。如果<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u=v}"><semantics><annotation encoding="application/x-tex">{\displaystyle u=v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2c14384063d79ad3532fd37aecc8616441da4631" aria-hidden="true" alt="u=v">，称该路径是<b>闭</b>的，反之则称为<b>开</b>的；如果<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v_{1},...,v_{k}}"><semantics><annotation encoding="application/x-tex">{\displaystyle v_{1},...,v_{k}}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7325d3c64ff3e21b0e2339c771d3f4f072c0f445" aria-hidden="true" alt="v_1,...,v_k">两两不等，则称之为<b>简单路径</b>（Simple path，注意，<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u=v}"><semantics><annotation encoding="application/x-tex">{\displaystyle u=v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2c14384063d79ad3532fd37aecc8616441da4631" aria-hidden="true" alt="u=v">是允许的）。</li></ul></div></h3> ",
            "assembleText":"自环（Loop）：若一条边的两个顶点相同，则此边称作自环。 路径（Path）：从顶点u到顶点v的一条路径是指一个序列 {\displaystyle v_{0},e_{1},v_{1},e_{2},v_{2},...e_{k},v_{k}}， {\displaystyle e_{i}}的起点终点为 {\displaystyle v_{i-1}}及 {\displaystyle v_{i}}； {\displaystyle k}称作路径的长度； {\displaystyle v_{0}=u}，称为路径的起点； {\displaystyle v_{k}=v}，称为路径的终点。如果 {\displaystyle u=v}，称该路径是闭的，反之则称为开的；如果 {\displaystyle v_{1},...,v_{k}}两两不等，则称之为简单路径（Simple path，注意， {\displaystyle u=v}是允许的）。",
            "assembleScratchTime":"2019-03-21 20:18:30",
            "facetId":557668,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE",
            "type":"text"
        },
        {
            "assembleId":2863506,
            "assembleContent":"<h3><div><ul><li><b>行迹</b>（Trace）：如果路径<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle P(u,v)}"><semantics><annotation encoding="application/x-tex">{\displaystyle P(u,v)}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d1907575621f37047c6519882a7e47c5da7391b2" aria-hidden="true" alt="P(u,v)">中边各不相同，则该路径称为<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle u}"><semantics><annotation encoding="application/x-tex">{\displaystyle u}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c3e6bb763d22c20916ed4f0bb6bd49d7470cffd8" aria-hidden="true" alt="u">到<math xmlns="http://www.w3.org/1998/Math/MathML" alttext="{\displaystyle v}"><semantics><annotation encoding="application/x-tex">{\displaystyle v}</annotation></semantics></math><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e07b00e7fc0847fbd16391c778d65bc25c452597" aria-hidden="true" alt="v">的一条行迹。</li><li><b>轨道</b>（Track）：即简单路径。</li><li>闭的行迹称作<b>回路</b>（Circuit），闭的轨道称作<b>圈</b>（Cycle）。（现存文献中的命名法并无统一标准。比如在另一种定义中，walk对应上述的path，path对应上述的track，trail对应上述的trace。）</li></ul></div></h3> ",
            "assembleText":"行迹（Trace）：如果路径 {\displaystyle P(u,v)}中边各不相同，则该路径称为 {\displaystyle u}到 {\displaystyle v}的一条行迹。 轨道（Track）：即简单路径。 闭的行迹称作回路（Circuit），闭的轨道称作圈（Cycle）。（现存文献中的命名法并无统一标准。比如在另一种定义中，walk对应上述的path，path对应上述的track，trail对应上述的trace。）",
            "assembleScratchTime":"2019-03-21 20:18:49",
            "facetId":557668,
            "sourceId":1,
            "domainId":413,
            "url":"https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)#%E6%9C%AF%E8%AF%AD",
            "type":"text"
        },
        {
            "assembleId":2863648,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><p>一个图中的元素有很多，例如：</p><blockquote><p>完全图，邻接节点，结点的度，路径，权，路径长度，子图，连通图和强连通图，生成树，简单路径和回路...</p></blockquote></div></div></div></dt></h2>   ",
            "assembleText":"一个图中的元素有很多，例如： 完全图，邻接节点，结点的度，路径，权，路径长度，子图，连通图和强连通图，生成树，简单路径和回路...",
            "assembleScratchTime":"2019-03-22 16:54:11",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863654,
            "assembleContent":"<h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><p>一个结点的邻接节点，对于无向图来说，就是与这个结点相连的结点，至少有一个。</p><p>对于有向图来说，由于边是有方向的，所以一个结点的邻接节点是指以这个结点为开头，所指向的那些结点。</p></div></div></div></dt></h2>   ",
            "assembleText":"一个结点的邻接节点，对于无向图来说，就是与这个结点相连的结点，至少有一个。 对于有向图来说，由于边是有方向的，所以一个结点的邻接节点是指以这个结点为开头，所指向的那些结点。",
            "assembleScratchTime":"2019-03-22 17:00:27",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863655,
            "assembleContent":"<h3>结点的度</h3><h2><dt><div label-module="para"><div label-module="para"><div label-module="para"><div><div>
<p>度是针对结点来说的， 又分为出度和入度，看到“出度入度”，我们不难想到这是与边和边的方向有关的。<br>
对于无向图来说，没有出度入度之分，一个结点的度就是经过这个结点的边的数目(或者是与这个结点相关联的边的数目)，对于有向图来说，出度就是指以这个结点为起始的边的条数（箭头向外），入度则是以这个点为终点的边的条数（箭头向内）。</p>
<p><strong>出 = 箭头向外，入 = 箭头向内</strong></p></div><br><br>作者：beanlam<br>链接：https://www.jianshu.com/p/a47a147ec92c<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></div></div></div></dt></h2>   ",
            "assembleText":"结点的度 度是针对结点来说的， 又分为出度和入度，看到“出度入度”，我们不难想到这是与边和边的方向有关的。 对于无向图来说，没有出度入度之分，一个结点的度就是经过这个结点的边的数目(或者是与这个结点相关联的边的数目)，对于有向图来说，出度就是指以这个结点为起始的边的条数（箭头向外），入度则是以这个点为终点的边的条数（箭头向内）。 出 = 箭头向外，入 = 箭头向内 作者：beanlam 链接：https://www.jianshu.com/p/a47a147ec92c 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-22 17:01:58",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863656,
            "assembleContent":"<h3>权</h3><h3><p>权是指一条边所附带的数据信息，比如说一个结点到另一个结点的距离，或者花费的时间等等都可以用权来表示。带权的图也称为网格或网。</p></h3>   ",
            "assembleText":"权 权是指一条边所附带的数据信息，比如说一个结点到另一个结点的距离，或者花费的时间等等都可以用权来表示。带权的图也称为网格或网。",
            "assembleScratchTime":"2019-03-22 17:02:06",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863657,
            "assembleContent":"<h3>子图</h3><h3><p>跟一个集合有子集一样，图也有子图。可以类比理解。</p></h3>   ",
            "assembleText":"子图 跟一个集合有子集一样，图也有子图。可以类比理解。",
            "assembleScratchTime":"2019-03-22 17:02:13",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/a47a147ec92c",
            "type":"text"
        },
        {
            "assembleId":2863675,
            "assembleContent":"<ol start="4"><li>度数与边数<br>握手定理：在任何无向图中，所有顶点的度数之和等于边数的2倍。<br>在任何有向图中，所有顶点的度数之和等于边数的2倍；所有顶点的入度之和等于所有顶点的出度之和，都等于边数。</li></ol> ",
            "assembleText":"度数与边数 握手定理：在任何无向图中，所有顶点的度数之和等于边数的2倍。 在任何有向图中，所有顶点的度数之和等于边数的2倍；所有顶点的入度之和等于所有顶点的出度之和，都等于边数。",
            "assembleScratchTime":"2019-03-22 17:13:55",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863777,
            "assembleContent":"<ol start="7"><li>图的同构<br>至今还没找到判断两个图是否同构的便于检查的充要条件。显然阶数相同、边数相同、度数列相同等等都是必要条件。</li></ol> ",
            "assembleText":"图的同构 至今还没找到判断两个图是否同构的便于检查的充要条件。显然阶数相同、边数相同、度数列相同等等都是必要条件。",
            "assembleScratchTime":"2019-03-22 23:08:10",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863779,
            "assembleContent":"<ol start="7"><li>生成子图<br>如果一个图的顶点集合和边集合都是另一个图的子集，则该图为另一个图的子图。如果子图的顶点集合等于母图的顶点集合，则称该子图为生成子图。</li></ol> ",
            "assembleText":"生成子图 如果一个图的顶点集合和边集合都是另一个图的子集，则该图为另一个图的子图。如果子图的顶点集合等于母图的顶点集合，则称该子图为生成子图。",
            "assembleScratchTime":"2019-03-22 23:08:22",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863782,
            "assembleContent":"<p>补图</p><p>设G是n阶无向简单图，G的补图的顶点集合与G相同，不过边集合为G的边集合的补。如果G和G的补图同构，则称G为自补图。</p> ",
            "assembleText":"补图 设G是n阶无向简单图，G的补图的顶点集合与G相同，不过边集合为G的边集合的补。如果G和G的补图同构，则称G为自补图。",
            "assembleScratchTime":"2019-03-22 23:08:47",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863785,
            "assembleContent":"<p>通路与回路</p><ul><li>设G是无向标定图，G中顶点与边的交替序列称为通路</li><li>若通路中始点和终点相同，则称为回路</li><li>若通路中所有边各异，则称为简单通路</li><li>若通路中所有顶点各异（除了始点和终点可能相同外），所有边也各异，则称为初级通路或路径</li><li>若路径中始点和终点相同，则称为初级回路或圈</li></ul> ",
            "assembleText":"通路与回路 设G是无向标定图，G中顶点与边的交替序列称为通路 若通路中始点和终点相同，则称为回路 若通路中所有边各异，则称为简单通路 若通路中所有顶点各异（除了始点和终点可能相同外），所有边也各异，则称为初级通路或路径 若路径中始点和终点相同，则称为初级回路或圈",
            "assembleScratchTime":"2019-03-22 23:09:10",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863787,
            "assembleContent":"<ol start="12"><li>连通性<br>若无向图G是平凡图或G中任何两个顶点都是连通的，则称G为连通图，否则称为非连通图。</li></ol> ",
            "assembleText":"连通性 若无向图G是平凡图或G中任何两个顶点都是连通的，则称G为连通图，否则称为非连通图。",
            "assembleScratchTime":"2019-03-22 23:09:21",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863789,
            "assembleContent":"<ol start="12"><li>可达<br>设D是一个有向图，若任意两个顶点Vi，Vj之间存在通路，则称Vi可达Vj；</li></ol><ul><li>若有向图D的基图是连通图，则称D是弱连通图</li><li>若有向图D中任意两个顶点Vi，Vj，存在Vi可达Vj或者Vj可达Vi，则称D为单向连通图</li><li>若有向图D中任意两个顶点之间相互可达，则称D为强连通图</li></ul> ",
            "assembleText":"可达 设D是一个有向图，若任意两个顶点Vi，Vj之间存在通路，则称Vi可达Vj； 若有向图D的基图是连通图，则称D是弱连通图 若有向图D中任意两个顶点Vi，Vj，存在Vi可达Vj或者Vj可达Vi，则称D为单向连通图 若有向图D中任意两个顶点之间相互可达，则称D为强连通图",
            "assembleScratchTime":"2019-03-22 23:09:37",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863791,
            "assembleContent":"<p>定理<br>有向图D是强连通图当且仅当D中存在经过每个顶点至少一次的回路<br>有向图D是单向连通图当且仅当D中存在经过每个顶点至少一次的通路  <br></p> ",
            "assembleText":"定理 有向图D是强连通图当且仅当D中存在经过每个顶点至少一次的回路 有向图D是单向连通图当且仅当D中存在经过每个顶点至少一次的通路  ",
            "assembleScratchTime":"2019-03-22 23:09:57",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863793,
            "assembleContent":"<p>二部图</p><div><div>
<ul>
<li>若无向图G的顶点集V可划分为V1和V2（V1∪V2=V，V1∩V2=∅，<br>
V1≠∅，V2≠∅），使得G中的每条边的两个端点都是一个属于V1，一个属于V2，则称G为二部图（二分图），常将二部图记为<V1，V2，E>.</li>
<li>若G是简单二部图，V1中每个顶点均与V2中所有顶点相邻，则称G为完全二部图.</li>
<li>n(n≥2)阶零图都是二部图</li>
<li>n(n≥2)阶无向图G是二部图当且仅当G中无奇圈（长度为奇数的圈）</li></ul></div><br><br>作者：zizhan<br>链接：https://www.jianshu.com/p/d761bdc76bf7<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div> ",
            "assembleText":"二部图 若无向图G的顶点集V可划分为V1和V2（V1∪V2=V，V1∩V2=∅， V1≠∅，V2≠∅），使得G中的每条边的两个端点都是一个属于V1，一个属于V2，则称G为二部图（二分图），常将二部图记为<V1，V2，E>. 若G是简单二部图，V1中每个顶点均与V2中所有顶点相邻，则称G为完全二部图. n(n≥2)阶零图都是二部图 n(n≥2)阶无向图G是二部图当且仅当G中无奇圈（长度为奇数的圈） 作者：zizhan 链接：https://www.jianshu.com/p/d761bdc76bf7 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-22 23:10:24",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863798,
            "assembleContent":"<div><li>无向图G是欧拉图当且仅当G是连通图且没有奇度顶点。</li>
<li>无向图G是半欧拉图当且仅当G是连通的且恰有两个奇度顶点。</li>
<li>有向图D是欧拉图当且仅当D是强连通的且每个顶点的入度等于出度</li>
<li>有向图D是半欧拉图当且仅当D是单向连通的且恰有两个奇度顶点，其中一个顶点的入度比出度大1，另一个顶点的出度比入度大1，而其余顶点的入度等于出度</li>
<li>G是非平凡的欧拉图当且仅当G是连通的且是若干个边不重的圈的并</li></div><br><br> ",
            "assembleText":"无向图G是欧拉图当且仅当G是连通图且没有奇度顶点。 无向图G是半欧拉图当且仅当G是连通的且恰有两个奇度顶点。 有向图D是欧拉图当且仅当D是强连通的且每个顶点的入度等于出度 有向图D是半欧拉图当且仅当D是单向连通的且恰有两个奇度顶点，其中一个顶点的入度比出度大1，另一个顶点的出度比入度大1，而其余顶点的入度等于出度 G是非平凡的欧拉图当且仅当G是连通的且是若干个边不重的圈的并",
            "assembleScratchTime":"2019-03-22 23:12:11",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/d761bdc76bf7",
            "type":"text"
        },
        {
            "assembleId":2863825,
            "assembleContent":"<div><h2>随机图</h2>
<p>随机图就像它的名字一样：一个随机生成的节点和边的图。当然，有许多随机过程可以生成图，所以有许多种类的随机图。</p>
<p>其中一个更有趣的是 Erdős-Rényi 模型，PaulErdős 和 AlfrédRényi 在 20 世纪 60 年代研究过它。</p>
<p>Erdős-Rényi 图（ER 图）的特征在于两个参数：<code>n</code>是节点的数量，<code>p</code>是任何两个节点之间存在边的概率。</p></div><br><br> ",
            "assembleText":"随机图 随机图就像它的名字一样：一个随机生成的节点和边的图。当然，有许多随机过程可以生成图，所以有许多种类的随机图。 其中一个更有趣的是 Erdős-Rényi 模型，PaulErdős 和 AlfrédRényi 在 20 世纪 60 年代研究过它。 Erdős-Rényi 图（ER 图）的特征在于两个参数：n是节点的数量，p是任何两个节点之间存在边的概率。",
            "assembleScratchTime":"2019-03-22 23:20:25",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863826,
            "assembleContent":"<h2><div><p>Erdős 和 Rényi 研究了随机图的属性；其令人惊奇的结果之一就是，随着随机的边被添加，随机图的属性会突然变化。</p>
<p>展示这类转变的一个属性是连通性。如果每个节点到每个其他节点都存在路径，那么无向图是连通的。</p>
<p>在 ER 图中，当<code>p</code>较小时，图是连通图的概率非常低，而<code>p</code>较大时接近<code>1</code>。在这两种状态之间，在<code>p</code>的特定值处存在快速转变，表示为<code>p*</code>。</p>
<p>Erdős 和 Rényi 表明，这个临界值是<code>p* = lnn / n</code>，其中<code>n</code>是节点数。如果<code>p < p*</code>，随机图<code>G(n, p)</code>不太可能连通，并且如果<code>p > p*</code>，则很可能连通。</p></div><br></h2> ",
            "assembleText":"Erdős 和 Rényi 研究了随机图的属性；其令人惊奇的结果之一就是，随着随机的边被添加，随机图的属性会突然变化。 展示这类转变的一个属性是连通性。如果每个节点到每个其他节点都存在路径，那么无向图是连通的。 在 ER 图中，当p较小时，图是连通图的概率非常低，而p较大时接近1。在这两种状态之间，在p的特定值处存在快速转变，表示为p*。 Erdős 和 Rényi 表明，这个临界值是p* = lnn / n，其中n是节点数。如果p < p*，随机图G(n, p)不太可能连通，并且如果p > p*，则很可能连通。",
            "assembleScratchTime":"2019-03-22 23:20:52",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/919d16649563",
            "type":"text"
        },
        {
            "assembleId":2863970,
            "assembleContent":"<h2>有向边和无向边</h2><h2><div>
<p>边，根据是否有方向，分为无向边和有向边。无向边指顶点v<sub>i</sub>到v<sub>j</sub>之间的边没有方向，用(v<sub>i</sub>, v<sub>j</sub>)表示。有向边指顶点v<sub>i</sub>到v<sub>j</sub>之间的边有方向，也称作弧，用<v<sub>i</sub>, v<sub>j</sub>>表示，其中v<sub>i</sub>称为弧尾或初始点，v<sub>j</sub>称为弧头或终端点，也就是箭头从v<sub>i</sub>指向v<sub>j</sub>，顺序不能交换。如下图所示，左边的图都是无向边，右边的图都是有向边：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-6a5563914cbf35f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/546/format/webp"></div>
</div>
<div>边的分类</div>
</div>
<p>左图可以表示为G<sub>1</sub> = (V<sub>1</sub>, {E<sub>1</sub>})，其中顶点集合V<sub>1</sub>={A, B, C, D}，边集合E<sub>1</sub>={(A, B), (B, C), (C, D), (D, A), (A, C)}。右图可以表示为G<sub>2</sub> = (V<sub>2</sub>, {E<sub>2</sub>})，其中顶点集合V<sub>2</sub>={A, B, C, D}，弧集合E<sub>2</sub>={<A, B>, <B, C>, <C, A>, <A, D>}。</p></div><br></h2> ",
            "assembleText":"有向边和无向边 边，根据是否有方向，分为无向边和有向边。无向边指顶点vi到vj之间的边没有方向，用(vi, vj)表示。有向边指顶点vi到vj之间的边有方向，也称作弧，用<vi, vj>表示，其中vi称为弧尾或初始点，vj称为弧头或终端点，也就是箭头从vi指向vj，顺序不能交换。如下图所示，左边的图都是无向边，右边的图都是有向边： 边的分类 左图可以表示为G1 = (V1, {E1})，其中顶点集合V1={A, B, C, D}，边集合E1={(A, B), (B, C), (C, D), (D, A), (A, C)}。右图可以表示为G2 = (V2, {E2})，其中顶点集合V2={A, B, C, D}，弧集合E2={<A, B>, <B, C>, <C, A>, <A, D>}。",
            "assembleScratchTime":"2019-03-23 20:47:56",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863976,
            "assembleContent":"<h2>子图</h2><h2><p>假设有两个图G=(V, {E})和G'=(V', {E'})，如果V'∈V且E'属于E，则称G'为G的子图。简言之，就是部分与整体的关系。</p></h2> ",
            "assembleText":"子图 假设有两个图G=(V, {E})和G'=(V', {E'})，如果V'∈V且E'属于E，则称G'为G的子图。简言之，就是部分与整体的关系。",
            "assembleScratchTime":"2019-03-23 20:49:53",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863979,
            "assembleContent":"<h2>路径</h2><h2><div><div><div>
<p>无向图G=(V, {E})中从顶点 v 到 v' 的路径是一个顶点序列(v=v<sub>i,0</sub>,v<sub>i,1</sub>,...,v<sub>i,m</sub>=v')，其中(v<sub>i,j-1</sub>,v<sub>i,j</sub>)∈E，1≤j≤m。</p>
<p>如果是有向图，则路径也是有向的，顶点序列满足<v<sub>i,j-1</sub>, v<sub>i,j</sub>>∈E，1≤j≤m。</p>
<p>路径的长度是路径上的边或弧的数目。</p></div><br><br>作者：大大纸飞机<br>链接：https://www.jianshu.com/p/9b263135be59<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></div></h2> ",
            "assembleText":"路径 无向图G=(V, {E})中从顶点 v 到 v' 的路径是一个顶点序列(v=vi,0,vi,1,...,vi,m=v')，其中(vi,j-1,vi,j)∈E，1≤j≤m。 如果是有向图，则路径也是有向的，顶点序列满足<vi,j-1, vi,j>∈E，1≤j≤m。 路径的长度是路径上的边或弧的数目。 作者：大大纸飞机 链接：https://www.jianshu.com/p/9b263135be59 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 20:51:28",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863980,
            "assembleContent":"<h2><p>第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。</p><br></h2> ",
            "assembleText":"第一个顶点到最后一个顶点相同的路径称为回路或环。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。",
            "assembleScratchTime":"2019-03-23 20:51:35",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863992,
            "assembleContent":"<h3>网</h3><h3><p>因为网的每条边都有权值，所以对应的公式稍有改变，如下所示：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-177de54d9137d5cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/360/format/webp"></div></div><div>网的邻接矩阵</div></div><p>这里∞表示的是不可能出现的值。</p></h3>  ",
            "assembleText":"网 因为网的每条边都有权值，所以对应的公式稍有改变，如下所示： 网的邻接矩阵 这里∞表示的是不可能出现的值。",
            "assembleScratchTime":"2019-03-23 20:55:25",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864068,
            "assembleContent":"<h4>图（Graph）</h4><h2><div><div><ul><li>
</li>
</ul>
<p>在图中的数据元素，我们称之为顶点（Vertex）<br>
1.按方向分，图可分为有向图，无向图。<br>
无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。<br>
图上的边或弧带有权则称为网。<br>
2.按边或弧的个数大小，图可分为稀疏图和稠密图。<br>
如果图中的任意两个顶点之间都存在边叫做完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。</p></div><br><br>作者：Nancy_Shi<br>链接：https://www.jianshu.com/p/1ceddc896da2<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h2>   ",
            "assembleText":"图（Graph） 在图中的数据元素，我们称之为顶点（Vertex） 1.按方向分，图可分为有向图，无向图。 无向图由顶点和边组成，有向图由顶点和弧构成。弧有弧尾和弧头之分，带箭头一端为弧头。 图上的边或弧带有权则称为网。 2.按边或弧的个数大小，图可分为稀疏图和稠密图。 如果图中的任意两个顶点之间都存在边叫做完全图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。 作者：Nancy_Shi 链接：https://www.jianshu.com/p/1ceddc896da2 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:29:30",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864074,
            "assembleContent":"<h4>度</h4><h4><ul><li></li></ul><p>顶点（v)的度（Degree）是和v相关联的边的数目（可分为入度，出度）</p></h4><h6>公式：总边数=1/2总度数</h6>   ",
            "assembleText":"度 顶点（v)的度（Degree）是和v相关联的边的数目（可分为入度，出度） 公式：总边数=1/2总度数",
            "assembleScratchTime":"2019-03-23 21:30:15",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864075,
            "assembleContent":"<ul><li><h4>路径</h4></li></ul><p>简单路径：序列中顶点不重复出现的路径。<br>环（回路）:第一个顶点和最后一个顶点有相同的路径。<br>若 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，可叫做简单回路（环）。</p> ",
            "assembleText":"路径 简单路径：序列中顶点不重复出现的路径。 环（回路）:第一个顶点和最后一个顶点有相同的路径。 若 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，可叫做简单回路（环）。",
            "assembleScratchTime":"2019-03-23 21:30:26",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864077,
            "assembleContent":"<div><div><ul><li><h4>连通分量</h4>
</li>
</ul>
<p>指的是无向图中的极大连通子图。<br>
极大连通子图的条件就是：1.是子图。2.尽可能大（emmm这不废话吗...）<br>
强连通图：每一个顶点都有进有出。<br>
强连通分量：有向图的极大强连通子图。<br>
生成树：极小连通子图。<br>
一颗有n个顶点的生成树有且仅有n-1条边<br>
若小于n-1：非连通图<br>
若大于n-1，则一定有回路（环）</p></div><br><br>作者：Nancy_Shi<br>链接：https://www.jianshu.com/p/1ceddc896da2<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div> ",
            "assembleText":"连通分量 指的是无向图中的极大连通子图。 极大连通子图的条件就是：1.是子图。2.尽可能大（emmm这不废话吗...） 强连通图：每一个顶点都有进有出。 强连通分量：有向图的极大强连通子图。 生成树：极小连通子图。 一颗有n个顶点的生成树有且仅有n-1条边 若小于n-1：非连通图 若大于n-1，则一定有回路（环） 作者：Nancy_Shi 链接：https://www.jianshu.com/p/1ceddc896da2 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:30:41",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864103,
            "assembleContent":"<ul><li><h6>最小生成树的概念</h6></li></ul><p>（1）一个带权值的图：网。所谓最小成本，就是用n-1条边把n个顶点连接起来，且连接起来的权值最小。<br>（2）我们把构造联通网的最小代价生成树称为最小生成树<br>（3）普里姆算法和克鲁斯卡尔算法</p> ",
            "assembleText":"最小生成树的概念 （1）一个带权值的图：网。所谓最小成本，就是用n-1条边把n个顶点连接起来，且连接起来的权值最小。 （2）我们把构造联通网的最小代价生成树称为最小生成树 （3）普里姆算法和克鲁斯卡尔算法",
            "assembleScratchTime":"2019-03-23 21:36:16",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864104,
            "assembleContent":"<ul><li><h6>普里姆算法</h6><h6><div><div><ul><li>
</li>
</ul>
<p>如下图，普利姆的最小生成树过程为：用Vs存储已经遍历的点，用Es存储已经遍历的边</p>
<br>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/12340137-62bf185b93fc9588.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/279/format/webp"></div>
</div>
<div>图片.png</div>
</div><br>
<p>（1）选择D为起点，加入Vs，与D连接的边中，权值最小的边为5，连接的点为A，因此将A加入到Vs，路径DA加入到Es。<br>
（2）此时Vs中存在D和A。与DA连接的边中，权值最小的为6，连接的点为F，因此F加入到Vs，边DF加入到Es。<br>
（3）此时Vs中存在DAF，与DAF连接的边中最小权值为7，连接的点为B，因此B加入Vs，路径AB加入Es<br>
（4）重复以上过程，知道Vs中加入了所有的点</p></div><br><br>作者：Nancy_Shi<br>链接：https://www.jianshu.com/p/1ceddc896da2<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h6></li></ul> ",
            "assembleText":"普里姆算法 如下图，普利姆的最小生成树过程为：用Vs存储已经遍历的点，用Es存储已经遍历的边 图片.png （1）选择D为起点，加入Vs，与D连接的边中，权值最小的边为5，连接的点为A，因此将A加入到Vs，路径DA加入到Es。 （2）此时Vs中存在D和A。与DA连接的边中，权值最小的为6，连接的点为F，因此F加入到Vs，边DF加入到Es。 （3）此时Vs中存在DAF，与DAF连接的边中最小权值为7，连接的点为B，因此B加入Vs，路径AB加入Es （4）重复以上过程，知道Vs中加入了所有的点 作者：Nancy_Shi 链接：https://www.jianshu.com/p/1ceddc896da2 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:36:28",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864109,
            "assembleContent":"<div><div><ul><li><h6>克鲁斯卡尔算法</h6>
</li>
</ul>
<p>克鲁斯卡尔算法从边的集合中挑选权值最小的，加入到选择的边集合中。如果这条边，予以选择的边构成了回路，则舍弃这条边。<br>
如下图所示，克鲁斯卡尔的方法为：</p>
<br>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/12340137-e5e59d9008252099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp"></div>
</div>
<div>图片.png</div>
</div><br>
<p>（1）选择权值最小为7的边V7-V4<br>
（2）选择权值最小为8的边V2-V8<br>
（3）选择权值最小为10的边V1-V0<br>
（4）选择权值最小为11的边V0-V5<br>
（5）选择全职最小为12的边V1-V8,但是发现V1和V8全部是已经访问的点，所以会构成回路，舍弃<br>
（6）选择权值最小为16的边V1-V6<br>
（7）选择权值最小为16的边V3-V7</p></div><br><br>作者：Nancy_Shi<br>链接：https://www.jianshu.com/p/1ceddc896da2<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div> ",
            "assembleText":"克鲁斯卡尔算法 克鲁斯卡尔算法从边的集合中挑选权值最小的，加入到选择的边集合中。如果这条边，予以选择的边构成了回路，则舍弃这条边。 如下图所示，克鲁斯卡尔的方法为： 图片.png （1）选择权值最小为7的边V7-V4 （2）选择权值最小为8的边V2-V8 （3）选择权值最小为10的边V1-V0 （4）选择权值最小为11的边V0-V5 （5）选择全职最小为12的边V1-V8,但是发现V1和V8全部是已经访问的点，所以会构成回路，舍弃 （6）选择权值最小为16的边V1-V6 （7）选择权值最小为16的边V3-V7 作者：Nancy_Shi 链接：https://www.jianshu.com/p/1ceddc896da2 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:38:13",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864111,
            "assembleContent":"<ul><li><h6>1.普里姆算法的时间复杂度为O（n平方），与网中的边数无关，因此适用于求边稠密的网的最小生成树。<br>2.克鲁斯卡尔算法恰恰相反，时间复杂度为O(e loge) (其中e为网中边的数目），因此更适合求边稀疏的网的最小生成树。  <br></h6></li></ul> ",
            "assembleText":"1.普里姆算法的时间复杂度为O（n平方），与网中的边数无关，因此适用于求边稠密的网的最小生成树。 2.克鲁斯卡尔算法恰恰相反，时间复杂度为O(e loge) (其中e为网中边的数目），因此更适合求边稀疏的网的最小生成树。  ",
            "assembleScratchTime":"2019-03-23 21:38:25",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864401,
            "assembleContent":"<ul><li><h4><div><strong><code>有向图</code></strong>中，若图G中任意两个不同的顶点<code>vi</code>和<code>vj</code>，都存在从<code>vi</code>到<code>vj</code>以及从<code>vj</code>到<code>vi</code>的路径，则称G是<strong>强连通图</strong>。<br><strong>强连通图</strong>G的极大强连通子图称为G的<strong>强连通分量</strong>。  <br></div></h4></li></ul> ",
            "assembleText":"有向图中，若图G中任意两个不同的顶点vi和vj，都存在从vi到vj以及从vj到vi的路径，则称G是强连通图。 强连通图G的极大强连通子图称为G的强连通分量。  ",
            "assembleScratchTime":"2019-03-24 11:45:43",
            "facetId":557668,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/58caac025729",
            "type":"text"
        },
        {
            "assembleId":2864664,
            "assembleContent":"<p></p><h4>二部图</h4><h4><p>无向图G点集V可划分为{V1，V2}，使得V1中每个节点都不与V2中结点相邻，则称G为二部图</p><p>可知二部图：</p><ol><li>没有回路</li><li><p>或回路长度为偶数</p></li></ol></h4> ",
            "assembleText":"二部图 无向图G点集V可划分为{V1，V2}，使得V1中每个节点都不与V2中结点相邻，则称G为二部图 可知二部图： 没有回路 或回路长度为偶数",
            "assembleScratchTime":"2019-03-24 16:17:25",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/40bbe3939699",
            "type":"text"
        },
        {
            "assembleId":2864665,
            "assembleContent":"<p></p><h4><p><strong>完全二部图</strong>：V1,V2是简单二部图G的互补结点子集，V1中每个点与V2中每个点相邻。可以记作<code>$K_{m,n}$</code>,边数m*n，上图也是完全二部图，<code>$K_{3,3}$</code><br></p><div><div><br></div></div></h4> ",
            "assembleText":"完全二部图：V1,V2是简单二部图G的互补结点子集，V1中每个点与V2中每个点相邻。可以记作$K_{m,n}$,边数m*n，上图也是完全二部图，$K_{3,3}$",
            "assembleScratchTime":"2019-03-24 16:17:33",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/40bbe3939699",
            "type":"text"
        },
        {
            "assembleId":2864666,
            "assembleContent":"<p></p><h4><p><strong>二部图匹配问题</strong></p><ul><li>匹配</li><li>极大匹配</li><li>最大匹配:包含边数最多的那个匹配就是图G的最大匹配</li></ul></h4> ",
            "assembleText":"二部图匹配问题 匹配 极大匹配 最大匹配:包含边数最多的那个匹配就是图G的最大匹配",
            "assembleScratchTime":"2019-03-24 16:17:42",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/40bbe3939699",
            "type":"text"
        },
        {
            "assembleId":2864667,
            "assembleContent":"<p></p><h4><div><blockquote><p>求二部图的最大匹配可以使用最大流（maximal flow）或匈牙利算法（Hungarian algorithm）</p>
</blockquote>
<ul>
<li>匹配数：最大匹配包含的边数</li>
<li>最大匹配一定是极大匹配，但极大匹配不一定是最大匹配</li>
<li>无向图中可以有多个极大匹配和最大匹配</li>
<li>完美匹配:如果一个最大匹配中所有的点都有边与之相连，没有未覆盖点，则这个最大匹配就是完美匹配。</li></ul></div><br></h4> ",
            "assembleText":"求二部图的最大匹配可以使用最大流（maximal flow）或匈牙利算法（Hungarian algorithm） 匹配数：最大匹配包含的边数 最大匹配一定是极大匹配，但极大匹配不一定是最大匹配 无向图中可以有多个极大匹配和最大匹配 完美匹配:如果一个最大匹配中所有的点都有边与之相连，没有未覆盖点，则这个最大匹配就是完美匹配。",
            "assembleScratchTime":"2019-03-24 16:17:52",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/40bbe3939699",
            "type":"text"
        },
        {
            "assembleId":2865893,
            "assembleContent":"<h4>最小生成树(minimum spanning tree)</h4><p>(1)基本概念<br>生成树的概念：<br>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。<br>最小生成树的概念：<br>带权连通图中代价最小的生成树。</p>  ",
            "assembleText":"最小生成树(minimum spanning tree) (1)基本概念 生成树的概念： 一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树的概念： 带权连通图中代价最小的生成树。",
            "assembleScratchTime":"2019-03-24 22:53:04",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/424a37c3dd4c",
            "type":"text"
        },
        {
            "assembleId":2865895,
            "assembleContent":"<h4>构造最小生成树的算法有许多，基本原则是：<br>尽可能选取权值最小的边，但不能构成回路；<br>选取n-1条边构成最小生成树。  <br></h4>  ",
            "assembleText":"构造最小生成树的算法有许多，基本原则是： 尽可能选取权值最小的边，但不能构成回路； 选取n-1条边构成最小生成树。  ",
            "assembleScratchTime":"2019-03-24 22:53:11",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/424a37c3dd4c",
            "type":"text"
        },
        {
            "assembleId":2865896,
            "assembleContent":"<h4><div>Prim算法<br>
假设 G=(V，E)为一网图，其中 V 为网图中所有顶点的集合，E 为网图中所有带权边的集合。设置两个新的集合 U 和 T，其中集合 U 用于存放 G 的最小生成树中的顶点， 集合 T 存放 G 的最小生成树中的边。令集合 U 的初值为 U={<img src="https://math.jianshu.com/math?formula=v_1" alt="v_1" mathimg="1">}(假设构造最小生成树时， 从顶点 <img src="https://math.jianshu.com/math?formula=v_1" alt="v_1" mathimg="1"> 出发)，集合 T 的初值为 T={}。</div><br><br></h4>  ",
            "assembleText":"Prim算法 假设 G=(V，E)为一网图，其中 V 为网图中所有顶点的集合，E 为网图中所有带权边的集合。设置两个新的集合 U 和 T，其中集合 U 用于存放 G 的最小生成树中的顶点， 集合 T 存放 G 的最小生成树中的边。令集合 U 的初值为 U={}(假设构造最小生成树时， 从顶点 出发)，集合 T 的初值为 T={}。",
            "assembleScratchTime":"2019-03-24 22:53:21",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/424a37c3dd4c",
            "type":"text"
        },
        {
            "assembleId":2865897,
            "assembleContent":"<h6>单源点最短路径 Dijkstra算法</h6><h4><div><p>对于给定的有向图G=(V,E)及单个源点<img src="https://math.jianshu.com/math?formula=v_s" alt="v_s" mathimg="1">，求<img src="https://math.jianshu.com/math?formula=v_s" alt="v_s" mathimg="1">到G的其即余各顶点的最短路径。<br>Dijkstra提出了一种按路径长度递增次序产生最短路径的算法， Dijkstra算法。</p></div></h4>  ",
            "assembleText":"单源点最短路径 Dijkstra算法 对于给定的有向图G=(V,E)及单个源点，求到G的其即余各顶点的最短路径。 Dijkstra提出了一种按路径长度递增次序产生最短路径的算法， Dijkstra算法。",
            "assembleScratchTime":"2019-03-24 22:53:39",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/424a37c3dd4c",
            "type":"text"
        },
        {
            "assembleId":2865898,
            "assembleContent":"<h6>Dijkstra算法基本思想：<br></h6><div><div>
从图中的给定源点到其它各个顶点之间客观上应存在一条最短路径，从这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。<br>
即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，以此类推，直到求出长度最长的最短路径。</div><br><br></div>  ",
            "assembleText":"Dijkstra算法基本思想： 从图中的给定源点到其它各个顶点之间客观上应存在一条最短路径，从这组最短路径中，按其长度的递增次序，依次求出到不同顶点的最短路径和路径长度。 即按长度递增的次序生成各顶点的最短路径，即先求出长度最小的一条最短路径，然后求出长度第二小的最短路径，以此类推，直到求出长度最长的最短路径。",
            "assembleScratchTime":"2019-03-24 22:53:54",
            "facetId":557668,
            "sourceId":3,
            "domainId":413,
            "url":"https://www.jianshu.com/p/424a37c3dd4c",
            "type":"text"
        },
        {
            "assembleId":2856980,
            "assembleContent":"<p><strong>邻接矩阵：</strong></p><p>　　邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。上图用邻接矩阵表示如下：</p><p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209221722904-1549384558.png" alt=""></p><p>　　1表示有边，0表示没有边，也可以用布尔变量true和false来表示。顶点与自身相连用 0 表示，所以这个矩阵从左上角到右上角的对角线全是 0 。</p><p>　　注意：这个矩阵的上三角是下三角的镜像，两个三角包含了相同的信息，这个冗余信息看似低效，但是在大多数计算机中，创造一个三角形数组比较困难，所以只好接受这个冗余，这也要求在程序处理中，当我们增加一条边时，比如更新邻接矩阵的两部分，而不是一部分。</p> ",
            "assembleText":"邻接矩阵： 　　邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。上图用邻接矩阵表示如下： 　　 　　1表示有边，0表示没有边，也可以用布尔变量true和false来表示。顶点与自身相连用 0 表示，所以这个矩阵从左上角到右上角的对角线全是 0 。 　　注意：这个矩阵的上三角是下三角的镜像，两个三角包含了相同的信息，这个冗余信息看似低效，但是在大多数计算机中，创造一个三角形数组比较困难，所以只好接受这个冗余，这也要求在程序处理中，当我们增加一条边时，比如更新邻接矩阵的两部分，而不是一部分。",
            "assembleScratchTime":"2019-03-03 19:37:09",
            "facetId":557720,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2856981,
            "assembleContent":"<p><strong>邻接表：</strong></p><p>　　邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。</p><p>　　<img src="https://images2017.cnblogs.com/blog/1120165/201802/1120165-20180209222328123-1963427649.png" alt=""></p> ",
            "assembleText":"邻接表： 　　邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。 　　",
            "assembleScratchTime":"2019-03-03 19:37:21",
            "facetId":557720,
            "sourceId":4,
            "domainId":413,
            "url":"https://www.cnblogs.com/ysocean/p/8032659.html#_label0_0",
            "type":"text"
        },
        {
            "assembleId":2863989,
            "assembleContent":"<h2>邻接矩阵</h2><h1><p>图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p><p>设G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-2cb678f96c7db85c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/337/format/webp"></div></div><div>邻接矩阵</div></div></h1>  ",
            "assembleText":"邻接矩阵 图的邻接矩阵（Adjacency Matrix）存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 设G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为： 邻接矩阵",
            "assembleScratchTime":"2019-03-23 20:54:26",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863990,
            "assembleContent":"<h3><br></h3><h2><div><div>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-ae502ecf1781dc95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/648/format/webp"></div>
</div>
<div>无向图的邻接矩阵</div>
</div>
<p>其中主对角线的值为0，表示顶点到其本身没有边。无向图的邻接矩阵一定是对称的，也就是以主对角线划分的右上方和左下方对称。从矩阵中我们可以获取以下信息：</p>
<ul>
<li>判断两个顶点之间是否有边</li>
<li>获取某个顶点的度，只需要求第 i 行或第 i 列的和即可。</li>
<li>获取某个顶点的所有临界点，只需要遍历第 i 行即可。</li></ul></div><br><br>作者：大大纸飞机<br>链接：https://www.jianshu.com/p/9b263135be59<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h2>  ",
            "assembleText":"无向图的邻接矩阵 其中主对角线的值为0，表示顶点到其本身没有边。无向图的邻接矩阵一定是对称的，也就是以主对角线划分的右上方和左下方对称。从矩阵中我们可以获取以下信息： 判断两个顶点之间是否有边 获取某个顶点的度，只需要求第 i 行或第 i 列的和即可。 获取某个顶点的所有临界点，只需要遍历第 i 行即可。 作者：大大纸飞机 链接：https://www.jianshu.com/p/9b263135be59 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 20:54:49",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863991,
            "assembleContent":"<h3><br></h3><h3><p>有向图的表示和无向图类似，如下所示：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-02f5077fd998d28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp"></div></div><div>有向图的邻接矩阵</div></div></h3>  ",
            "assembleText":"有向图的表示和无向图类似，如下所示： 有向图的邻接矩阵",
            "assembleScratchTime":"2019-03-23 20:55:00",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863993,
            "assembleContent":"<h3><p>网的邻接矩阵存储示例如下：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-be32ea4a2648c283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/630/format/webp"></div></div><div>网的邻接矩阵</div></div></h3>  ",
            "assembleText":"网的邻接矩阵存储示例如下： 网的邻接矩阵",
            "assembleScratchTime":"2019-03-23 20:55:34",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864079,
            "assembleContent":"<ul><li><h3>邻接矩阵</h3></li></ul><p>图的邻接矩阵的表示方式需要两个数组来表示图的信息，一个一维数组表示每个数据元素的信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。</p> ",
            "assembleText":"邻接矩阵 图的邻接矩阵的表示方式需要两个数组来表示图的信息，一个一维数组表示每个数据元素的信息，一个二维数组（邻接矩阵）表示图中的边或者弧的信息。",
            "assembleScratchTime":"2019-03-23 21:30:57",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864080,
            "assembleContent":"<div><p>如果图有n个顶点，那么邻接矩阵就是一个n*n的方阵，若考虑无向图的邻接矩阵的对称性，则可采用压缩存储的方式只存入矩阵的上三角（or下三角）元素。</p><br><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/12340137-0c19452082dc6668.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/341/format/webp"></div></div><div>图片.png</div></div><br></div> ",
            "assembleText":"如果图有n个顶点，那么邻接矩阵就是一个n*n的方阵，若考虑无向图的邻接矩阵的对称性，则可采用压缩存储的方式只存入矩阵的上三角（or下三角）元素。 图片.png",
            "assembleScratchTime":"2019-03-23 21:31:13",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864081,
            "assembleContent":"<div><p>对于有权值的网，二维数组中的元素不再是0,1表示是否存在边，而是把元素值表示为权值。不存在的边，权值记录为∞；对角线上的权值为0.</p><p><br></p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/12340137-9beb02f052ff4a85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623/format/webp"></div></div><div>图片.png</div></div></div> ",
            "assembleText":"对于有权值的网，二维数组中的元素不再是0,1表示是否存在边，而是把元素值表示为权值。不存在的边，权值记录为∞；对角线上的权值为0. 图片.png",
            "assembleScratchTime":"2019-03-23 21:31:24",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864084,
            "assembleContent":"<p>邻接矩阵优缺点：<br>优点：<br>直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。<br>缺点：<br>当我么表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。  <br></p> ",
            "assembleText":"邻接矩阵优缺点： 优点： 直观、容易理解，可以很容易的判断出任意两个顶点是否有边，最大的优点就是很容易计算出各个顶点的度。 缺点： 当我么表示完全图的时候，邻接矩阵是最好的表示方法，但是对于稀疏矩阵，由于它边少，但是顶点多，这样就会造成空间的浪费。  ",
            "assembleScratchTime":"2019-03-23 21:31:56",
            "facetId":557720,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2863994,
            "assembleContent":"<h2>邻接表</h2><h3><p>数组的优缺点我们都已经熟知，那么使用邻接矩阵就一定会面临空间浪费的问题，上述示例中0或者∞越多，对应图中边数相对于顶点数而言较少时，空间的使用率也就越低。邻接表的思想和哈希表类似，使用数组结合链表的方式来存储图。</p></h3>  ",
            "assembleText":"邻接表 数组的优缺点我们都已经熟知，那么使用邻接矩阵就一定会面临空间浪费的问题，上述示例中0或者∞越多，对应图中边数相对于顶点数而言较少时，空间的使用率也就越低。邻接表的思想和哈希表类似，使用数组结合链表的方式来存储图。",
            "assembleScratchTime":"2019-03-23 20:56:25",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863995,
            "assembleContent":"<h3>无向图邻接表</h3><h3>使用一个数组来存储每个顶点，数组的每一位都包含一个链表，用来存储与此顶点相邻的边，示例如下：</h3><h2><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-5792b6eebffab5f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp"></div></div><div>无向图的邻接表</div></div></h2>  ",
            "assembleText":"无向图邻接表 使用一个数组来存储每个顶点，数组的每一位都包含一个链表，用来存储与此顶点相邻的边，示例如下： 无向图的邻接表",
            "assembleScratchTime":"2019-03-23 20:56:41",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863996,
            "assembleContent":"<h3>有向图的邻接表和无向图类似，但是它获取出度容易，获取入度却比较困难，如下所示：<br></h3><h3><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-6128f88316735fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/577/format/webp"></div></div><div>有向图邻接表</div></div></h3>  ",
            "assembleText":"有向图的邻接表和无向图类似，但是它获取出度容易，获取入度却比较困难，如下所示： 有向图邻接表",
            "assembleScratchTime":"2019-03-23 20:56:58",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863997,
            "assembleContent":"<h3><p>获取一个顶点的出度只需要计算链表的长度即可，但是入度却没有有效的获取方式，所以通常还会建立一个逆邻接表作为补充，如下所示：</p><div><div><div></div><div><img src="https://upload-images.jianshu.io/upload_images/1696815-5f29fadefffb2209.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/706/format/webp"></div></div><div>有向图逆邻接表</div></div></h3>  ",
            "assembleText":"获取一个顶点的出度只需要计算链表的长度即可，但是入度却没有有效的获取方式，所以通常还会建立一个逆邻接表作为补充，如下所示： 有向图逆邻接表",
            "assembleScratchTime":"2019-03-23 20:57:07",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864085,
            "assembleContent":"<ul><li><h3>邻接表</h3></li></ul><p>邻接表是图的一种链式存储结构。主要是应对于邻接矩阵在顶点多边少的时候，浪费空间的问题。它的方法就是声明两个结构。</p><p><br></p> ",
            "assembleText":"邻接表 邻接表是图的一种链式存储结构。主要是应对于邻接矩阵在顶点多边少的时候，浪费空间的问题。它的方法就是声明两个结构。",
            "assembleScratchTime":"2019-03-23 21:32:18",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864087,
            "assembleContent":"<div><span style="font-family: "Source Sans Pro", sans-serif; font-size: 24px;"><br></span></div><p><img src="https://upload-images.jianshu.io/upload_images/12340137-a059601fd35f8309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp" style="max-width:100%;"><br></p> ",
            "assembleText":"",
            "assembleScratchTime":"2019-03-23 21:32:51",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864089,
            "assembleContent":"<ul><li>邻接表的优缺点：<br>优点：<br>对于，稀疏图，邻接表比邻接矩阵更节约空间。<br>缺点：<br>不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。</li></ul> ",
            "assembleText":"邻接表的优缺点： 优点： 对于，稀疏图，邻接表比邻接矩阵更节约空间。 缺点： 不容易判断两个顶点是有关系（边），顶点的出度容易，但是求入度需要遍历整个邻接表。",
            "assembleScratchTime":"2019-03-23 21:33:08",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/1ceddc896da2",
            "type":"text"
        },
        {
            "assembleId":2864281,
            "assembleContent":"<p>邻接表的不足：若要确定图中边(U,V)是否存在，只能在顶点U邻接表中搜索V。  <br></p> ",
            "assembleText":"邻接表的不足：若要确定图中边(U,V)是否存在，只能在顶点U邻接表中搜索V。  ",
            "assembleScratchTime":"2019-03-23 23:30:05",
            "facetId":559837,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/b3df2a2e2a43",
            "type":"text"
        },
        {
            "assembleId":2863998,
            "assembleContent":"<h2>十字链表</h2><h3><p>邻接表在表示有向图时，需要邻接表和逆邻接表两张表配合使用，较为繁琐，我们可以把邻接表和逆邻接表结合为一张表，这就是十字链表。</p></h3>  ",
            "assembleText":"十字链表 邻接表在表示有向图时，需要邻接表和逆邻接表两张表配合使用，较为繁琐，我们可以把邻接表和逆邻接表结合为一张表，这就是十字链表。",
            "assembleScratchTime":"2019-03-23 20:57:45",
            "facetId":559838,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2863999,
            "assembleContent":"<h2><div><div><p>十字链表也使用数组来存储顶点，只是每一位数据除了顶点外，还有两个链表分别表示出边表和入边表，数据的结构如下所示：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-4b356d920b1ea794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/414/format/webp"></div>
</div>
<div>顶点结构定义</div>
</div>
<p>边表的结构也有所改变，结构如下：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-a9f4f33ff501f00c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/437/format/webp"></div>
</div>
<div>边表结构定义</div>
</div>
<p>其中，tailvex表示弧起点在顶点表的下标，headvex表示弧终点在顶点表的下标，headlink是入边表指针域，指向下一个终点相同的边，taillink是出边表指针域，指向下一个起点相同的边。</p></div><br><br>作者：大大纸飞机<br>链接：https://www.jianshu.com/p/9b263135be59<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h2>  ",
            "assembleText":"十字链表也使用数组来存储顶点，只是每一位数据除了顶点外，还有两个链表分别表示出边表和入边表，数据的结构如下所示： 顶点结构定义 边表的结构也有所改变，结构如下： 边表结构定义 其中，tailvex表示弧起点在顶点表的下标，headvex表示弧终点在顶点表的下标，headlink是入边表指针域，指向下一个终点相同的边，taillink是出边表指针域，指向下一个起点相同的边。 作者：大大纸飞机 链接：https://www.jianshu.com/p/9b263135be59 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 20:58:09",
            "facetId":559838,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864000,
            "assembleContent":"<h2>邻接多重表</h2><h2><div><div>
<p>十字链表是针对有向图的优化，而邻接表在表示无向图时也存在一定的问题。比如我们要把下图的边(v<sub>2</sub>, v<sub>0</sub>)删除，在邻接表中就要删除两个位置：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-5a4eb12d8b7b74ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp"></div>
</div>
<div>无向图的邻接表删除数据</div>
</div>
<p>可以看到，这是因为数据的重复造成的，所以我们可以仿照十字链表的方式构造一个邻接多重表，来解决以上问题。为此，需要重新定义边表结构，如下：</p>
<div>
<div>
<div></div>
<div><img src="//upload-images.jianshu.io/upload_images/1696815-a0dd2889a670a7d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/399/format/webp"></div>
</div>
<div>邻接多重表的边表结构</div>
</div>
<p>其中，ivex和jvex是某条边依附的两个顶点在顶点表的下标，ilink表示依附于顶点ivex的下一条边，jlink表示依附于顶点jvex的的下一条边。</p></div><br><br>作者：大大纸飞机<br>链接：https://www.jianshu.com/p/9b263135be59<br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</div></h2>  ",
            "assembleText":"邻接多重表 十字链表是针对有向图的优化，而邻接表在表示无向图时也存在一定的问题。比如我们要把下图的边(v2, v0)删除，在邻接表中就要删除两个位置： 无向图的邻接表删除数据 可以看到，这是因为数据的重复造成的，所以我们可以仿照十字链表的方式构造一个邻接多重表，来解决以上问题。为此，需要重新定义边表结构，如下： 邻接多重表的边表结构 其中，ivex和jvex是某条边依附的两个顶点在顶点表的下标，ilink表示依附于顶点ivex的下一条边，jlink表示依附于顶点jvex的的下一条边。 作者：大大纸飞机 链接：https://www.jianshu.com/p/9b263135be59 来源：简书 简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。",
            "assembleScratchTime":"2019-03-23 21:01:08",
            "facetId":559839,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        },
        {
            "assembleId":2864001,
            "assembleContent":"<h2>边集数组</h2><h2><p>如果我们仅关注边的操作，还可以使用边集数组，它由两个一维数组组成，一个数组用来存储顶点的信息，另一个数组存储边的信息。边的数组的每个元素都由一条边的起点下标、终点下标和权组成。这个存储方式主要用于寻找连通网的最小生成树算法：克鲁斯卡尔算法。</p></h2>  ",
            "assembleText":"边集数组 如果我们仅关注边的操作，还可以使用边集数组，它由两个一维数组组成，一个数组用来存储顶点的信息，另一个数组存储边的信息。边的数组的每个元素都由一条边的起点下标、终点下标和权组成。这个存储方式主要用于寻找连通网的最小生成树算法：克鲁斯卡尔算法。",
            "assembleScratchTime":"2019-03-23 21:01:56",
            "facetId":559840,
            "sourceId":11,
            "domainId":413,
            "url":"https://www.jianshu.com/p/9b263135be59",
            "type":"text"
        }
    ]
}